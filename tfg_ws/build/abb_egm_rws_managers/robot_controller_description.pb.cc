// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot_controller_description.proto

#include "robot_controller_description.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace abb {
namespace robot {
PROTOBUF_CONSTEXPR Header::Header(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.options_)*/{}
  , /*decltype(_impl_.ip_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.system_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.system_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.robot_ware_version_)*/nullptr
  , /*decltype(_impl_.rws_port_number_)*/0u} {}
struct HeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeaderDefaultTypeInternal() {}
  union {
    Header _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeaderDefaultTypeInternal _Header_default_instance_;
PROTOBUF_CONSTEXPR RobotControllerDescription::RobotControllerDescription(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mechanical_units_groups_)*/{}
  , /*decltype(_impl_.rapid_tasks_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.system_indicators_)*/nullptr} {}
struct RobotControllerDescriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RobotControllerDescriptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RobotControllerDescriptionDefaultTypeInternal() {}
  union {
    RobotControllerDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RobotControllerDescriptionDefaultTypeInternal _RobotControllerDescription_default_instance_;
PROTOBUF_CONSTEXPR RobotWareVersion::RobotWareVersion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.major_number_)*/0u
  , /*decltype(_impl_.minor_number_)*/0u
  , /*decltype(_impl_.patch_number_)*/0u} {}
struct RobotWareVersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RobotWareVersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RobotWareVersionDefaultTypeInternal() {}
  union {
    RobotWareVersion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RobotWareVersionDefaultTypeInternal _RobotWareVersion_default_instance_;
PROTOBUF_CONSTEXPR Cartesian::Cartesian(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0} {}
struct CartesianDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CartesianDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CartesianDefaultTypeInternal() {}
  union {
    Cartesian _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CartesianDefaultTypeInternal _Cartesian_default_instance_;
PROTOBUF_CONSTEXPR Quaternion::Quaternion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.q1_)*/0
  , /*decltype(_impl_.q2_)*/0
  , /*decltype(_impl_.q3_)*/0
  , /*decltype(_impl_.q4_)*/0} {}
struct QuaternionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuaternionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuaternionDefaultTypeInternal() {}
  union {
    Quaternion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuaternionDefaultTypeInternal _Quaternion_default_instance_;
PROTOBUF_CONSTEXPR Pose::Pose(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr} {}
struct PoseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PoseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PoseDefaultTypeInternal() {}
  union {
    Pose _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PoseDefaultTypeInternal _Pose_default_instance_;
PROTOBUF_CONSTEXPR RobotIndicators::RobotIndicators(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.irb14000_)*/false} {}
struct RobotIndicatorsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RobotIndicatorsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RobotIndicatorsDefaultTypeInternal() {}
  union {
    RobotIndicators _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RobotIndicatorsDefaultTypeInternal _RobotIndicators_default_instance_;
PROTOBUF_CONSTEXPR OptionIndicators::OptionIndicators(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.egm_)*/false
  , /*decltype(_impl_.leadthrough_)*/false
  , /*decltype(_impl_.multimove_)*/false} {}
struct OptionIndicatorsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OptionIndicatorsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OptionIndicatorsDefaultTypeInternal() {}
  union {
    OptionIndicators _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OptionIndicatorsDefaultTypeInternal _OptionIndicators_default_instance_;
PROTOBUF_CONSTEXPR AddInIndicators::AddInIndicators(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.smart_gripper_)*/false
  , /*decltype(_impl_.state_machine_1_0_)*/false
  , /*decltype(_impl_.state_machine_1_1_)*/false} {}
struct AddInIndicatorsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddInIndicatorsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddInIndicatorsDefaultTypeInternal() {}
  union {
    AddInIndicators _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddInIndicatorsDefaultTypeInternal _AddInIndicators_default_instance_;
PROTOBUF_CONSTEXPR SystemIndicators::SystemIndicators(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.robots_)*/nullptr
  , /*decltype(_impl_.options_)*/nullptr
  , /*decltype(_impl_.addins_)*/nullptr} {}
struct SystemIndicatorsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemIndicatorsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemIndicatorsDefaultTypeInternal() {}
  union {
    SystemIndicators _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemIndicatorsDefaultTypeInternal _SystemIndicators_default_instance_;
PROTOBUF_CONSTEXPR Transmission::Transmission(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rotating_move_)*/false} {}
struct TransmissionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransmissionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransmissionDefaultTypeInternal() {}
  union {
    Transmission _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransmissionDefaultTypeInternal _Transmission_default_instance_;
PROTOBUF_CONSTEXPR Arm::Arm(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lower_joint_bound_)*/0
  , /*decltype(_impl_.upper_joint_bound_)*/0} {}
struct ArmDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArmDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArmDefaultTypeInternal() {}
  union {
    Arm _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArmDefaultTypeInternal _Arm_default_instance_;
PROTOBUF_CONSTEXPR Joint::Joint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.arm_)*/nullptr
  , /*decltype(_impl_.transmission_)*/nullptr
  , /*decltype(_impl_.logical_axis_)*/0
  , /*decltype(_impl_.kinematic_axis_number_)*/0} {}
struct JointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JointDefaultTypeInternal() {}
  union {
    Joint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JointDefaultTypeInternal _Joint_default_instance_;
PROTOBUF_CONSTEXPR StandardizedJoint::StandardizedJoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.original_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.standardized_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lower_joint_bound_)*/0
  , /*decltype(_impl_.upper_joint_bound_)*/0
  , /*decltype(_impl_.rotating_move_)*/false} {}
struct StandardizedJointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StandardizedJointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StandardizedJointDefaultTypeInternal() {}
  union {
    StandardizedJoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StandardizedJointDefaultTypeInternal _StandardizedJoint_default_instance_;
PROTOBUF_CONSTEXPR Single::Single(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_frame_moved_by_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.joint_)*/nullptr
  , /*decltype(_impl_.base_frame_)*/nullptr} {}
struct SingleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SingleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SingleDefaultTypeInternal() {}
  union {
    Single _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SingleDefaultTypeInternal _Single_default_instance_;
PROTOBUF_CONSTEXPR Robot::Robot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.joints_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_frame_moved_by_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_frame_)*/nullptr} {}
struct RobotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RobotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RobotDefaultTypeInternal() {}
  union {
    Robot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RobotDefaultTypeInternal _Robot_default_instance_;
PROTOBUF_CONSTEXPR MechanicalUnit::MechanicalUnit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.singles_)*/{}
  , /*decltype(_impl_.standardized_joints_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.task_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_integrated_unit_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.has_integrated_unit_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.robot_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.axes_)*/0
  , /*decltype(_impl_.axes_total_)*/0
  , /*decltype(_impl_.mode_)*/0} {}
struct MechanicalUnitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MechanicalUnitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MechanicalUnitDefaultTypeInternal() {}
  union {
    MechanicalUnit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MechanicalUnitDefaultTypeInternal _MechanicalUnit_default_instance_;
PROTOBUF_CONSTEXPR MechanicalUnitGroup::MechanicalUnitGroup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mechanical_units_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.robot_)*/nullptr} {}
struct MechanicalUnitGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MechanicalUnitGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MechanicalUnitGroupDefaultTypeInternal() {}
  union {
    MechanicalUnitGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MechanicalUnitGroupDefaultTypeInternal _MechanicalUnitGroup_default_instance_;
PROTOBUF_CONSTEXPR RAPIDModule::RAPIDModule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct RAPIDModuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RAPIDModuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RAPIDModuleDefaultTypeInternal() {}
  union {
    RAPIDModule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RAPIDModuleDefaultTypeInternal _RAPIDModule_default_instance_;
PROTOBUF_CONSTEXPR RAPIDTask::RAPIDTask(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.modules_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_motion_task_)*/false
  , /*decltype(_impl_.is_active_)*/false
  , /*decltype(_impl_.execution_state_)*/1} {}
struct RAPIDTaskDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RAPIDTaskDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RAPIDTaskDefaultTypeInternal() {}
  union {
    RAPIDTask _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RAPIDTaskDefaultTypeInternal _RAPIDTask_default_instance_;
}  // namespace robot
}  // namespace abb
static ::_pb::Metadata file_level_metadata_robot_5fcontroller_5fdescription_2eproto[20];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_robot_5fcontroller_5fdescription_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_robot_5fcontroller_5fdescription_2eproto = nullptr;

const uint32_t TableStruct_robot_5fcontroller_5fdescription_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, _impl_.ip_address_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, _impl_.rws_port_number_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, _impl_.robot_ware_version_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, _impl_.system_name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, _impl_.system_type_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Header, _impl_.options_),
  0,
  4,
  3,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotControllerDescription, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotControllerDescription, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotControllerDescription, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotControllerDescription, _impl_.system_indicators_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotControllerDescription, _impl_.mechanical_units_groups_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotControllerDescription, _impl_.rapid_tasks_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotWareVersion, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotWareVersion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotWareVersion, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotWareVersion, _impl_.major_number_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotWareVersion, _impl_.minor_number_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotWareVersion, _impl_.patch_number_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Cartesian, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Cartesian, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Cartesian, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Cartesian, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Cartesian, _impl_.z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Quaternion, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Quaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Quaternion, _impl_.q1_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Quaternion, _impl_.q2_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Quaternion, _impl_.q3_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Quaternion, _impl_.q4_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Pose, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Pose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Pose, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Pose, _impl_.rotation_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotIndicators, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotIndicators, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::RobotIndicators, _impl_.irb14000_),
  0,
  PROTOBUF_FIELD_OFFSET(::abb::robot::OptionIndicators, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::OptionIndicators, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::OptionIndicators, _impl_.egm_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::OptionIndicators, _impl_.leadthrough_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::OptionIndicators, _impl_.multimove_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::AddInIndicators, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::AddInIndicators, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::AddInIndicators, _impl_.smart_gripper_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::AddInIndicators, _impl_.state_machine_1_0_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::AddInIndicators, _impl_.state_machine_1_1_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::SystemIndicators, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::SystemIndicators, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::SystemIndicators, _impl_.robots_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::SystemIndicators, _impl_.options_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::SystemIndicators, _impl_.addins_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Transmission, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Transmission, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Transmission, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Transmission, _impl_.rotating_move_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Arm, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Arm, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Arm, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Arm, _impl_.lower_joint_bound_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Arm, _impl_.upper_joint_bound_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, _impl_.logical_axis_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, _impl_.kinematic_axis_number_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, _impl_.arm_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Joint, _impl_.transmission_),
  0,
  3,
  4,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, _impl_.original_name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, _impl_.standardized_name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, _impl_.rotating_move_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, _impl_.lower_joint_bound_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::StandardizedJoint, _impl_.upper_joint_bound_),
  0,
  1,
  4,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, _impl_.joint_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, _impl_.base_frame_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Single, _impl_.base_frame_moved_by_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, _impl_.joints_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, _impl_.base_frame_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::Robot, _impl_.base_frame_moved_by_),
  0,
  1,
  ~0u,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_.robot_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_.singles_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_.task_name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_.axes_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_.axes_total_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_.is_integrated_unit_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_.has_integrated_unit_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnit, _impl_.standardized_joints_),
  0,
  5,
  ~0u,
  6,
  1,
  7,
  8,
  2,
  3,
  4,
  9,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnitGroup, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnitGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnitGroup, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnitGroup, _impl_.robot_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::MechanicalUnitGroup, _impl_.mechanical_units_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDModule, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDModule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDModule, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDModule, _impl_.type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, _impl_.is_motion_task_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, _impl_.is_active_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, _impl_.execution_state_),
  PROTOBUF_FIELD_OFFSET(::abb::robot::RAPIDTask, _impl_.modules_),
  0,
  1,
  2,
  3,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 12, -1, sizeof(::abb::robot::Header)},
  { 18, 28, -1, sizeof(::abb::robot::RobotControllerDescription)},
  { 32, 42, -1, sizeof(::abb::robot::RobotWareVersion)},
  { 46, 55, -1, sizeof(::abb::robot::Cartesian)},
  { 58, 68, -1, sizeof(::abb::robot::Quaternion)},
  { 72, 80, -1, sizeof(::abb::robot::Pose)},
  { 82, 89, -1, sizeof(::abb::robot::RobotIndicators)},
  { 90, 99, -1, sizeof(::abb::robot::OptionIndicators)},
  { 102, 111, -1, sizeof(::abb::robot::AddInIndicators)},
  { 114, 123, -1, sizeof(::abb::robot::SystemIndicators)},
  { 126, 134, -1, sizeof(::abb::robot::Transmission)},
  { 136, 145, -1, sizeof(::abb::robot::Arm)},
  { 148, 159, -1, sizeof(::abb::robot::Joint)},
  { 164, 175, -1, sizeof(::abb::robot::StandardizedJoint)},
  { 180, 191, -1, sizeof(::abb::robot::Single)},
  { 196, 207, -1, sizeof(::abb::robot::Robot)},
  { 212, 230, -1, sizeof(::abb::robot::MechanicalUnit)},
  { 242, 251, -1, sizeof(::abb::robot::MechanicalUnitGroup)},
  { 254, 262, -1, sizeof(::abb::robot::RAPIDModule)},
  { 264, 275, -1, sizeof(::abb::robot::RAPIDTask)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::abb::robot::_Header_default_instance_._instance,
  &::abb::robot::_RobotControllerDescription_default_instance_._instance,
  &::abb::robot::_RobotWareVersion_default_instance_._instance,
  &::abb::robot::_Cartesian_default_instance_._instance,
  &::abb::robot::_Quaternion_default_instance_._instance,
  &::abb::robot::_Pose_default_instance_._instance,
  &::abb::robot::_RobotIndicators_default_instance_._instance,
  &::abb::robot::_OptionIndicators_default_instance_._instance,
  &::abb::robot::_AddInIndicators_default_instance_._instance,
  &::abb::robot::_SystemIndicators_default_instance_._instance,
  &::abb::robot::_Transmission_default_instance_._instance,
  &::abb::robot::_Arm_default_instance_._instance,
  &::abb::robot::_Joint_default_instance_._instance,
  &::abb::robot::_StandardizedJoint_default_instance_._instance,
  &::abb::robot::_Single_default_instance_._instance,
  &::abb::robot::_Robot_default_instance_._instance,
  &::abb::robot::_MechanicalUnit_default_instance_._instance,
  &::abb::robot::_MechanicalUnitGroup_default_instance_._instance,
  &::abb::robot::_RAPIDModule_default_instance_._instance,
  &::abb::robot::_RAPIDTask_default_instance_._instance,
};

const char descriptor_table_protodef_robot_5fcontroller_5fdescription_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\"robot_controller_description.proto\022\tab"
  "b.robot\"\251\001\n\006Header\022\022\n\nip_address\030\001 \001(\t\022\027"
  "\n\017rws_port_number\030\002 \001(\r\0227\n\022robot_ware_ve"
  "rsion\030\003 \001(\0132\033.abb.robot.RobotWareVersion"
  "\022\023\n\013system_name\030\004 \001(\t\022\023\n\013system_type\030\005 \001"
  "(\t\022\017\n\007options\030\006 \003(\t\"\343\001\n\032RobotControllerD"
  "escription\022!\n\006header\030\001 \001(\0132\021.abb.robot.H"
  "eader\0226\n\021system_indicators\030\002 \001(\0132\033.abb.r"
  "obot.SystemIndicators\022\?\n\027mechanical_unit"
  "s_groups\030\003 \003(\0132\036.abb.robot.MechanicalUni"
  "tGroup\022)\n\013rapid_tasks\030\004 \003(\0132\024.abb.robot."
  "RAPIDTask\"b\n\020RobotWareVersion\022\014\n\004name\030\001 "
  "\001(\t\022\024\n\014major_number\030\002 \001(\r\022\024\n\014minor_numbe"
  "r\030\003 \001(\r\022\024\n\014patch_number\030\004 \001(\r\",\n\tCartesi"
  "an\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\"<\n\nQ"
  "uaternion\022\n\n\002q1\030\001 \001(\001\022\n\n\002q2\030\002 \001(\001\022\n\n\002q3\030"
  "\003 \001(\001\022\n\n\002q4\030\004 \001(\001\"W\n\004Pose\022&\n\010position\030\001 "
  "\001(\0132\024.abb.robot.Cartesian\022\'\n\010rotation\030\002 "
  "\001(\0132\025.abb.robot.Quaternion\"#\n\017RobotIndic"
  "ators\022\020\n\010irb14000\030\001 \001(\010\"G\n\020OptionIndicat"
  "ors\022\013\n\003egm\030\001 \001(\010\022\023\n\013leadthrough\030\002 \001(\010\022\021\n"
  "\tmultimove\030\003 \001(\010\"^\n\017AddInIndicators\022\025\n\rs"
  "mart_gripper\030\001 \001(\010\022\031\n\021state_machine_1_0\030"
  "\002 \001(\010\022\031\n\021state_machine_1_1\030\003 \001(\010\"\230\001\n\020Sys"
  "temIndicators\022*\n\006robots\030\001 \001(\0132\032.abb.robo"
  "t.RobotIndicators\022,\n\007options\030\002 \001(\0132\033.abb"
  ".robot.OptionIndicators\022*\n\006addins\030\003 \001(\0132"
  "\032.abb.robot.AddInIndicators\"3\n\014Transmiss"
  "ion\022\014\n\004name\030\001 \001(\t\022\025\n\rrotating_move\030\002 \001(\010"
  "\"I\n\003Arm\022\014\n\004name\030\001 \001(\t\022\031\n\021lower_joint_bou"
  "nd\030\002 \001(\001\022\031\n\021upper_joint_bound\030\003 \001(\001\"\226\001\n\005"
  "Joint\022\014\n\004name\030\001 \001(\t\022\024\n\014logical_axis\030\002 \001("
  "\005\022\035\n\025kinematic_axis_number\030\003 \001(\005\022\033\n\003arm\030"
  "\004 \001(\0132\016.abb.robot.Arm\022-\n\014transmission\030\005 "
  "\001(\0132\027.abb.robot.Transmission\"\222\001\n\021Standar"
  "dizedJoint\022\025\n\roriginal_name\030\001 \001(\t\022\031\n\021sta"
  "ndardized_name\030\002 \001(\t\022\025\n\rrotating_move\030\003 "
  "\001(\010\022\031\n\021lower_joint_bound\030\004 \001(\001\022\031\n\021upper_"
  "joint_bound\030\005 \001(\001\"\207\001\n\006Single\022\014\n\004name\030\001 \001"
  "(\t\022\014\n\004type\030\002 \001(\t\022\037\n\005joint\030\003 \001(\0132\020.abb.ro"
  "bot.Joint\022#\n\nbase_frame\030\004 \001(\0132\017.abb.robo"
  "t.Pose\022\033\n\023base_frame_moved_by\030\005 \001(\t\"\207\001\n\005"
  "Robot\022\014\n\004name\030\001 \001(\t\022\014\n\004type\030\002 \001(\t\022 \n\006joi"
  "nts\030\003 \003(\0132\020.abb.robot.Joint\022#\n\nbase_fram"
  "e\030\004 \001(\0132\017.abb.robot.Pose\022\033\n\023base_frame_m"
  "oved_by\030\005 \001(\t\"\377\003\n\016MechanicalUnit\022\014\n\004name"
  "\030\001 \001(\t\022\037\n\005robot\030\002 \001(\0132\020.abb.robot.Robot\022"
  "\"\n\007singles\030\003 \003(\0132\021.abb.robot.Single\0227\n\004t"
  "ype\030\004 \001(\0162\036.abb.robot.MechanicalUnit.Typ"
  "e:\tUNDEFINED\022\021\n\ttask_name\030\005 \001(\t\022\014\n\004axes\030"
  "\006 \001(\005\022\022\n\naxes_total\030\007 \001(\005\022\032\n\022is_integrat"
  "ed_unit\030\010 \001(\t\022\033\n\023has_integrated_unit\030\t \001"
  "(\t\022\016\n\006status\030\n \001(\t\0229\n\004mode\030\013 \001(\0162\036.abb.r"
  "obot.MechanicalUnit.Mode:\013DEACTIVATED\0229\n"
  "\023standardized_joints\030\014 \003(\0132\034.abb.robot.S"
  "tandardizedJoint\"E\n\004Type\022\r\n\tUNDEFINED\020\000\022"
  "\010\n\004NONE\020\001\022\r\n\tTCP_ROBOT\020\002\022\t\n\005ROBOT\020\003\022\n\n\006S"
  "INGLE\020\004\"&\n\004Mode\022\017\n\013DEACTIVATED\020\000\022\r\n\tACTI"
  "VATED\020\001\"\202\001\n\023MechanicalUnitGroup\022\014\n\004name\030"
  "\001 \001(\t\022(\n\005robot\030\002 \001(\0132\031.abb.robot.Mechani"
  "calUnit\0223\n\020mechanical_units\030\003 \003(\0132\031.abb."
  "robot.MechanicalUnit\")\n\013RAPIDModule\022\014\n\004n"
  "ame\030\001 \001(\t\022\014\n\004type\030\002 \001(\t\"\213\002\n\tRAPIDTask\022\014\n"
  "\004name\030\001 \001(\t\022\026\n\016is_motion_task\030\002 \001(\010\022\021\n\ti"
  "s_active\030\003 \001(\010\022E\n\017execution_state\030\004 \001(\0162"
  "#.abb.robot.RAPIDTask.ExecutionState:\007UN"
  "KNOWN\022\'\n\007modules\030\005 \003(\0132\026.abb.robot.RAPID"
  "Module\"U\n\016ExecutionState\022\013\n\007UNKNOWN\020\001\022\t\n"
  "\005READY\020\002\022\013\n\007STOPPED\020\003\022\013\n\007STARTED\020\004\022\021\n\rUN"
  "INITIALIZED\020\005"
  ;
static ::_pbi::once_flag descriptor_table_robot_5fcontroller_5fdescription_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_robot_5fcontroller_5fdescription_2eproto = {
    false, false, 2773, descriptor_table_protodef_robot_5fcontroller_5fdescription_2eproto,
    "robot_controller_description.proto",
    &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once, nullptr, 0, 20,
    schemas, file_default_instances, TableStruct_robot_5fcontroller_5fdescription_2eproto::offsets,
    file_level_metadata_robot_5fcontroller_5fdescription_2eproto, file_level_enum_descriptors_robot_5fcontroller_5fdescription_2eproto,
    file_level_service_descriptors_robot_5fcontroller_5fdescription_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter() {
  return &descriptor_table_robot_5fcontroller_5fdescription_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_robot_5fcontroller_5fdescription_2eproto(&descriptor_table_robot_5fcontroller_5fdescription_2eproto);
namespace abb {
namespace robot {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MechanicalUnit_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_robot_5fcontroller_5fdescription_2eproto);
  return file_level_enum_descriptors_robot_5fcontroller_5fdescription_2eproto[0];
}
bool MechanicalUnit_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MechanicalUnit_Type MechanicalUnit::UNDEFINED;
constexpr MechanicalUnit_Type MechanicalUnit::NONE;
constexpr MechanicalUnit_Type MechanicalUnit::TCP_ROBOT;
constexpr MechanicalUnit_Type MechanicalUnit::ROBOT;
constexpr MechanicalUnit_Type MechanicalUnit::SINGLE;
constexpr MechanicalUnit_Type MechanicalUnit::Type_MIN;
constexpr MechanicalUnit_Type MechanicalUnit::Type_MAX;
constexpr int MechanicalUnit::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MechanicalUnit_Mode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_robot_5fcontroller_5fdescription_2eproto);
  return file_level_enum_descriptors_robot_5fcontroller_5fdescription_2eproto[1];
}
bool MechanicalUnit_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MechanicalUnit_Mode MechanicalUnit::DEACTIVATED;
constexpr MechanicalUnit_Mode MechanicalUnit::ACTIVATED;
constexpr MechanicalUnit_Mode MechanicalUnit::Mode_MIN;
constexpr MechanicalUnit_Mode MechanicalUnit::Mode_MAX;
constexpr int MechanicalUnit::Mode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RAPIDTask_ExecutionState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_robot_5fcontroller_5fdescription_2eproto);
  return file_level_enum_descriptors_robot_5fcontroller_5fdescription_2eproto[2];
}
bool RAPIDTask_ExecutionState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RAPIDTask_ExecutionState RAPIDTask::UNKNOWN;
constexpr RAPIDTask_ExecutionState RAPIDTask::READY;
constexpr RAPIDTask_ExecutionState RAPIDTask::STOPPED;
constexpr RAPIDTask_ExecutionState RAPIDTask::STARTED;
constexpr RAPIDTask_ExecutionState RAPIDTask::UNINITIALIZED;
constexpr RAPIDTask_ExecutionState RAPIDTask::ExecutionState_MIN;
constexpr RAPIDTask_ExecutionState RAPIDTask::ExecutionState_MAX;
constexpr int RAPIDTask::ExecutionState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Header::_Internal {
 public:
  using HasBits = decltype(std::declval<Header>()._impl_._has_bits_);
  static void set_has_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rws_port_number(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::abb::robot::RobotWareVersion& robot_ware_version(const Header* msg);
  static void set_has_robot_ware_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_system_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_system_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::robot::RobotWareVersion&
Header::_Internal::robot_ware_version(const Header* msg) {
  return *msg->_impl_.robot_ware_version_;
}
Header::Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.Header)
}
Header::Header(const Header& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Header* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.options_){from._impl_.options_}
    , decltype(_impl_.ip_address_){}
    , decltype(_impl_.system_name_){}
    , decltype(_impl_.system_type_){}
    , decltype(_impl_.robot_ware_version_){nullptr}
    , decltype(_impl_.rws_port_number_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ip_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip_address()) {
    _this->_impl_.ip_address_.Set(from._internal_ip_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.system_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_system_name()) {
    _this->_impl_.system_name_.Set(from._internal_system_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.system_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_system_type()) {
    _this->_impl_.system_type_.Set(from._internal_system_type(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_robot_ware_version()) {
    _this->_impl_.robot_ware_version_ = new ::abb::robot::RobotWareVersion(*from._impl_.robot_ware_version_);
  }
  _this->_impl_.rws_port_number_ = from._impl_.rws_port_number_;
  // @@protoc_insertion_point(copy_constructor:abb.robot.Header)
}

inline void Header::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.options_){arena}
    , decltype(_impl_.ip_address_){}
    , decltype(_impl_.system_name_){}
    , decltype(_impl_.system_type_){}
    , decltype(_impl_.robot_ware_version_){nullptr}
    , decltype(_impl_.rws_port_number_){0u}
  };
  _impl_.ip_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.system_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.system_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Header::~Header() {
  // @@protoc_insertion_point(destructor:abb.robot.Header)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Header::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.options_.~RepeatedPtrField();
  _impl_.ip_address_.Destroy();
  _impl_.system_name_.Destroy();
  _impl_.system_type_.Destroy();
  if (this != internal_default_instance()) delete _impl_.robot_ware_version_;
}

void Header::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Header::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Header)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.options_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ip_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.system_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.system_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.robot_ware_version_ != nullptr);
      _impl_.robot_ware_version_->Clear();
    }
  }
  _impl_.rws_port_number_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Header::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ip_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.Header.ip_address");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rws_port_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rws_port_number(&has_bits);
          _impl_.rws_port_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.RobotWareVersion robot_ware_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_robot_ware_version(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string system_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_system_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.Header.system_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string system_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_system_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.Header.system_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string options = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_options();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "abb.robot.Header.options");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Header::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Header)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string ip_address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ip_address().data(), static_cast<int>(this->_internal_ip_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Header.ip_address");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip_address(), target);
  }

  // optional uint32 rws_port_number = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_rws_port_number(), target);
  }

  // optional .abb.robot.RobotWareVersion robot_ware_version = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::robot_ware_version(this),
        _Internal::robot_ware_version(this).GetCachedSize(), target, stream);
  }

  // optional string system_name = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_system_name().data(), static_cast<int>(this->_internal_system_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Header.system_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_system_name(), target);
  }

  // optional string system_type = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_system_type().data(), static_cast<int>(this->_internal_system_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Header.system_type");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_system_type(), target);
  }

  // repeated string options = 6;
  for (int i = 0, n = this->_internal_options_size(); i < n; i++) {
    const auto& s = this->_internal_options(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Header.options");
    target = stream->WriteString(6, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Header)
  return target;
}

size_t Header::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Header)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string options = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.options_.size());
  for (int i = 0, n = _impl_.options_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.options_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string ip_address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ip_address());
    }

    // optional string system_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_system_name());
    }

    // optional string system_type = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_system_type());
    }

    // optional .abb.robot.RobotWareVersion robot_ware_version = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.robot_ware_version_);
    }

    // optional uint32 rws_port_number = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rws_port_number());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Header::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Header::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Header::GetClassData() const { return &_class_data_; }


void Header::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Header*>(&to_msg);
  auto& from = static_cast<const Header&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Header)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.options_.MergeFrom(from._impl_.options_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ip_address(from._internal_ip_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_system_name(from._internal_system_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_system_type(from._internal_system_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_robot_ware_version()->::abb::robot::RobotWareVersion::MergeFrom(
          from._internal_robot_ware_version());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rws_port_number_ = from._impl_.rws_port_number_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Header::CopyFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Header::IsInitialized() const {
  return true;
}

void Header::InternalSwap(Header* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.options_.InternalSwap(&other->_impl_.options_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_address_, lhs_arena,
      &other->_impl_.ip_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.system_name_, lhs_arena,
      &other->_impl_.system_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.system_type_, lhs_arena,
      &other->_impl_.system_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Header, _impl_.rws_port_number_)
      + sizeof(Header::_impl_.rws_port_number_)
      - PROTOBUF_FIELD_OFFSET(Header, _impl_.robot_ware_version_)>(
          reinterpret_cast<char*>(&_impl_.robot_ware_version_),
          reinterpret_cast<char*>(&other->_impl_.robot_ware_version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Header::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[0]);
}

// ===================================================================

class RobotControllerDescription::_Internal {
 public:
  using HasBits = decltype(std::declval<RobotControllerDescription>()._impl_._has_bits_);
  static const ::abb::robot::Header& header(const RobotControllerDescription* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::robot::SystemIndicators& system_indicators(const RobotControllerDescription* msg);
  static void set_has_system_indicators(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::abb::robot::Header&
RobotControllerDescription::_Internal::header(const RobotControllerDescription* msg) {
  return *msg->_impl_.header_;
}
const ::abb::robot::SystemIndicators&
RobotControllerDescription::_Internal::system_indicators(const RobotControllerDescription* msg) {
  return *msg->_impl_.system_indicators_;
}
RobotControllerDescription::RobotControllerDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.RobotControllerDescription)
}
RobotControllerDescription::RobotControllerDescription(const RobotControllerDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RobotControllerDescription* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mechanical_units_groups_){from._impl_.mechanical_units_groups_}
    , decltype(_impl_.rapid_tasks_){from._impl_.rapid_tasks_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.system_indicators_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::abb::robot::Header(*from._impl_.header_);
  }
  if (from._internal_has_system_indicators()) {
    _this->_impl_.system_indicators_ = new ::abb::robot::SystemIndicators(*from._impl_.system_indicators_);
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.RobotControllerDescription)
}

inline void RobotControllerDescription::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mechanical_units_groups_){arena}
    , decltype(_impl_.rapid_tasks_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.system_indicators_){nullptr}
  };
}

RobotControllerDescription::~RobotControllerDescription() {
  // @@protoc_insertion_point(destructor:abb.robot.RobotControllerDescription)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RobotControllerDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mechanical_units_groups_.~RepeatedPtrField();
  _impl_.rapid_tasks_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.system_indicators_;
}

void RobotControllerDescription::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RobotControllerDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.RobotControllerDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mechanical_units_groups_.Clear();
  _impl_.rapid_tasks_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.system_indicators_ != nullptr);
      _impl_.system_indicators_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotControllerDescription::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.robot.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.SystemIndicators system_indicators = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_system_indicators(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.MechanicalUnitGroup mechanical_units_groups = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mechanical_units_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.RAPIDTask rapid_tasks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rapid_tasks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RobotControllerDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.RobotControllerDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .abb.robot.Header header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional .abb.robot.SystemIndicators system_indicators = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::system_indicators(this),
        _Internal::system_indicators(this).GetCachedSize(), target, stream);
  }

  // repeated .abb.robot.MechanicalUnitGroup mechanical_units_groups = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mechanical_units_groups_size()); i < n; i++) {
    const auto& repfield = this->_internal_mechanical_units_groups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .abb.robot.RAPIDTask rapid_tasks = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rapid_tasks_size()); i < n; i++) {
    const auto& repfield = this->_internal_rapid_tasks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.RobotControllerDescription)
  return target;
}

size_t RobotControllerDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.RobotControllerDescription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .abb.robot.MechanicalUnitGroup mechanical_units_groups = 3;
  total_size += 1UL * this->_internal_mechanical_units_groups_size();
  for (const auto& msg : this->_impl_.mechanical_units_groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .abb.robot.RAPIDTask rapid_tasks = 4;
  total_size += 1UL * this->_internal_rapid_tasks_size();
  for (const auto& msg : this->_impl_.rapid_tasks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.robot.Header header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional .abb.robot.SystemIndicators system_indicators = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.system_indicators_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotControllerDescription::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RobotControllerDescription::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotControllerDescription::GetClassData() const { return &_class_data_; }


void RobotControllerDescription::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RobotControllerDescription*>(&to_msg);
  auto& from = static_cast<const RobotControllerDescription&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.RobotControllerDescription)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.mechanical_units_groups_.MergeFrom(from._impl_.mechanical_units_groups_);
  _this->_impl_.rapid_tasks_.MergeFrom(from._impl_.rapid_tasks_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header()->::abb::robot::Header::MergeFrom(
          from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_system_indicators()->::abb::robot::SystemIndicators::MergeFrom(
          from._internal_system_indicators());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotControllerDescription::CopyFrom(const RobotControllerDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.RobotControllerDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotControllerDescription::IsInitialized() const {
  return true;
}

void RobotControllerDescription::InternalSwap(RobotControllerDescription* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.mechanical_units_groups_.InternalSwap(&other->_impl_.mechanical_units_groups_);
  _impl_.rapid_tasks_.InternalSwap(&other->_impl_.rapid_tasks_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotControllerDescription, _impl_.system_indicators_)
      + sizeof(RobotControllerDescription::_impl_.system_indicators_)
      - PROTOBUF_FIELD_OFFSET(RobotControllerDescription, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotControllerDescription::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[1]);
}

// ===================================================================

class RobotWareVersion::_Internal {
 public:
  using HasBits = decltype(std::declval<RobotWareVersion>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_major_number(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_minor_number(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_patch_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

RobotWareVersion::RobotWareVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.RobotWareVersion)
}
RobotWareVersion::RobotWareVersion(const RobotWareVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RobotWareVersion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.major_number_){}
    , decltype(_impl_.minor_number_){}
    , decltype(_impl_.patch_number_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.major_number_, &from._impl_.major_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.patch_number_) -
    reinterpret_cast<char*>(&_impl_.major_number_)) + sizeof(_impl_.patch_number_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.RobotWareVersion)
}

inline void RobotWareVersion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.major_number_){0u}
    , decltype(_impl_.minor_number_){0u}
    , decltype(_impl_.patch_number_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RobotWareVersion::~RobotWareVersion() {
  // @@protoc_insertion_point(destructor:abb.robot.RobotWareVersion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RobotWareVersion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void RobotWareVersion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RobotWareVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.RobotWareVersion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.major_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.patch_number_) -
        reinterpret_cast<char*>(&_impl_.major_number_)) + sizeof(_impl_.patch_number_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotWareVersion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.RobotWareVersion.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 major_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_major_number(&has_bits);
          _impl_.major_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 minor_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_minor_number(&has_bits);
          _impl_.minor_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 patch_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_patch_number(&has_bits);
          _impl_.patch_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RobotWareVersion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.RobotWareVersion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.RobotWareVersion.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 major_number = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_major_number(), target);
  }

  // optional uint32 minor_number = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_minor_number(), target);
  }

  // optional uint32 patch_number = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_patch_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.RobotWareVersion)
  return target;
}

size_t RobotWareVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.RobotWareVersion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 major_number = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_major_number());
    }

    // optional uint32 minor_number = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_minor_number());
    }

    // optional uint32 patch_number = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_patch_number());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotWareVersion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RobotWareVersion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotWareVersion::GetClassData() const { return &_class_data_; }


void RobotWareVersion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RobotWareVersion*>(&to_msg);
  auto& from = static_cast<const RobotWareVersion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.RobotWareVersion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.major_number_ = from._impl_.major_number_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.minor_number_ = from._impl_.minor_number_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.patch_number_ = from._impl_.patch_number_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotWareVersion::CopyFrom(const RobotWareVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.RobotWareVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotWareVersion::IsInitialized() const {
  return true;
}

void RobotWareVersion::InternalSwap(RobotWareVersion* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotWareVersion, _impl_.patch_number_)
      + sizeof(RobotWareVersion::_impl_.patch_number_)
      - PROTOBUF_FIELD_OFFSET(RobotWareVersion, _impl_.major_number_)>(
          reinterpret_cast<char*>(&_impl_.major_number_),
          reinterpret_cast<char*>(&other->_impl_.major_number_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotWareVersion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[2]);
}

// ===================================================================

class Cartesian::_Internal {
 public:
  using HasBits = decltype(std::declval<Cartesian>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Cartesian::Cartesian(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.Cartesian)
}
Cartesian::Cartesian(const Cartesian& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Cartesian* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.Cartesian)
}

inline void Cartesian::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
  };
}

Cartesian::~Cartesian() {
  // @@protoc_insertion_point(destructor:abb.robot.Cartesian)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Cartesian::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Cartesian::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Cartesian::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Cartesian)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.z_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Cartesian::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Cartesian::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Cartesian)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Cartesian)
  return target;
}

size_t Cartesian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Cartesian)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Cartesian::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Cartesian::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Cartesian::GetClassData() const { return &_class_data_; }


void Cartesian::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Cartesian*>(&to_msg);
  auto& from = static_cast<const Cartesian&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Cartesian)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Cartesian::CopyFrom(const Cartesian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Cartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cartesian::IsInitialized() const {
  return true;
}

void Cartesian::InternalSwap(Cartesian* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Cartesian, _impl_.z_)
      + sizeof(Cartesian::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Cartesian, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Cartesian::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[3]);
}

// ===================================================================

class Quaternion::_Internal {
 public:
  using HasBits = decltype(std::declval<Quaternion>()._impl_._has_bits_);
  static void set_has_q1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_q2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_q3(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_q4(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Quaternion::Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.Quaternion)
}
Quaternion::Quaternion(const Quaternion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Quaternion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.q1_){}
    , decltype(_impl_.q2_){}
    , decltype(_impl_.q3_){}
    , decltype(_impl_.q4_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.q1_, &from._impl_.q1_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.q4_) -
    reinterpret_cast<char*>(&_impl_.q1_)) + sizeof(_impl_.q4_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.Quaternion)
}

inline void Quaternion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.q1_){0}
    , decltype(_impl_.q2_){0}
    , decltype(_impl_.q3_){0}
    , decltype(_impl_.q4_){0}
  };
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:abb.robot.Quaternion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Quaternion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Quaternion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Quaternion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.q1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.q4_) -
        reinterpret_cast<char*>(&_impl_.q1_)) + sizeof(_impl_.q4_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Quaternion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double q1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_q1(&has_bits);
          _impl_.q1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double q2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_q2(&has_bits);
          _impl_.q2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double q3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_q3(&has_bits);
          _impl_.q3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double q4 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_q4(&has_bits);
          _impl_.q4_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Quaternion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Quaternion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double q1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_q1(), target);
  }

  // optional double q2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_q2(), target);
  }

  // optional double q3 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_q3(), target);
  }

  // optional double q4 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_q4(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Quaternion)
  return target;
}

size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Quaternion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional double q1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double q2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double q3 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double q4 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Quaternion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Quaternion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Quaternion::GetClassData() const { return &_class_data_; }


void Quaternion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Quaternion*>(&to_msg);
  auto& from = static_cast<const Quaternion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Quaternion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.q1_ = from._impl_.q1_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.q2_ = from._impl_.q2_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.q3_ = from._impl_.q3_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.q4_ = from._impl_.q4_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  return true;
}

void Quaternion::InternalSwap(Quaternion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.q4_)
      + sizeof(Quaternion::_impl_.q4_)
      - PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.q1_)>(
          reinterpret_cast<char*>(&_impl_.q1_),
          reinterpret_cast<char*>(&other->_impl_.q1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Quaternion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[4]);
}

// ===================================================================

class Pose::_Internal {
 public:
  using HasBits = decltype(std::declval<Pose>()._impl_._has_bits_);
  static const ::abb::robot::Cartesian& position(const Pose* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::robot::Quaternion& rotation(const Pose* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::abb::robot::Cartesian&
Pose::_Internal::position(const Pose* msg) {
  return *msg->_impl_.position_;
}
const ::abb::robot::Quaternion&
Pose::_Internal::rotation(const Pose* msg) {
  return *msg->_impl_.rotation_;
}
Pose::Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.Pose)
}
Pose::Pose(const Pose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Pose* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.rotation_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::abb::robot::Cartesian(*from._impl_.position_);
  }
  if (from._internal_has_rotation()) {
    _this->_impl_.rotation_ = new ::abb::robot::Quaternion(*from._impl_.rotation_);
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.Pose)
}

inline void Pose::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
  };
}

Pose::~Pose() {
  // @@protoc_insertion_point(destructor:abb.robot.Pose)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Pose::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
}

void Pose::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Pose::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Pose)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Pose::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.robot.Cartesian position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Quaternion rotation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Pose::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Pose)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .abb.robot.Cartesian position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional .abb.robot.Quaternion rotation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Pose)
  return target;
}

size_t Pose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Pose)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.robot.Cartesian position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional .abb.robot.Quaternion rotation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rotation_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Pose::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Pose::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Pose::GetClassData() const { return &_class_data_; }


void Pose::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Pose*>(&to_msg);
  auto& from = static_cast<const Pose&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Pose)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::abb::robot::Cartesian::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_rotation()->::abb::robot::Quaternion::MergeFrom(
          from._internal_rotation());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Pose::CopyFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pose::IsInitialized() const {
  return true;
}

void Pose::InternalSwap(Pose* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Pose, _impl_.rotation_)
      + sizeof(Pose::_impl_.rotation_)
      - PROTOBUF_FIELD_OFFSET(Pose, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Pose::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[5]);
}

// ===================================================================

class RobotIndicators::_Internal {
 public:
  using HasBits = decltype(std::declval<RobotIndicators>()._impl_._has_bits_);
  static void set_has_irb14000(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RobotIndicators::RobotIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.RobotIndicators)
}
RobotIndicators::RobotIndicators(const RobotIndicators& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RobotIndicators* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irb14000_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.irb14000_ = from._impl_.irb14000_;
  // @@protoc_insertion_point(copy_constructor:abb.robot.RobotIndicators)
}

inline void RobotIndicators::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irb14000_){false}
  };
}

RobotIndicators::~RobotIndicators() {
  // @@protoc_insertion_point(destructor:abb.robot.RobotIndicators)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RobotIndicators::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RobotIndicators::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RobotIndicators::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.RobotIndicators)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.irb14000_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotIndicators::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool irb14000 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_irb14000(&has_bits);
          _impl_.irb14000_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RobotIndicators::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.RobotIndicators)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool irb14000 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_irb14000(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.RobotIndicators)
  return target;
}

size_t RobotIndicators::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.RobotIndicators)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool irb14000 = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotIndicators::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RobotIndicators::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotIndicators::GetClassData() const { return &_class_data_; }


void RobotIndicators::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RobotIndicators*>(&to_msg);
  auto& from = static_cast<const RobotIndicators&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.RobotIndicators)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_irb14000()) {
    _this->_internal_set_irb14000(from._internal_irb14000());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotIndicators::CopyFrom(const RobotIndicators& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.RobotIndicators)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotIndicators::IsInitialized() const {
  return true;
}

void RobotIndicators::InternalSwap(RobotIndicators* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.irb14000_, other->_impl_.irb14000_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotIndicators::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[6]);
}

// ===================================================================

class OptionIndicators::_Internal {
 public:
  using HasBits = decltype(std::declval<OptionIndicators>()._impl_._has_bits_);
  static void set_has_egm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_leadthrough(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_multimove(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

OptionIndicators::OptionIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.OptionIndicators)
}
OptionIndicators::OptionIndicators(const OptionIndicators& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OptionIndicators* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.egm_){}
    , decltype(_impl_.leadthrough_){}
    , decltype(_impl_.multimove_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.egm_, &from._impl_.egm_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.multimove_) -
    reinterpret_cast<char*>(&_impl_.egm_)) + sizeof(_impl_.multimove_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.OptionIndicators)
}

inline void OptionIndicators::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.egm_){false}
    , decltype(_impl_.leadthrough_){false}
    , decltype(_impl_.multimove_){false}
  };
}

OptionIndicators::~OptionIndicators() {
  // @@protoc_insertion_point(destructor:abb.robot.OptionIndicators)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OptionIndicators::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OptionIndicators::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OptionIndicators::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.OptionIndicators)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.egm_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.multimove_) -
      reinterpret_cast<char*>(&_impl_.egm_)) + sizeof(_impl_.multimove_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OptionIndicators::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool egm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_egm(&has_bits);
          _impl_.egm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool leadthrough = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_leadthrough(&has_bits);
          _impl_.leadthrough_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool multimove = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_multimove(&has_bits);
          _impl_.multimove_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OptionIndicators::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.OptionIndicators)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool egm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_egm(), target);
  }

  // optional bool leadthrough = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_leadthrough(), target);
  }

  // optional bool multimove = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_multimove(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.OptionIndicators)
  return target;
}

size_t OptionIndicators::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.OptionIndicators)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool egm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool leadthrough = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool multimove = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OptionIndicators::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OptionIndicators::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OptionIndicators::GetClassData() const { return &_class_data_; }


void OptionIndicators::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OptionIndicators*>(&to_msg);
  auto& from = static_cast<const OptionIndicators&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.OptionIndicators)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.egm_ = from._impl_.egm_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.leadthrough_ = from._impl_.leadthrough_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.multimove_ = from._impl_.multimove_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OptionIndicators::CopyFrom(const OptionIndicators& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.OptionIndicators)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OptionIndicators::IsInitialized() const {
  return true;
}

void OptionIndicators::InternalSwap(OptionIndicators* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OptionIndicators, _impl_.multimove_)
      + sizeof(OptionIndicators::_impl_.multimove_)
      - PROTOBUF_FIELD_OFFSET(OptionIndicators, _impl_.egm_)>(
          reinterpret_cast<char*>(&_impl_.egm_),
          reinterpret_cast<char*>(&other->_impl_.egm_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OptionIndicators::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[7]);
}

// ===================================================================

class AddInIndicators::_Internal {
 public:
  using HasBits = decltype(std::declval<AddInIndicators>()._impl_._has_bits_);
  static void set_has_smart_gripper(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_state_machine_1_0(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_state_machine_1_1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

AddInIndicators::AddInIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.AddInIndicators)
}
AddInIndicators::AddInIndicators(const AddInIndicators& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddInIndicators* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.smart_gripper_){}
    , decltype(_impl_.state_machine_1_0_){}
    , decltype(_impl_.state_machine_1_1_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.smart_gripper_, &from._impl_.smart_gripper_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_machine_1_1_) -
    reinterpret_cast<char*>(&_impl_.smart_gripper_)) + sizeof(_impl_.state_machine_1_1_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.AddInIndicators)
}

inline void AddInIndicators::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.smart_gripper_){false}
    , decltype(_impl_.state_machine_1_0_){false}
    , decltype(_impl_.state_machine_1_1_){false}
  };
}

AddInIndicators::~AddInIndicators() {
  // @@protoc_insertion_point(destructor:abb.robot.AddInIndicators)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddInIndicators::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AddInIndicators::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddInIndicators::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.AddInIndicators)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.smart_gripper_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.state_machine_1_1_) -
      reinterpret_cast<char*>(&_impl_.smart_gripper_)) + sizeof(_impl_.state_machine_1_1_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddInIndicators::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool smart_gripper = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_smart_gripper(&has_bits);
          _impl_.smart_gripper_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool state_machine_1_0 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_state_machine_1_0(&has_bits);
          _impl_.state_machine_1_0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool state_machine_1_1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_state_machine_1_1(&has_bits);
          _impl_.state_machine_1_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddInIndicators::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.AddInIndicators)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool smart_gripper = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_smart_gripper(), target);
  }

  // optional bool state_machine_1_0 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_state_machine_1_0(), target);
  }

  // optional bool state_machine_1_1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_state_machine_1_1(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.AddInIndicators)
  return target;
}

size_t AddInIndicators::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.AddInIndicators)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool smart_gripper = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool state_machine_1_0 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool state_machine_1_1 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddInIndicators::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddInIndicators::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddInIndicators::GetClassData() const { return &_class_data_; }


void AddInIndicators::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddInIndicators*>(&to_msg);
  auto& from = static_cast<const AddInIndicators&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.AddInIndicators)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.smart_gripper_ = from._impl_.smart_gripper_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.state_machine_1_0_ = from._impl_.state_machine_1_0_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.state_machine_1_1_ = from._impl_.state_machine_1_1_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddInIndicators::CopyFrom(const AddInIndicators& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.AddInIndicators)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddInIndicators::IsInitialized() const {
  return true;
}

void AddInIndicators::InternalSwap(AddInIndicators* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddInIndicators, _impl_.state_machine_1_1_)
      + sizeof(AddInIndicators::_impl_.state_machine_1_1_)
      - PROTOBUF_FIELD_OFFSET(AddInIndicators, _impl_.smart_gripper_)>(
          reinterpret_cast<char*>(&_impl_.smart_gripper_),
          reinterpret_cast<char*>(&other->_impl_.smart_gripper_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddInIndicators::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[8]);
}

// ===================================================================

class SystemIndicators::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemIndicators>()._impl_._has_bits_);
  static const ::abb::robot::RobotIndicators& robots(const SystemIndicators* msg);
  static void set_has_robots(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::robot::OptionIndicators& options(const SystemIndicators* msg);
  static void set_has_options(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::robot::AddInIndicators& addins(const SystemIndicators* msg);
  static void set_has_addins(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::robot::RobotIndicators&
SystemIndicators::_Internal::robots(const SystemIndicators* msg) {
  return *msg->_impl_.robots_;
}
const ::abb::robot::OptionIndicators&
SystemIndicators::_Internal::options(const SystemIndicators* msg) {
  return *msg->_impl_.options_;
}
const ::abb::robot::AddInIndicators&
SystemIndicators::_Internal::addins(const SystemIndicators* msg) {
  return *msg->_impl_.addins_;
}
SystemIndicators::SystemIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.SystemIndicators)
}
SystemIndicators::SystemIndicators(const SystemIndicators& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SystemIndicators* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.robots_){nullptr}
    , decltype(_impl_.options_){nullptr}
    , decltype(_impl_.addins_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_robots()) {
    _this->_impl_.robots_ = new ::abb::robot::RobotIndicators(*from._impl_.robots_);
  }
  if (from._internal_has_options()) {
    _this->_impl_.options_ = new ::abb::robot::OptionIndicators(*from._impl_.options_);
  }
  if (from._internal_has_addins()) {
    _this->_impl_.addins_ = new ::abb::robot::AddInIndicators(*from._impl_.addins_);
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.SystemIndicators)
}

inline void SystemIndicators::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.robots_){nullptr}
    , decltype(_impl_.options_){nullptr}
    , decltype(_impl_.addins_){nullptr}
  };
}

SystemIndicators::~SystemIndicators() {
  // @@protoc_insertion_point(destructor:abb.robot.SystemIndicators)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemIndicators::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.robots_;
  if (this != internal_default_instance()) delete _impl_.options_;
  if (this != internal_default_instance()) delete _impl_.addins_;
}

void SystemIndicators::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemIndicators::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.SystemIndicators)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.robots_ != nullptr);
      _impl_.robots_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.options_ != nullptr);
      _impl_.options_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.addins_ != nullptr);
      _impl_.addins_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SystemIndicators::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.robot.RobotIndicators robots = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_robots(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.OptionIndicators options = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.AddInIndicators addins = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_addins(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemIndicators::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.SystemIndicators)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .abb.robot.RobotIndicators robots = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::robots(this),
        _Internal::robots(this).GetCachedSize(), target, stream);
  }

  // optional .abb.robot.OptionIndicators options = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::options(this),
        _Internal::options(this).GetCachedSize(), target, stream);
  }

  // optional .abb.robot.AddInIndicators addins = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::addins(this),
        _Internal::addins(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.SystemIndicators)
  return target;
}

size_t SystemIndicators::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.SystemIndicators)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .abb.robot.RobotIndicators robots = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.robots_);
    }

    // optional .abb.robot.OptionIndicators options = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.options_);
    }

    // optional .abb.robot.AddInIndicators addins = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.addins_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SystemIndicators::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SystemIndicators::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SystemIndicators::GetClassData() const { return &_class_data_; }


void SystemIndicators::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SystemIndicators*>(&to_msg);
  auto& from = static_cast<const SystemIndicators&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.SystemIndicators)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_robots()->::abb::robot::RobotIndicators::MergeFrom(
          from._internal_robots());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_options()->::abb::robot::OptionIndicators::MergeFrom(
          from._internal_options());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_addins()->::abb::robot::AddInIndicators::MergeFrom(
          from._internal_addins());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SystemIndicators::CopyFrom(const SystemIndicators& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.SystemIndicators)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemIndicators::IsInitialized() const {
  return true;
}

void SystemIndicators::InternalSwap(SystemIndicators* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemIndicators, _impl_.addins_)
      + sizeof(SystemIndicators::_impl_.addins_)
      - PROTOBUF_FIELD_OFFSET(SystemIndicators, _impl_.robots_)>(
          reinterpret_cast<char*>(&_impl_.robots_),
          reinterpret_cast<char*>(&other->_impl_.robots_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SystemIndicators::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[9]);
}

// ===================================================================

class Transmission::_Internal {
 public:
  using HasBits = decltype(std::declval<Transmission>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rotating_move(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Transmission::Transmission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.Transmission)
}
Transmission::Transmission(const Transmission& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Transmission* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.rotating_move_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.rotating_move_ = from._impl_.rotating_move_;
  // @@protoc_insertion_point(copy_constructor:abb.robot.Transmission)
}

inline void Transmission::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.rotating_move_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Transmission::~Transmission() {
  // @@protoc_insertion_point(destructor:abb.robot.Transmission)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Transmission::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void Transmission::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Transmission::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Transmission)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.rotating_move_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Transmission::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.Transmission.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool rotating_move = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rotating_move(&has_bits);
          _impl_.rotating_move_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Transmission::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Transmission)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Transmission.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bool rotating_move = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_rotating_move(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Transmission)
  return target;
}

size_t Transmission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Transmission)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bool rotating_move = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Transmission::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Transmission::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Transmission::GetClassData() const { return &_class_data_; }


void Transmission::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Transmission*>(&to_msg);
  auto& from = static_cast<const Transmission&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Transmission)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.rotating_move_ = from._impl_.rotating_move_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Transmission::CopyFrom(const Transmission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Transmission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transmission::IsInitialized() const {
  return true;
}

void Transmission::InternalSwap(Transmission* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.rotating_move_, other->_impl_.rotating_move_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Transmission::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[10]);
}

// ===================================================================

class Arm::_Internal {
 public:
  using HasBits = decltype(std::declval<Arm>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lower_joint_bound(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_upper_joint_bound(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Arm::Arm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.Arm)
}
Arm::Arm(const Arm& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Arm* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.lower_joint_bound_){}
    , decltype(_impl_.upper_joint_bound_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.lower_joint_bound_, &from._impl_.lower_joint_bound_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.upper_joint_bound_) -
    reinterpret_cast<char*>(&_impl_.lower_joint_bound_)) + sizeof(_impl_.upper_joint_bound_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.Arm)
}

inline void Arm::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.lower_joint_bound_){0}
    , decltype(_impl_.upper_joint_bound_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Arm::~Arm() {
  // @@protoc_insertion_point(destructor:abb.robot.Arm)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Arm::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void Arm::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Arm::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Arm)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.lower_joint_bound_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.upper_joint_bound_) -
        reinterpret_cast<char*>(&_impl_.lower_joint_bound_)) + sizeof(_impl_.upper_joint_bound_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Arm::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.Arm.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double lower_joint_bound = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_lower_joint_bound(&has_bits);
          _impl_.lower_joint_bound_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double upper_joint_bound = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_upper_joint_bound(&has_bits);
          _impl_.upper_joint_bound_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Arm::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Arm)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Arm.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional double lower_joint_bound = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_lower_joint_bound(), target);
  }

  // optional double upper_joint_bound = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_upper_joint_bound(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Arm)
  return target;
}

size_t Arm::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Arm)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional double lower_joint_bound = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double upper_joint_bound = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Arm::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Arm::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Arm::GetClassData() const { return &_class_data_; }


void Arm::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Arm*>(&to_msg);
  auto& from = static_cast<const Arm&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Arm)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lower_joint_bound_ = from._impl_.lower_joint_bound_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.upper_joint_bound_ = from._impl_.upper_joint_bound_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Arm::CopyFrom(const Arm& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Arm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Arm::IsInitialized() const {
  return true;
}

void Arm::InternalSwap(Arm* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Arm, _impl_.upper_joint_bound_)
      + sizeof(Arm::_impl_.upper_joint_bound_)
      - PROTOBUF_FIELD_OFFSET(Arm, _impl_.lower_joint_bound_)>(
          reinterpret_cast<char*>(&_impl_.lower_joint_bound_),
          reinterpret_cast<char*>(&other->_impl_.lower_joint_bound_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Arm::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[11]);
}

// ===================================================================

class Joint::_Internal {
 public:
  using HasBits = decltype(std::declval<Joint>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_logical_axis(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_kinematic_axis_number(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::abb::robot::Arm& arm(const Joint* msg);
  static void set_has_arm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::robot::Transmission& transmission(const Joint* msg);
  static void set_has_transmission(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::robot::Arm&
Joint::_Internal::arm(const Joint* msg) {
  return *msg->_impl_.arm_;
}
const ::abb::robot::Transmission&
Joint::_Internal::transmission(const Joint* msg) {
  return *msg->_impl_.transmission_;
}
Joint::Joint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.Joint)
}
Joint::Joint(const Joint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Joint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.arm_){nullptr}
    , decltype(_impl_.transmission_){nullptr}
    , decltype(_impl_.logical_axis_){}
    , decltype(_impl_.kinematic_axis_number_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_arm()) {
    _this->_impl_.arm_ = new ::abb::robot::Arm(*from._impl_.arm_);
  }
  if (from._internal_has_transmission()) {
    _this->_impl_.transmission_ = new ::abb::robot::Transmission(*from._impl_.transmission_);
  }
  ::memcpy(&_impl_.logical_axis_, &from._impl_.logical_axis_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.kinematic_axis_number_) -
    reinterpret_cast<char*>(&_impl_.logical_axis_)) + sizeof(_impl_.kinematic_axis_number_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.Joint)
}

inline void Joint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.arm_){nullptr}
    , decltype(_impl_.transmission_){nullptr}
    , decltype(_impl_.logical_axis_){0}
    , decltype(_impl_.kinematic_axis_number_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Joint::~Joint() {
  // @@protoc_insertion_point(destructor:abb.robot.Joint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Joint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.arm_;
  if (this != internal_default_instance()) delete _impl_.transmission_;
}

void Joint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Joint::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Joint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.arm_ != nullptr);
      _impl_.arm_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.transmission_ != nullptr);
      _impl_.transmission_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.logical_axis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.kinematic_axis_number_) -
        reinterpret_cast<char*>(&_impl_.logical_axis_)) + sizeof(_impl_.kinematic_axis_number_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Joint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.Joint.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 logical_axis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_logical_axis(&has_bits);
          _impl_.logical_axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 kinematic_axis_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_kinematic_axis_number(&has_bits);
          _impl_.kinematic_axis_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Arm arm = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_arm(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Transmission transmission = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_transmission(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Joint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Joint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Joint.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 logical_axis = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_logical_axis(), target);
  }

  // optional int32 kinematic_axis_number = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_kinematic_axis_number(), target);
  }

  // optional .abb.robot.Arm arm = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::arm(this),
        _Internal::arm(this).GetCachedSize(), target, stream);
  }

  // optional .abb.robot.Transmission transmission = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::transmission(this),
        _Internal::transmission(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Joint)
  return target;
}

size_t Joint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Joint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .abb.robot.Arm arm = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.arm_);
    }

    // optional .abb.robot.Transmission transmission = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.transmission_);
    }

    // optional int32 logical_axis = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_logical_axis());
    }

    // optional int32 kinematic_axis_number = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_kinematic_axis_number());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Joint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Joint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Joint::GetClassData() const { return &_class_data_; }


void Joint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Joint*>(&to_msg);
  auto& from = static_cast<const Joint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Joint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_arm()->::abb::robot::Arm::MergeFrom(
          from._internal_arm());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_transmission()->::abb::robot::Transmission::MergeFrom(
          from._internal_transmission());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.logical_axis_ = from._impl_.logical_axis_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.kinematic_axis_number_ = from._impl_.kinematic_axis_number_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Joint::CopyFrom(const Joint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Joint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Joint::IsInitialized() const {
  return true;
}

void Joint::InternalSwap(Joint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Joint, _impl_.kinematic_axis_number_)
      + sizeof(Joint::_impl_.kinematic_axis_number_)
      - PROTOBUF_FIELD_OFFSET(Joint, _impl_.arm_)>(
          reinterpret_cast<char*>(&_impl_.arm_),
          reinterpret_cast<char*>(&other->_impl_.arm_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Joint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[12]);
}

// ===================================================================

class StandardizedJoint::_Internal {
 public:
  using HasBits = decltype(std::declval<StandardizedJoint>()._impl_._has_bits_);
  static void set_has_original_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_standardized_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rotating_move(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lower_joint_bound(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_upper_joint_bound(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

StandardizedJoint::StandardizedJoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.StandardizedJoint)
}
StandardizedJoint::StandardizedJoint(const StandardizedJoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StandardizedJoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.original_name_){}
    , decltype(_impl_.standardized_name_){}
    , decltype(_impl_.lower_joint_bound_){}
    , decltype(_impl_.upper_joint_bound_){}
    , decltype(_impl_.rotating_move_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.original_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.original_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_original_name()) {
    _this->_impl_.original_name_.Set(from._internal_original_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.standardized_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.standardized_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_standardized_name()) {
    _this->_impl_.standardized_name_.Set(from._internal_standardized_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.lower_joint_bound_, &from._impl_.lower_joint_bound_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rotating_move_) -
    reinterpret_cast<char*>(&_impl_.lower_joint_bound_)) + sizeof(_impl_.rotating_move_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.StandardizedJoint)
}

inline void StandardizedJoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.original_name_){}
    , decltype(_impl_.standardized_name_){}
    , decltype(_impl_.lower_joint_bound_){0}
    , decltype(_impl_.upper_joint_bound_){0}
    , decltype(_impl_.rotating_move_){false}
  };
  _impl_.original_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.original_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.standardized_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.standardized_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StandardizedJoint::~StandardizedJoint() {
  // @@protoc_insertion_point(destructor:abb.robot.StandardizedJoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StandardizedJoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.original_name_.Destroy();
  _impl_.standardized_name_.Destroy();
}

void StandardizedJoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StandardizedJoint::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.StandardizedJoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.original_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.standardized_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.lower_joint_bound_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rotating_move_) -
        reinterpret_cast<char*>(&_impl_.lower_joint_bound_)) + sizeof(_impl_.rotating_move_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StandardizedJoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string original_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_original_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.StandardizedJoint.original_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string standardized_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_standardized_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.StandardizedJoint.standardized_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool rotating_move = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_rotating_move(&has_bits);
          _impl_.rotating_move_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double lower_joint_bound = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_lower_joint_bound(&has_bits);
          _impl_.lower_joint_bound_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double upper_joint_bound = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_upper_joint_bound(&has_bits);
          _impl_.upper_joint_bound_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StandardizedJoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.StandardizedJoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string original_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_original_name().data(), static_cast<int>(this->_internal_original_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.StandardizedJoint.original_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_original_name(), target);
  }

  // optional string standardized_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_standardized_name().data(), static_cast<int>(this->_internal_standardized_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.StandardizedJoint.standardized_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_standardized_name(), target);
  }

  // optional bool rotating_move = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_rotating_move(), target);
  }

  // optional double lower_joint_bound = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_lower_joint_bound(), target);
  }

  // optional double upper_joint_bound = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_upper_joint_bound(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.StandardizedJoint)
  return target;
}

size_t StandardizedJoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.StandardizedJoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string original_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_name());
    }

    // optional string standardized_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_standardized_name());
    }

    // optional double lower_joint_bound = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double upper_joint_bound = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional bool rotating_move = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StandardizedJoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StandardizedJoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StandardizedJoint::GetClassData() const { return &_class_data_; }


void StandardizedJoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StandardizedJoint*>(&to_msg);
  auto& from = static_cast<const StandardizedJoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.StandardizedJoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_original_name(from._internal_original_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_standardized_name(from._internal_standardized_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lower_joint_bound_ = from._impl_.lower_joint_bound_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.upper_joint_bound_ = from._impl_.upper_joint_bound_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rotating_move_ = from._impl_.rotating_move_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StandardizedJoint::CopyFrom(const StandardizedJoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.StandardizedJoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StandardizedJoint::IsInitialized() const {
  return true;
}

void StandardizedJoint::InternalSwap(StandardizedJoint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.original_name_, lhs_arena,
      &other->_impl_.original_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.standardized_name_, lhs_arena,
      &other->_impl_.standardized_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StandardizedJoint, _impl_.rotating_move_)
      + sizeof(StandardizedJoint::_impl_.rotating_move_)
      - PROTOBUF_FIELD_OFFSET(StandardizedJoint, _impl_.lower_joint_bound_)>(
          reinterpret_cast<char*>(&_impl_.lower_joint_bound_),
          reinterpret_cast<char*>(&other->_impl_.lower_joint_bound_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StandardizedJoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[13]);
}

// ===================================================================

class Single::_Internal {
 public:
  using HasBits = decltype(std::declval<Single>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::robot::Joint& joint(const Single* msg);
  static void set_has_joint(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::abb::robot::Pose& base_frame(const Single* msg);
  static void set_has_base_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_base_frame_moved_by(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::robot::Joint&
Single::_Internal::joint(const Single* msg) {
  return *msg->_impl_.joint_;
}
const ::abb::robot::Pose&
Single::_Internal::base_frame(const Single* msg) {
  return *msg->_impl_.base_frame_;
}
Single::Single(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.Single)
}
Single::Single(const Single& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Single* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.base_frame_moved_by_){}
    , decltype(_impl_.joint_){nullptr}
    , decltype(_impl_.base_frame_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.base_frame_moved_by_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_frame_moved_by_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_base_frame_moved_by()) {
    _this->_impl_.base_frame_moved_by_.Set(from._internal_base_frame_moved_by(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_joint()) {
    _this->_impl_.joint_ = new ::abb::robot::Joint(*from._impl_.joint_);
  }
  if (from._internal_has_base_frame()) {
    _this->_impl_.base_frame_ = new ::abb::robot::Pose(*from._impl_.base_frame_);
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.Single)
}

inline void Single::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.base_frame_moved_by_){}
    , decltype(_impl_.joint_){nullptr}
    , decltype(_impl_.base_frame_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_frame_moved_by_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_frame_moved_by_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Single::~Single() {
  // @@protoc_insertion_point(destructor:abb.robot.Single)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Single::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.type_.Destroy();
  _impl_.base_frame_moved_by_.Destroy();
  if (this != internal_default_instance()) delete _impl_.joint_;
  if (this != internal_default_instance()) delete _impl_.base_frame_;
}

void Single::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Single::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Single)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.base_frame_moved_by_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.joint_ != nullptr);
      _impl_.joint_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.base_frame_ != nullptr);
      _impl_.base_frame_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Single::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.Single.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.Single.type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Joint joint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_joint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Pose base_frame = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_base_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string base_frame_moved_by = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_base_frame_moved_by();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.Single.base_frame_moved_by");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Single::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Single)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Single.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Single.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  // optional .abb.robot.Joint joint = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::joint(this),
        _Internal::joint(this).GetCachedSize(), target, stream);
  }

  // optional .abb.robot.Pose base_frame = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::base_frame(this),
        _Internal::base_frame(this).GetCachedSize(), target, stream);
  }

  // optional string base_frame_moved_by = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_base_frame_moved_by().data(), static_cast<int>(this->_internal_base_frame_moved_by().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Single.base_frame_moved_by");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_base_frame_moved_by(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Single)
  return target;
}

size_t Single::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Single)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional string base_frame_moved_by = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_base_frame_moved_by());
    }

    // optional .abb.robot.Joint joint = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.joint_);
    }

    // optional .abb.robot.Pose base_frame = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_frame_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Single::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Single::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Single::GetClassData() const { return &_class_data_; }


void Single::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Single*>(&to_msg);
  auto& from = static_cast<const Single&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Single)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_base_frame_moved_by(from._internal_base_frame_moved_by());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_joint()->::abb::robot::Joint::MergeFrom(
          from._internal_joint());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_base_frame()->::abb::robot::Pose::MergeFrom(
          from._internal_base_frame());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Single::CopyFrom(const Single& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Single)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Single::IsInitialized() const {
  return true;
}

void Single::InternalSwap(Single* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.base_frame_moved_by_, lhs_arena,
      &other->_impl_.base_frame_moved_by_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Single, _impl_.base_frame_)
      + sizeof(Single::_impl_.base_frame_)
      - PROTOBUF_FIELD_OFFSET(Single, _impl_.joint_)>(
          reinterpret_cast<char*>(&_impl_.joint_),
          reinterpret_cast<char*>(&other->_impl_.joint_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Single::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[14]);
}

// ===================================================================

class Robot::_Internal {
 public:
  using HasBits = decltype(std::declval<Robot>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::robot::Pose& base_frame(const Robot* msg);
  static void set_has_base_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_base_frame_moved_by(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::robot::Pose&
Robot::_Internal::base_frame(const Robot* msg) {
  return *msg->_impl_.base_frame_;
}
Robot::Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.Robot)
}
Robot::Robot(const Robot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Robot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.joints_){from._impl_.joints_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.base_frame_moved_by_){}
    , decltype(_impl_.base_frame_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.base_frame_moved_by_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_frame_moved_by_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_base_frame_moved_by()) {
    _this->_impl_.base_frame_moved_by_.Set(from._internal_base_frame_moved_by(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_base_frame()) {
    _this->_impl_.base_frame_ = new ::abb::robot::Pose(*from._impl_.base_frame_);
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.Robot)
}

inline void Robot::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.joints_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.base_frame_moved_by_){}
    , decltype(_impl_.base_frame_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_frame_moved_by_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_frame_moved_by_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Robot::~Robot() {
  // @@protoc_insertion_point(destructor:abb.robot.Robot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Robot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.joints_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.type_.Destroy();
  _impl_.base_frame_moved_by_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_frame_;
}

void Robot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Robot::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.Robot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.joints_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.base_frame_moved_by_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.base_frame_ != nullptr);
      _impl_.base_frame_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Robot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.Robot.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.Robot.type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.Joint joints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_joints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Pose base_frame = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_base_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string base_frame_moved_by = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_base_frame_moved_by();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.Robot.base_frame_moved_by");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Robot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.Robot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Robot.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Robot.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  // repeated .abb.robot.Joint joints = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_joints_size()); i < n; i++) {
    const auto& repfield = this->_internal_joints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .abb.robot.Pose base_frame = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::base_frame(this),
        _Internal::base_frame(this).GetCachedSize(), target, stream);
  }

  // optional string base_frame_moved_by = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_base_frame_moved_by().data(), static_cast<int>(this->_internal_base_frame_moved_by().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.Robot.base_frame_moved_by");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_base_frame_moved_by(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.Robot)
  return target;
}

size_t Robot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.Robot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .abb.robot.Joint joints = 3;
  total_size += 1UL * this->_internal_joints_size();
  for (const auto& msg : this->_impl_.joints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional string base_frame_moved_by = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_base_frame_moved_by());
    }

    // optional .abb.robot.Pose base_frame = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_frame_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Robot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Robot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Robot::GetClassData() const { return &_class_data_; }


void Robot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Robot*>(&to_msg);
  auto& from = static_cast<const Robot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.Robot)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.joints_.MergeFrom(from._impl_.joints_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_base_frame_moved_by(from._internal_base_frame_moved_by());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_base_frame()->::abb::robot::Pose::MergeFrom(
          from._internal_base_frame());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Robot::CopyFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Robot::IsInitialized() const {
  return true;
}

void Robot::InternalSwap(Robot* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.joints_.InternalSwap(&other->_impl_.joints_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.base_frame_moved_by_, lhs_arena,
      &other->_impl_.base_frame_moved_by_, rhs_arena
  );
  swap(_impl_.base_frame_, other->_impl_.base_frame_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Robot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[15]);
}

// ===================================================================

class MechanicalUnit::_Internal {
 public:
  using HasBits = decltype(std::declval<MechanicalUnit>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::robot::Robot& robot(const MechanicalUnit* msg);
  static void set_has_robot(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_task_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_axes(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_axes_total(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_integrated_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_has_integrated_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::abb::robot::Robot&
MechanicalUnit::_Internal::robot(const MechanicalUnit* msg) {
  return *msg->_impl_.robot_;
}
MechanicalUnit::MechanicalUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.MechanicalUnit)
}
MechanicalUnit::MechanicalUnit(const MechanicalUnit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MechanicalUnit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.singles_){from._impl_.singles_}
    , decltype(_impl_.standardized_joints_){from._impl_.standardized_joints_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.task_name_){}
    , decltype(_impl_.is_integrated_unit_){}
    , decltype(_impl_.has_integrated_unit_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.robot_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.axes_){}
    , decltype(_impl_.axes_total_){}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.task_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.task_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_task_name()) {
    _this->_impl_.task_name_.Set(from._internal_task_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.is_integrated_unit_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.is_integrated_unit_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_is_integrated_unit()) {
    _this->_impl_.is_integrated_unit_.Set(from._internal_is_integrated_unit(), 
      _this->GetArenaForAllocation());
  }
  _impl_.has_integrated_unit_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.has_integrated_unit_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_has_integrated_unit()) {
    _this->_impl_.has_integrated_unit_.Set(from._internal_has_integrated_unit(), 
      _this->GetArenaForAllocation());
  }
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_robot()) {
    _this->_impl_.robot_ = new ::abb::robot::Robot(*from._impl_.robot_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mode_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.mode_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.MechanicalUnit)
}

inline void MechanicalUnit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.singles_){arena}
    , decltype(_impl_.standardized_joints_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.task_name_){}
    , decltype(_impl_.is_integrated_unit_){}
    , decltype(_impl_.has_integrated_unit_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.robot_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.axes_){0}
    , decltype(_impl_.axes_total_){0}
    , decltype(_impl_.mode_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.task_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.task_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.is_integrated_unit_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.is_integrated_unit_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.has_integrated_unit_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.has_integrated_unit_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MechanicalUnit::~MechanicalUnit() {
  // @@protoc_insertion_point(destructor:abb.robot.MechanicalUnit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MechanicalUnit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.singles_.~RepeatedPtrField();
  _impl_.standardized_joints_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.task_name_.Destroy();
  _impl_.is_integrated_unit_.Destroy();
  _impl_.has_integrated_unit_.Destroy();
  _impl_.status_.Destroy();
  if (this != internal_default_instance()) delete _impl_.robot_;
}

void MechanicalUnit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MechanicalUnit::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.MechanicalUnit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.singles_.Clear();
  _impl_.standardized_joints_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.task_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.is_integrated_unit_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.has_integrated_unit_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.robot_ != nullptr);
      _impl_.robot_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.axes_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.axes_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.axes_total_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.axes_total_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MechanicalUnit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.MechanicalUnit.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.Robot robot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_robot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.Single singles = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_singles(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.MechanicalUnit.Type type = 4 [default = UNDEFINED];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::robot::MechanicalUnit_Type_IsValid(val))) {
            _internal_set_type(static_cast<::abb::robot::MechanicalUnit_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string task_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_task_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.MechanicalUnit.task_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 axes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_axes(&has_bits);
          _impl_.axes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 axes_total = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_axes_total(&has_bits);
          _impl_.axes_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string is_integrated_unit = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_is_integrated_unit();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.MechanicalUnit.is_integrated_unit");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string has_integrated_unit = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_has_integrated_unit();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.MechanicalUnit.has_integrated_unit");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string status = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.MechanicalUnit.status");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.MechanicalUnit.Mode mode = 11 [default = DEACTIVATED];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::robot::MechanicalUnit_Mode_IsValid(val))) {
            _internal_set_mode(static_cast<::abb::robot::MechanicalUnit_Mode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.StandardizedJoint standardized_joints = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_standardized_joints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MechanicalUnit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.MechanicalUnit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.MechanicalUnit.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .abb.robot.Robot robot = 2;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::robot(this),
        _Internal::robot(this).GetCachedSize(), target, stream);
  }

  // repeated .abb.robot.Single singles = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_singles_size()); i < n; i++) {
    const auto& repfield = this->_internal_singles(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .abb.robot.MechanicalUnit.Type type = 4 [default = UNDEFINED];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  // optional string task_name = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_task_name().data(), static_cast<int>(this->_internal_task_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.MechanicalUnit.task_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_task_name(), target);
  }

  // optional int32 axes = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_axes(), target);
  }

  // optional int32 axes_total = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_axes_total(), target);
  }

  // optional string is_integrated_unit = 8;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_is_integrated_unit().data(), static_cast<int>(this->_internal_is_integrated_unit().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.MechanicalUnit.is_integrated_unit");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_is_integrated_unit(), target);
  }

  // optional string has_integrated_unit = 9;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_has_integrated_unit().data(), static_cast<int>(this->_internal_has_integrated_unit().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.MechanicalUnit.has_integrated_unit");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_has_integrated_unit(), target);
  }

  // optional string status = 10;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.MechanicalUnit.status");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_status(), target);
  }

  // optional .abb.robot.MechanicalUnit.Mode mode = 11 [default = DEACTIVATED];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      11, this->_internal_mode(), target);
  }

  // repeated .abb.robot.StandardizedJoint standardized_joints = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_standardized_joints_size()); i < n; i++) {
    const auto& repfield = this->_internal_standardized_joints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.MechanicalUnit)
  return target;
}

size_t MechanicalUnit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.MechanicalUnit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .abb.robot.Single singles = 3;
  total_size += 1UL * this->_internal_singles_size();
  for (const auto& msg : this->_impl_.singles_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .abb.robot.StandardizedJoint standardized_joints = 12;
  total_size += 1UL * this->_internal_standardized_joints_size();
  for (const auto& msg : this->_impl_.standardized_joints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string task_name = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_task_name());
    }

    // optional string is_integrated_unit = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_is_integrated_unit());
    }

    // optional string has_integrated_unit = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_has_integrated_unit());
    }

    // optional string status = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

    // optional .abb.robot.Robot robot = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.robot_);
    }

    // optional .abb.robot.MechanicalUnit.Type type = 4 [default = UNDEFINED];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional int32 axes = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_axes());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 axes_total = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_axes_total());
    }

    // optional .abb.robot.MechanicalUnit.Mode mode = 11 [default = DEACTIVATED];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MechanicalUnit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MechanicalUnit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MechanicalUnit::GetClassData() const { return &_class_data_; }


void MechanicalUnit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MechanicalUnit*>(&to_msg);
  auto& from = static_cast<const MechanicalUnit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.MechanicalUnit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.singles_.MergeFrom(from._impl_.singles_);
  _this->_impl_.standardized_joints_.MergeFrom(from._impl_.standardized_joints_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_task_name(from._internal_task_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_is_integrated_unit(from._internal_is_integrated_unit());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_has_integrated_unit(from._internal_has_integrated_unit());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_robot()->::abb::robot::Robot::MergeFrom(
          from._internal_robot());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.axes_ = from._impl_.axes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.axes_total_ = from._impl_.axes_total_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MechanicalUnit::CopyFrom(const MechanicalUnit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.MechanicalUnit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MechanicalUnit::IsInitialized() const {
  return true;
}

void MechanicalUnit::InternalSwap(MechanicalUnit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.singles_.InternalSwap(&other->_impl_.singles_);
  _impl_.standardized_joints_.InternalSwap(&other->_impl_.standardized_joints_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.task_name_, lhs_arena,
      &other->_impl_.task_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.is_integrated_unit_, lhs_arena,
      &other->_impl_.is_integrated_unit_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.has_integrated_unit_, lhs_arena,
      &other->_impl_.has_integrated_unit_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MechanicalUnit, _impl_.mode_)
      + sizeof(MechanicalUnit::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(MechanicalUnit, _impl_.robot_)>(
          reinterpret_cast<char*>(&_impl_.robot_),
          reinterpret_cast<char*>(&other->_impl_.robot_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MechanicalUnit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[16]);
}

// ===================================================================

class MechanicalUnitGroup::_Internal {
 public:
  using HasBits = decltype(std::declval<MechanicalUnitGroup>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::robot::MechanicalUnit& robot(const MechanicalUnitGroup* msg);
  static void set_has_robot(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::abb::robot::MechanicalUnit&
MechanicalUnitGroup::_Internal::robot(const MechanicalUnitGroup* msg) {
  return *msg->_impl_.robot_;
}
MechanicalUnitGroup::MechanicalUnitGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.MechanicalUnitGroup)
}
MechanicalUnitGroup::MechanicalUnitGroup(const MechanicalUnitGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MechanicalUnitGroup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mechanical_units_){from._impl_.mechanical_units_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.robot_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_robot()) {
    _this->_impl_.robot_ = new ::abb::robot::MechanicalUnit(*from._impl_.robot_);
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.MechanicalUnitGroup)
}

inline void MechanicalUnitGroup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mechanical_units_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.robot_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MechanicalUnitGroup::~MechanicalUnitGroup() {
  // @@protoc_insertion_point(destructor:abb.robot.MechanicalUnitGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MechanicalUnitGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mechanical_units_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.robot_;
}

void MechanicalUnitGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MechanicalUnitGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.MechanicalUnitGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mechanical_units_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.robot_ != nullptr);
      _impl_.robot_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MechanicalUnitGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.MechanicalUnitGroup.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.MechanicalUnit robot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_robot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.MechanicalUnit mechanical_units = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mechanical_units(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MechanicalUnitGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.MechanicalUnitGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.MechanicalUnitGroup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .abb.robot.MechanicalUnit robot = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::robot(this),
        _Internal::robot(this).GetCachedSize(), target, stream);
  }

  // repeated .abb.robot.MechanicalUnit mechanical_units = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mechanical_units_size()); i < n; i++) {
    const auto& repfield = this->_internal_mechanical_units(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.MechanicalUnitGroup)
  return target;
}

size_t MechanicalUnitGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.MechanicalUnitGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .abb.robot.MechanicalUnit mechanical_units = 3;
  total_size += 1UL * this->_internal_mechanical_units_size();
  for (const auto& msg : this->_impl_.mechanical_units_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .abb.robot.MechanicalUnit robot = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.robot_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MechanicalUnitGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MechanicalUnitGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MechanicalUnitGroup::GetClassData() const { return &_class_data_; }


void MechanicalUnitGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MechanicalUnitGroup*>(&to_msg);
  auto& from = static_cast<const MechanicalUnitGroup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.MechanicalUnitGroup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.mechanical_units_.MergeFrom(from._impl_.mechanical_units_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_robot()->::abb::robot::MechanicalUnit::MergeFrom(
          from._internal_robot());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MechanicalUnitGroup::CopyFrom(const MechanicalUnitGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.MechanicalUnitGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MechanicalUnitGroup::IsInitialized() const {
  return true;
}

void MechanicalUnitGroup::InternalSwap(MechanicalUnitGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.mechanical_units_.InternalSwap(&other->_impl_.mechanical_units_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.robot_, other->_impl_.robot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MechanicalUnitGroup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[17]);
}

// ===================================================================

class RAPIDModule::_Internal {
 public:
  using HasBits = decltype(std::declval<RAPIDModule>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

RAPIDModule::RAPIDModule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.RAPIDModule)
}
RAPIDModule::RAPIDModule(const RAPIDModule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RAPIDModule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:abb.robot.RAPIDModule)
}

inline void RAPIDModule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.type_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RAPIDModule::~RAPIDModule() {
  // @@protoc_insertion_point(destructor:abb.robot.RAPIDModule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RAPIDModule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.type_.Destroy();
}

void RAPIDModule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RAPIDModule::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.RAPIDModule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RAPIDModule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.RAPIDModule.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.RAPIDModule.type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RAPIDModule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.RAPIDModule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.RAPIDModule.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.RAPIDModule.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.RAPIDModule)
  return target;
}

size_t RAPIDModule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.RAPIDModule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RAPIDModule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RAPIDModule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RAPIDModule::GetClassData() const { return &_class_data_; }


void RAPIDModule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RAPIDModule*>(&to_msg);
  auto& from = static_cast<const RAPIDModule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.RAPIDModule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_type(from._internal_type());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RAPIDModule::CopyFrom(const RAPIDModule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.RAPIDModule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RAPIDModule::IsInitialized() const {
  return true;
}

void RAPIDModule::InternalSwap(RAPIDModule* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RAPIDModule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[18]);
}

// ===================================================================

class RAPIDTask::_Internal {
 public:
  using HasBits = decltype(std::declval<RAPIDTask>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_motion_task(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_active(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_execution_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

RAPIDTask::RAPIDTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.robot.RAPIDTask)
}
RAPIDTask::RAPIDTask(const RAPIDTask& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RAPIDTask* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.modules_){from._impl_.modules_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.is_motion_task_){}
    , decltype(_impl_.is_active_){}
    , decltype(_impl_.execution_state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.is_motion_task_, &from._impl_.is_motion_task_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.execution_state_) -
    reinterpret_cast<char*>(&_impl_.is_motion_task_)) + sizeof(_impl_.execution_state_));
  // @@protoc_insertion_point(copy_constructor:abb.robot.RAPIDTask)
}

inline void RAPIDTask::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.modules_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.is_motion_task_){false}
    , decltype(_impl_.is_active_){false}
    , decltype(_impl_.execution_state_){1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RAPIDTask::~RAPIDTask() {
  // @@protoc_insertion_point(destructor:abb.robot.RAPIDTask)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RAPIDTask::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.modules_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void RAPIDTask::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RAPIDTask::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.robot.RAPIDTask)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.modules_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.is_motion_task_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_active_) -
      reinterpret_cast<char*>(&_impl_.is_motion_task_)) + sizeof(_impl_.is_active_));
  _impl_.execution_state_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RAPIDTask::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "abb.robot.RAPIDTask.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool is_motion_task = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_motion_task(&has_bits);
          _impl_.is_motion_task_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_active = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_active(&has_bits);
          _impl_.is_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.robot.RAPIDTask.ExecutionState execution_state = 4 [default = UNKNOWN];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::robot::RAPIDTask_ExecutionState_IsValid(val))) {
            _internal_set_execution_state(static_cast<::abb::robot::RAPIDTask_ExecutionState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .abb.robot.RAPIDModule modules = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_modules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RAPIDTask::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.robot.RAPIDTask)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "abb.robot.RAPIDTask.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bool is_motion_task = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_motion_task(), target);
  }

  // optional bool is_active = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_active(), target);
  }

  // optional .abb.robot.RAPIDTask.ExecutionState execution_state = 4 [default = UNKNOWN];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_execution_state(), target);
  }

  // repeated .abb.robot.RAPIDModule modules = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_modules_size()); i < n; i++) {
    const auto& repfield = this->_internal_modules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.robot.RAPIDTask)
  return target;
}

size_t RAPIDTask::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.robot.RAPIDTask)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .abb.robot.RAPIDModule modules = 5;
  total_size += 1UL * this->_internal_modules_size();
  for (const auto& msg : this->_impl_.modules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bool is_motion_task = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool is_active = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional .abb.robot.RAPIDTask.ExecutionState execution_state = 4 [default = UNKNOWN];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_execution_state());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RAPIDTask::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RAPIDTask::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RAPIDTask::GetClassData() const { return &_class_data_; }


void RAPIDTask::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RAPIDTask*>(&to_msg);
  auto& from = static_cast<const RAPIDTask&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.robot.RAPIDTask)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.modules_.MergeFrom(from._impl_.modules_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_motion_task_ = from._impl_.is_motion_task_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_active_ = from._impl_.is_active_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.execution_state_ = from._impl_.execution_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RAPIDTask::CopyFrom(const RAPIDTask& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.robot.RAPIDTask)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RAPIDTask::IsInitialized() const {
  return true;
}

void RAPIDTask::InternalSwap(RAPIDTask* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.modules_.InternalSwap(&other->_impl_.modules_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RAPIDTask, _impl_.is_active_)
      + sizeof(RAPIDTask::_impl_.is_active_)
      - PROTOBUF_FIELD_OFFSET(RAPIDTask, _impl_.is_motion_task_)>(
          reinterpret_cast<char*>(&_impl_.is_motion_task_),
          reinterpret_cast<char*>(&other->_impl_.is_motion_task_));
  swap(_impl_.execution_state_, other->_impl_.execution_state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RAPIDTask::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_robot_5fcontroller_5fdescription_2eproto_getter, &descriptor_table_robot_5fcontroller_5fdescription_2eproto_once,
      file_level_metadata_robot_5fcontroller_5fdescription_2eproto[19]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace robot
}  // namespace abb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::abb::robot::Header*
Arena::CreateMaybeMessage< ::abb::robot::Header >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Header >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::RobotControllerDescription*
Arena::CreateMaybeMessage< ::abb::robot::RobotControllerDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::RobotControllerDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::RobotWareVersion*
Arena::CreateMaybeMessage< ::abb::robot::RobotWareVersion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::RobotWareVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Cartesian*
Arena::CreateMaybeMessage< ::abb::robot::Cartesian >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Cartesian >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Quaternion*
Arena::CreateMaybeMessage< ::abb::robot::Quaternion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Quaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Pose*
Arena::CreateMaybeMessage< ::abb::robot::Pose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Pose >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::RobotIndicators*
Arena::CreateMaybeMessage< ::abb::robot::RobotIndicators >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::RobotIndicators >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::OptionIndicators*
Arena::CreateMaybeMessage< ::abb::robot::OptionIndicators >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::OptionIndicators >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::AddInIndicators*
Arena::CreateMaybeMessage< ::abb::robot::AddInIndicators >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::AddInIndicators >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::SystemIndicators*
Arena::CreateMaybeMessage< ::abb::robot::SystemIndicators >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::SystemIndicators >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Transmission*
Arena::CreateMaybeMessage< ::abb::robot::Transmission >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Transmission >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Arm*
Arena::CreateMaybeMessage< ::abb::robot::Arm >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Arm >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Joint*
Arena::CreateMaybeMessage< ::abb::robot::Joint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Joint >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::StandardizedJoint*
Arena::CreateMaybeMessage< ::abb::robot::StandardizedJoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::StandardizedJoint >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Single*
Arena::CreateMaybeMessage< ::abb::robot::Single >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Single >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::Robot*
Arena::CreateMaybeMessage< ::abb::robot::Robot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::Robot >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::MechanicalUnit*
Arena::CreateMaybeMessage< ::abb::robot::MechanicalUnit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::MechanicalUnit >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::MechanicalUnitGroup*
Arena::CreateMaybeMessage< ::abb::robot::MechanicalUnitGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::MechanicalUnitGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::RAPIDModule*
Arena::CreateMaybeMessage< ::abb::robot::RAPIDModule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::RAPIDModule >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::robot::RAPIDTask*
Arena::CreateMaybeMessage< ::abb::robot::RAPIDTask >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::robot::RAPIDTask >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
