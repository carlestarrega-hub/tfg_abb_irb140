// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm_wrapper.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_egm_5fwrapper_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_egm_5fwrapper_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_egm_5fwrapper_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_egm_5fwrapper_2eproto;
namespace abb {
namespace egm {
namespace wrapper {
class Cartesian;
struct CartesianDefaultTypeInternal;
extern CartesianDefaultTypeInternal _Cartesian_default_instance_;
class CartesianPose;
struct CartesianPoseDefaultTypeInternal;
extern CartesianPoseDefaultTypeInternal _CartesianPose_default_instance_;
class CartesianSpace;
struct CartesianSpaceDefaultTypeInternal;
extern CartesianSpaceDefaultTypeInternal _CartesianSpace_default_instance_;
class CartesianVelocity;
struct CartesianVelocityDefaultTypeInternal;
extern CartesianVelocityDefaultTypeInternal _CartesianVelocity_default_instance_;
class Clock;
struct ClockDefaultTypeInternal;
extern ClockDefaultTypeInternal _Clock_default_instance_;
class Euler;
struct EulerDefaultTypeInternal;
extern EulerDefaultTypeInternal _Euler_default_instance_;
class External;
struct ExternalDefaultTypeInternal;
extern ExternalDefaultTypeInternal _External_default_instance_;
class Feedback;
struct FeedbackDefaultTypeInternal;
extern FeedbackDefaultTypeInternal _Feedback_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Input;
struct InputDefaultTypeInternal;
extern InputDefaultTypeInternal _Input_default_instance_;
class JointSpace;
struct JointSpaceDefaultTypeInternal;
extern JointSpaceDefaultTypeInternal _JointSpace_default_instance_;
class Joints;
struct JointsDefaultTypeInternal;
extern JointsDefaultTypeInternal _Joints_default_instance_;
class Output;
struct OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Planned;
struct PlannedDefaultTypeInternal;
extern PlannedDefaultTypeInternal _Planned_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Robot;
struct RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace wrapper
}  // namespace egm
}  // namespace abb
PROTOBUF_NAMESPACE_OPEN
template<> ::abb::egm::wrapper::Cartesian* Arena::CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(Arena*);
template<> ::abb::egm::wrapper::CartesianPose* Arena::CreateMaybeMessage<::abb::egm::wrapper::CartesianPose>(Arena*);
template<> ::abb::egm::wrapper::CartesianSpace* Arena::CreateMaybeMessage<::abb::egm::wrapper::CartesianSpace>(Arena*);
template<> ::abb::egm::wrapper::CartesianVelocity* Arena::CreateMaybeMessage<::abb::egm::wrapper::CartesianVelocity>(Arena*);
template<> ::abb::egm::wrapper::Clock* Arena::CreateMaybeMessage<::abb::egm::wrapper::Clock>(Arena*);
template<> ::abb::egm::wrapper::Euler* Arena::CreateMaybeMessage<::abb::egm::wrapper::Euler>(Arena*);
template<> ::abb::egm::wrapper::External* Arena::CreateMaybeMessage<::abb::egm::wrapper::External>(Arena*);
template<> ::abb::egm::wrapper::Feedback* Arena::CreateMaybeMessage<::abb::egm::wrapper::Feedback>(Arena*);
template<> ::abb::egm::wrapper::Header* Arena::CreateMaybeMessage<::abb::egm::wrapper::Header>(Arena*);
template<> ::abb::egm::wrapper::Input* Arena::CreateMaybeMessage<::abb::egm::wrapper::Input>(Arena*);
template<> ::abb::egm::wrapper::JointSpace* Arena::CreateMaybeMessage<::abb::egm::wrapper::JointSpace>(Arena*);
template<> ::abb::egm::wrapper::Joints* Arena::CreateMaybeMessage<::abb::egm::wrapper::Joints>(Arena*);
template<> ::abb::egm::wrapper::Output* Arena::CreateMaybeMessage<::abb::egm::wrapper::Output>(Arena*);
template<> ::abb::egm::wrapper::Planned* Arena::CreateMaybeMessage<::abb::egm::wrapper::Planned>(Arena*);
template<> ::abb::egm::wrapper::Quaternion* Arena::CreateMaybeMessage<::abb::egm::wrapper::Quaternion>(Arena*);
template<> ::abb::egm::wrapper::Robot* Arena::CreateMaybeMessage<::abb::egm::wrapper::Robot>(Arena*);
template<> ::abb::egm::wrapper::Status* Arena::CreateMaybeMessage<::abb::egm::wrapper::Status>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace abb {
namespace egm {
namespace wrapper {

enum Header_MessageType : int {
  Header_MessageType_UNDEFINED = 0,
  Header_MessageType_DATA = 1
};
bool Header_MessageType_IsValid(int value);
constexpr Header_MessageType Header_MessageType_MessageType_MIN = Header_MessageType_UNDEFINED;
constexpr Header_MessageType Header_MessageType_MessageType_MAX = Header_MessageType_DATA;
constexpr int Header_MessageType_MessageType_ARRAYSIZE = Header_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Header_MessageType_descriptor();
template<typename T>
inline const std::string& Header_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Header_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Header_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Header_MessageType_descriptor(), enum_t_value);
}
inline bool Header_MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Header_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Header_MessageType>(
    Header_MessageType_descriptor(), name, value);
}
enum Header_RWVersion : int {
  Header_RWVersion_RW_UNKNOWN = 0,
  Header_RWVersion_RW_6_10_AND_NEWER = 1,
  Header_RWVersion_RW_BETWEEN_6_AND_6_06_03 = 2,
  Header_RWVersion_RW_BETWEEN_6_07_AND_6_09_02 = 3
};
bool Header_RWVersion_IsValid(int value);
constexpr Header_RWVersion Header_RWVersion_RWVersion_MIN = Header_RWVersion_RW_UNKNOWN;
constexpr Header_RWVersion Header_RWVersion_RWVersion_MAX = Header_RWVersion_RW_BETWEEN_6_07_AND_6_09_02;
constexpr int Header_RWVersion_RWVersion_ARRAYSIZE = Header_RWVersion_RWVersion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Header_RWVersion_descriptor();
template<typename T>
inline const std::string& Header_RWVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Header_RWVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Header_RWVersion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Header_RWVersion_descriptor(), enum_t_value);
}
inline bool Header_RWVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Header_RWVersion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Header_RWVersion>(
    Header_RWVersion_descriptor(), name, value);
}
enum Header_EGMVersion : int {
  Header_EGMVersion_EGM_UNKNOWN = 0,
  Header_EGMVersion_EGM_1_0 = 1,
  Header_EGMVersion_EGM_1_1 = 2
};
bool Header_EGMVersion_IsValid(int value);
constexpr Header_EGMVersion Header_EGMVersion_EGMVersion_MIN = Header_EGMVersion_EGM_UNKNOWN;
constexpr Header_EGMVersion Header_EGMVersion_EGMVersion_MAX = Header_EGMVersion_EGM_1_1;
constexpr int Header_EGMVersion_EGMVersion_ARRAYSIZE = Header_EGMVersion_EGMVersion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Header_EGMVersion_descriptor();
template<typename T>
inline const std::string& Header_EGMVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Header_EGMVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Header_EGMVersion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Header_EGMVersion_descriptor(), enum_t_value);
}
inline bool Header_EGMVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Header_EGMVersion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Header_EGMVersion>(
    Header_EGMVersion_descriptor(), name, value);
}
enum Status_EGMState : int {
  Status_EGMState_EGM_UNDEFINED = 0,
  Status_EGMState_EGM_ERROR = 1,
  Status_EGMState_EGM_STOPPED = 2,
  Status_EGMState_EGM_RUNNING = 3
};
bool Status_EGMState_IsValid(int value);
constexpr Status_EGMState Status_EGMState_EGMState_MIN = Status_EGMState_EGM_UNDEFINED;
constexpr Status_EGMState Status_EGMState_EGMState_MAX = Status_EGMState_EGM_RUNNING;
constexpr int Status_EGMState_EGMState_ARRAYSIZE = Status_EGMState_EGMState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_EGMState_descriptor();
template<typename T>
inline const std::string& Status_EGMState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status_EGMState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_EGMState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_EGMState_descriptor(), enum_t_value);
}
inline bool Status_EGMState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status_EGMState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status_EGMState>(
    Status_EGMState_descriptor(), name, value);
}
enum Status_MotorState : int {
  Status_MotorState_MOTORS_UNDEFINED = 0,
  Status_MotorState_MOTORS_ON = 1,
  Status_MotorState_MOTORS_OFF = 2
};
bool Status_MotorState_IsValid(int value);
constexpr Status_MotorState Status_MotorState_MotorState_MIN = Status_MotorState_MOTORS_UNDEFINED;
constexpr Status_MotorState Status_MotorState_MotorState_MAX = Status_MotorState_MOTORS_OFF;
constexpr int Status_MotorState_MotorState_ARRAYSIZE = Status_MotorState_MotorState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_MotorState_descriptor();
template<typename T>
inline const std::string& Status_MotorState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status_MotorState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_MotorState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_MotorState_descriptor(), enum_t_value);
}
inline bool Status_MotorState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status_MotorState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status_MotorState>(
    Status_MotorState_descriptor(), name, value);
}
enum Status_RAPIDExecutionState : int {
  Status_RAPIDExecutionState_RAPID_UNDEFINED = 0,
  Status_RAPIDExecutionState_RAPID_STOPPED = 1,
  Status_RAPIDExecutionState_RAPID_RUNNING = 2
};
bool Status_RAPIDExecutionState_IsValid(int value);
constexpr Status_RAPIDExecutionState Status_RAPIDExecutionState_RAPIDExecutionState_MIN = Status_RAPIDExecutionState_RAPID_UNDEFINED;
constexpr Status_RAPIDExecutionState Status_RAPIDExecutionState_RAPIDExecutionState_MAX = Status_RAPIDExecutionState_RAPID_RUNNING;
constexpr int Status_RAPIDExecutionState_RAPIDExecutionState_ARRAYSIZE = Status_RAPIDExecutionState_RAPIDExecutionState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_RAPIDExecutionState_descriptor();
template<typename T>
inline const std::string& Status_RAPIDExecutionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status_RAPIDExecutionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_RAPIDExecutionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_RAPIDExecutionState_descriptor(), enum_t_value);
}
inline bool Status_RAPIDExecutionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status_RAPIDExecutionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status_RAPIDExecutionState>(
    Status_RAPIDExecutionState_descriptor(), name, value);
}
// ===================================================================

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit PROTOBUF_CONSTEXPR Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Header_MessageType MessageType;
  static constexpr MessageType UNDEFINED =
    Header_MessageType_UNDEFINED;
  static constexpr MessageType DATA =
    Header_MessageType_DATA;
  static inline bool MessageType_IsValid(int value) {
    return Header_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    Header_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    Header_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    Header_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return Header_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return Header_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MessageType* value) {
    return Header_MessageType_Parse(name, value);
  }

  typedef Header_RWVersion RWVersion;
  static constexpr RWVersion RW_UNKNOWN =
    Header_RWVersion_RW_UNKNOWN;
  static constexpr RWVersion RW_6_10_AND_NEWER =
    Header_RWVersion_RW_6_10_AND_NEWER;
  static constexpr RWVersion RW_BETWEEN_6_AND_6_06_03 =
    Header_RWVersion_RW_BETWEEN_6_AND_6_06_03;
  static constexpr RWVersion RW_BETWEEN_6_07_AND_6_09_02 =
    Header_RWVersion_RW_BETWEEN_6_07_AND_6_09_02;
  static inline bool RWVersion_IsValid(int value) {
    return Header_RWVersion_IsValid(value);
  }
  static constexpr RWVersion RWVersion_MIN =
    Header_RWVersion_RWVersion_MIN;
  static constexpr RWVersion RWVersion_MAX =
    Header_RWVersion_RWVersion_MAX;
  static constexpr int RWVersion_ARRAYSIZE =
    Header_RWVersion_RWVersion_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RWVersion_descriptor() {
    return Header_RWVersion_descriptor();
  }
  template<typename T>
  static inline const std::string& RWVersion_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RWVersion>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RWVersion_Name.");
    return Header_RWVersion_Name(enum_t_value);
  }
  static inline bool RWVersion_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RWVersion* value) {
    return Header_RWVersion_Parse(name, value);
  }

  typedef Header_EGMVersion EGMVersion;
  static constexpr EGMVersion EGM_UNKNOWN =
    Header_EGMVersion_EGM_UNKNOWN;
  static constexpr EGMVersion EGM_1_0 =
    Header_EGMVersion_EGM_1_0;
  static constexpr EGMVersion EGM_1_1 =
    Header_EGMVersion_EGM_1_1;
  static inline bool EGMVersion_IsValid(int value) {
    return Header_EGMVersion_IsValid(value);
  }
  static constexpr EGMVersion EGMVersion_MIN =
    Header_EGMVersion_EGMVersion_MIN;
  static constexpr EGMVersion EGMVersion_MAX =
    Header_EGMVersion_EGMVersion_MAX;
  static constexpr int EGMVersion_ARRAYSIZE =
    Header_EGMVersion_EGMVersion_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EGMVersion_descriptor() {
    return Header_EGMVersion_descriptor();
  }
  template<typename T>
  static inline const std::string& EGMVersion_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EGMVersion>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EGMVersion_Name.");
    return Header_EGMVersion_Name(enum_t_value);
  }
  static inline bool EGMVersion_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EGMVersion* value) {
    return Header_EGMVersion_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceNumberFieldNumber = 1,
    kTimeStampFieldNumber = 2,
    kMessageTypeFieldNumber = 3,
    kRwVersionFieldNumber = 4,
    kEgmVersionFieldNumber = 5,
  };
  // optional uint32 sequence_number = 1;
  bool has_sequence_number() const;
  private:
  bool _internal_has_sequence_number() const;
  public:
  void clear_sequence_number();
  uint32_t sequence_number() const;
  void set_sequence_number(uint32_t value);
  private:
  uint32_t _internal_sequence_number() const;
  void _internal_set_sequence_number(uint32_t value);
  public:

  // optional uint32 time_stamp = 2;
  bool has_time_stamp() const;
  private:
  bool _internal_has_time_stamp() const;
  public:
  void clear_time_stamp();
  uint32_t time_stamp() const;
  void set_time_stamp(uint32_t value);
  private:
  uint32_t _internal_time_stamp() const;
  void _internal_set_time_stamp(uint32_t value);
  public:

  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  bool has_message_type() const;
  private:
  bool _internal_has_message_type() const;
  public:
  void clear_message_type();
  ::abb::egm::wrapper::Header_MessageType message_type() const;
  void set_message_type(::abb::egm::wrapper::Header_MessageType value);
  private:
  ::abb::egm::wrapper::Header_MessageType _internal_message_type() const;
  void _internal_set_message_type(::abb::egm::wrapper::Header_MessageType value);
  public:

  // optional .abb.egm.wrapper.Header.RWVersion rw_version = 4 [default = RW_UNKNOWN];
  bool has_rw_version() const;
  private:
  bool _internal_has_rw_version() const;
  public:
  void clear_rw_version();
  ::abb::egm::wrapper::Header_RWVersion rw_version() const;
  void set_rw_version(::abb::egm::wrapper::Header_RWVersion value);
  private:
  ::abb::egm::wrapper::Header_RWVersion _internal_rw_version() const;
  void _internal_set_rw_version(::abb::egm::wrapper::Header_RWVersion value);
  public:

  // optional .abb.egm.wrapper.Header.EGMVersion egm_version = 5 [default = EGM_UNKNOWN];
  bool has_egm_version() const;
  private:
  bool _internal_has_egm_version() const;
  public:
  void clear_egm_version();
  ::abb::egm::wrapper::Header_EGMVersion egm_version() const;
  void set_egm_version(::abb::egm::wrapper::Header_EGMVersion value);
  private:
  ::abb::egm::wrapper::Header_EGMVersion _internal_egm_version() const;
  void _internal_set_egm_version(::abb::egm::wrapper::Header_EGMVersion value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t sequence_number_;
    uint32_t time_stamp_;
    int message_type_;
    int rw_version_;
    int egm_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit PROTOBUF_CONSTEXPR Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Status_EGMState EGMState;
  static constexpr EGMState EGM_UNDEFINED =
    Status_EGMState_EGM_UNDEFINED;
  static constexpr EGMState EGM_ERROR =
    Status_EGMState_EGM_ERROR;
  static constexpr EGMState EGM_STOPPED =
    Status_EGMState_EGM_STOPPED;
  static constexpr EGMState EGM_RUNNING =
    Status_EGMState_EGM_RUNNING;
  static inline bool EGMState_IsValid(int value) {
    return Status_EGMState_IsValid(value);
  }
  static constexpr EGMState EGMState_MIN =
    Status_EGMState_EGMState_MIN;
  static constexpr EGMState EGMState_MAX =
    Status_EGMState_EGMState_MAX;
  static constexpr int EGMState_ARRAYSIZE =
    Status_EGMState_EGMState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EGMState_descriptor() {
    return Status_EGMState_descriptor();
  }
  template<typename T>
  static inline const std::string& EGMState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EGMState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EGMState_Name.");
    return Status_EGMState_Name(enum_t_value);
  }
  static inline bool EGMState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EGMState* value) {
    return Status_EGMState_Parse(name, value);
  }

  typedef Status_MotorState MotorState;
  static constexpr MotorState MOTORS_UNDEFINED =
    Status_MotorState_MOTORS_UNDEFINED;
  static constexpr MotorState MOTORS_ON =
    Status_MotorState_MOTORS_ON;
  static constexpr MotorState MOTORS_OFF =
    Status_MotorState_MOTORS_OFF;
  static inline bool MotorState_IsValid(int value) {
    return Status_MotorState_IsValid(value);
  }
  static constexpr MotorState MotorState_MIN =
    Status_MotorState_MotorState_MIN;
  static constexpr MotorState MotorState_MAX =
    Status_MotorState_MotorState_MAX;
  static constexpr int MotorState_ARRAYSIZE =
    Status_MotorState_MotorState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MotorState_descriptor() {
    return Status_MotorState_descriptor();
  }
  template<typename T>
  static inline const std::string& MotorState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MotorState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MotorState_Name.");
    return Status_MotorState_Name(enum_t_value);
  }
  static inline bool MotorState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MotorState* value) {
    return Status_MotorState_Parse(name, value);
  }

  typedef Status_RAPIDExecutionState RAPIDExecutionState;
  static constexpr RAPIDExecutionState RAPID_UNDEFINED =
    Status_RAPIDExecutionState_RAPID_UNDEFINED;
  static constexpr RAPIDExecutionState RAPID_STOPPED =
    Status_RAPIDExecutionState_RAPID_STOPPED;
  static constexpr RAPIDExecutionState RAPID_RUNNING =
    Status_RAPIDExecutionState_RAPID_RUNNING;
  static inline bool RAPIDExecutionState_IsValid(int value) {
    return Status_RAPIDExecutionState_IsValid(value);
  }
  static constexpr RAPIDExecutionState RAPIDExecutionState_MIN =
    Status_RAPIDExecutionState_RAPIDExecutionState_MIN;
  static constexpr RAPIDExecutionState RAPIDExecutionState_MAX =
    Status_RAPIDExecutionState_RAPIDExecutionState_MAX;
  static constexpr int RAPIDExecutionState_ARRAYSIZE =
    Status_RAPIDExecutionState_RAPIDExecutionState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RAPIDExecutionState_descriptor() {
    return Status_RAPIDExecutionState_descriptor();
  }
  template<typename T>
  static inline const std::string& RAPIDExecutionState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RAPIDExecutionState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RAPIDExecutionState_Name.");
    return Status_RAPIDExecutionState_Name(enum_t_value);
  }
  static inline bool RAPIDExecutionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RAPIDExecutionState* value) {
    return Status_RAPIDExecutionState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEgmConvergenceMetFieldNumber = 1,
    kEgmStateFieldNumber = 2,
    kMotorStateFieldNumber = 3,
    kRapidExecutionStateFieldNumber = 4,
    kUtilizationRateFieldNumber = 5,
  };
  // optional bool egm_convergence_met = 1;
  bool has_egm_convergence_met() const;
  private:
  bool _internal_has_egm_convergence_met() const;
  public:
  void clear_egm_convergence_met();
  bool egm_convergence_met() const;
  void set_egm_convergence_met(bool value);
  private:
  bool _internal_egm_convergence_met() const;
  void _internal_set_egm_convergence_met(bool value);
  public:

  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  bool has_egm_state() const;
  private:
  bool _internal_has_egm_state() const;
  public:
  void clear_egm_state();
  ::abb::egm::wrapper::Status_EGMState egm_state() const;
  void set_egm_state(::abb::egm::wrapper::Status_EGMState value);
  private:
  ::abb::egm::wrapper::Status_EGMState _internal_egm_state() const;
  void _internal_set_egm_state(::abb::egm::wrapper::Status_EGMState value);
  public:

  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  bool has_motor_state() const;
  private:
  bool _internal_has_motor_state() const;
  public:
  void clear_motor_state();
  ::abb::egm::wrapper::Status_MotorState motor_state() const;
  void set_motor_state(::abb::egm::wrapper::Status_MotorState value);
  private:
  ::abb::egm::wrapper::Status_MotorState _internal_motor_state() const;
  void _internal_set_motor_state(::abb::egm::wrapper::Status_MotorState value);
  public:

  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  bool has_rapid_execution_state() const;
  private:
  bool _internal_has_rapid_execution_state() const;
  public:
  void clear_rapid_execution_state();
  ::abb::egm::wrapper::Status_RAPIDExecutionState rapid_execution_state() const;
  void set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value);
  private:
  ::abb::egm::wrapper::Status_RAPIDExecutionState _internal_rapid_execution_state() const;
  void _internal_set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value);
  public:

  // optional double utilization_rate = 5;
  bool has_utilization_rate() const;
  private:
  bool _internal_has_utilization_rate() const;
  public:
  void clear_utilization_rate();
  double utilization_rate() const;
  void set_utilization_rate(double value);
  private:
  double _internal_utilization_rate() const;
  void _internal_set_utilization_rate(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool egm_convergence_met_;
    int egm_state_;
    int motor_state_;
    int rapid_execution_state_;
    double utilization_rate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Clock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Clock) */ {
 public:
  inline Clock() : Clock(nullptr) {}
  ~Clock() override;
  explicit PROTOBUF_CONSTEXPR Clock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Clock(const Clock& from);
  Clock(Clock&& from) noexcept
    : Clock() {
    *this = ::std::move(from);
  }

  inline Clock& operator=(const Clock& from) {
    CopyFrom(from);
    return *this;
  }
  inline Clock& operator=(Clock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Clock& default_instance() {
    return *internal_default_instance();
  }
  static inline const Clock* internal_default_instance() {
    return reinterpret_cast<const Clock*>(
               &_Clock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Clock& a, Clock& b) {
    a.Swap(&b);
  }
  inline void Swap(Clock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Clock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Clock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Clock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Clock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Clock& from) {
    Clock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Clock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Clock";
  }
  protected:
  explicit Clock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecFieldNumber = 1,
    kUsecFieldNumber = 2,
  };
  // optional uint64 sec = 1;
  bool has_sec() const;
  private:
  bool _internal_has_sec() const;
  public:
  void clear_sec();
  uint64_t sec() const;
  void set_sec(uint64_t value);
  private:
  uint64_t _internal_sec() const;
  void _internal_set_sec(uint64_t value);
  public:

  // optional uint64 usec = 2;
  bool has_usec() const;
  private:
  bool _internal_has_usec() const;
  public:
  void clear_usec();
  uint64_t usec() const;
  void set_usec(uint64_t value);
  private:
  uint64_t _internal_usec() const;
  void _internal_set_usec(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Clock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t sec_;
    uint64_t usec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Joints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Joints) */ {
 public:
  inline Joints() : Joints(nullptr) {}
  ~Joints() override;
  explicit PROTOBUF_CONSTEXPR Joints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Joints(const Joints& from);
  Joints(Joints&& from) noexcept
    : Joints() {
    *this = ::std::move(from);
  }

  inline Joints& operator=(const Joints& from) {
    CopyFrom(from);
    return *this;
  }
  inline Joints& operator=(Joints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Joints& default_instance() {
    return *internal_default_instance();
  }
  static inline const Joints* internal_default_instance() {
    return reinterpret_cast<const Joints*>(
               &_Joints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Joints& a, Joints& b) {
    a.Swap(&b);
  }
  inline void Swap(Joints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Joints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Joints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Joints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Joints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Joints& from) {
    Joints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Joints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Joints";
  }
  protected:
  explicit Joints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated double values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  double _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_values() const;
  void _internal_add_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_values();
  public:
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Joints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class JointSpace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.JointSpace) */ {
 public:
  inline JointSpace() : JointSpace(nullptr) {}
  ~JointSpace() override;
  explicit PROTOBUF_CONSTEXPR JointSpace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JointSpace(const JointSpace& from);
  JointSpace(JointSpace&& from) noexcept
    : JointSpace() {
    *this = ::std::move(from);
  }

  inline JointSpace& operator=(const JointSpace& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointSpace& operator=(JointSpace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JointSpace& default_instance() {
    return *internal_default_instance();
  }
  static inline const JointSpace* internal_default_instance() {
    return reinterpret_cast<const JointSpace*>(
               &_JointSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JointSpace& a, JointSpace& b) {
    a.Swap(&b);
  }
  inline void Swap(JointSpace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointSpace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JointSpace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JointSpace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JointSpace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JointSpace& from) {
    JointSpace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointSpace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.JointSpace";
  }
  protected:
  explicit JointSpace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kVelocityFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.Joints position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::abb::egm::wrapper::Joints& position() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Joints* release_position();
  ::abb::egm::wrapper::Joints* mutable_position();
  void set_allocated_position(::abb::egm::wrapper::Joints* position);
  private:
  const ::abb::egm::wrapper::Joints& _internal_position() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::abb::egm::wrapper::Joints* position);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_position();

  // optional .abb.egm.wrapper.Joints velocity = 2;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::abb::egm::wrapper::Joints& velocity() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Joints* release_velocity();
  ::abb::egm::wrapper::Joints* mutable_velocity();
  void set_allocated_velocity(::abb::egm::wrapper::Joints* velocity);
  private:
  const ::abb::egm::wrapper::Joints& _internal_velocity() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::abb::egm::wrapper::Joints* velocity);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_velocity();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.JointSpace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Joints* position_;
    ::abb::egm::wrapper::Joints* velocity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Cartesian final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Cartesian) */ {
 public:
  inline Cartesian() : Cartesian(nullptr) {}
  ~Cartesian() override;
  explicit PROTOBUF_CONSTEXPR Cartesian(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cartesian(const Cartesian& from);
  Cartesian(Cartesian&& from) noexcept
    : Cartesian() {
    *this = ::std::move(from);
  }

  inline Cartesian& operator=(const Cartesian& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cartesian& operator=(Cartesian&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cartesian& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cartesian* internal_default_instance() {
    return reinterpret_cast<const Cartesian*>(
               &_Cartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Cartesian& a, Cartesian& b) {
    a.Swap(&b);
  }
  inline void Swap(Cartesian* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cartesian* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cartesian* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cartesian>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cartesian& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cartesian& from) {
    Cartesian::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cartesian* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Cartesian";
  }
  protected:
  explicit Cartesian(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // optional double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Cartesian)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Euler final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Euler) */ {
 public:
  inline Euler() : Euler(nullptr) {}
  ~Euler() override;
  explicit PROTOBUF_CONSTEXPR Euler(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Euler(const Euler& from);
  Euler(Euler&& from) noexcept
    : Euler() {
    *this = ::std::move(from);
  }

  inline Euler& operator=(const Euler& from) {
    CopyFrom(from);
    return *this;
  }
  inline Euler& operator=(Euler&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Euler& default_instance() {
    return *internal_default_instance();
  }
  static inline const Euler* internal_default_instance() {
    return reinterpret_cast<const Euler*>(
               &_Euler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Euler& a, Euler& b) {
    a.Swap(&b);
  }
  inline void Swap(Euler* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Euler* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Euler* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Euler>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Euler& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Euler& from) {
    Euler::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Euler* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Euler";
  }
  protected:
  explicit Euler(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // optional double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Euler)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Quaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  explicit PROTOBUF_CONSTEXPR Quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kU0FieldNumber = 1,
    kU1FieldNumber = 2,
    kU2FieldNumber = 3,
    kU3FieldNumber = 4,
  };
  // optional double u0 = 1;
  bool has_u0() const;
  private:
  bool _internal_has_u0() const;
  public:
  void clear_u0();
  double u0() const;
  void set_u0(double value);
  private:
  double _internal_u0() const;
  void _internal_set_u0(double value);
  public:

  // optional double u1 = 2;
  bool has_u1() const;
  private:
  bool _internal_has_u1() const;
  public:
  void clear_u1();
  double u1() const;
  void set_u1(double value);
  private:
  double _internal_u1() const;
  void _internal_set_u1(double value);
  public:

  // optional double u2 = 3;
  bool has_u2() const;
  private:
  bool _internal_has_u2() const;
  public:
  void clear_u2();
  double u2() const;
  void set_u2(double value);
  private:
  double _internal_u2() const;
  void _internal_set_u2(double value);
  public:

  // optional double u3 = 4;
  bool has_u3() const;
  private:
  bool _internal_has_u3() const;
  public:
  void clear_u3();
  double u3() const;
  void set_u3(double value);
  private:
  double _internal_u3() const;
  void _internal_set_u3(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double u0_;
    double u1_;
    double u2_;
    double u3_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class CartesianPose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.CartesianPose) */ {
 public:
  inline CartesianPose() : CartesianPose(nullptr) {}
  ~CartesianPose() override;
  explicit PROTOBUF_CONSTEXPR CartesianPose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CartesianPose(const CartesianPose& from);
  CartesianPose(CartesianPose&& from) noexcept
    : CartesianPose() {
    *this = ::std::move(from);
  }

  inline CartesianPose& operator=(const CartesianPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartesianPose& operator=(CartesianPose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CartesianPose& default_instance() {
    return *internal_default_instance();
  }
  static inline const CartesianPose* internal_default_instance() {
    return reinterpret_cast<const CartesianPose*>(
               &_CartesianPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CartesianPose& a, CartesianPose& b) {
    a.Swap(&b);
  }
  inline void Swap(CartesianPose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartesianPose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CartesianPose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CartesianPose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CartesianPose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CartesianPose& from) {
    CartesianPose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianPose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.CartesianPose";
  }
  protected:
  explicit CartesianPose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kEulerFieldNumber = 2,
    kQuaternionFieldNumber = 3,
  };
  // optional .abb.egm.wrapper.Cartesian position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::abb::egm::wrapper::Cartesian& position() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Cartesian* release_position();
  ::abb::egm::wrapper::Cartesian* mutable_position();
  void set_allocated_position(::abb::egm::wrapper::Cartesian* position);
  private:
  const ::abb::egm::wrapper::Cartesian& _internal_position() const;
  ::abb::egm::wrapper::Cartesian* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::abb::egm::wrapper::Cartesian* position);
  ::abb::egm::wrapper::Cartesian* unsafe_arena_release_position();

  // optional .abb.egm.wrapper.Euler euler = 2;
  bool has_euler() const;
  private:
  bool _internal_has_euler() const;
  public:
  void clear_euler();
  const ::abb::egm::wrapper::Euler& euler() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Euler* release_euler();
  ::abb::egm::wrapper::Euler* mutable_euler();
  void set_allocated_euler(::abb::egm::wrapper::Euler* euler);
  private:
  const ::abb::egm::wrapper::Euler& _internal_euler() const;
  ::abb::egm::wrapper::Euler* _internal_mutable_euler();
  public:
  void unsafe_arena_set_allocated_euler(
      ::abb::egm::wrapper::Euler* euler);
  ::abb::egm::wrapper::Euler* unsafe_arena_release_euler();

  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  bool has_quaternion() const;
  private:
  bool _internal_has_quaternion() const;
  public:
  void clear_quaternion();
  const ::abb::egm::wrapper::Quaternion& quaternion() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Quaternion* release_quaternion();
  ::abb::egm::wrapper::Quaternion* mutable_quaternion();
  void set_allocated_quaternion(::abb::egm::wrapper::Quaternion* quaternion);
  private:
  const ::abb::egm::wrapper::Quaternion& _internal_quaternion() const;
  ::abb::egm::wrapper::Quaternion* _internal_mutable_quaternion();
  public:
  void unsafe_arena_set_allocated_quaternion(
      ::abb::egm::wrapper::Quaternion* quaternion);
  ::abb::egm::wrapper::Quaternion* unsafe_arena_release_quaternion();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianPose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Cartesian* position_;
    ::abb::egm::wrapper::Euler* euler_;
    ::abb::egm::wrapper::Quaternion* quaternion_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class CartesianVelocity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.CartesianVelocity) */ {
 public:
  inline CartesianVelocity() : CartesianVelocity(nullptr) {}
  ~CartesianVelocity() override;
  explicit PROTOBUF_CONSTEXPR CartesianVelocity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CartesianVelocity(const CartesianVelocity& from);
  CartesianVelocity(CartesianVelocity&& from) noexcept
    : CartesianVelocity() {
    *this = ::std::move(from);
  }

  inline CartesianVelocity& operator=(const CartesianVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartesianVelocity& operator=(CartesianVelocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CartesianVelocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const CartesianVelocity* internal_default_instance() {
    return reinterpret_cast<const CartesianVelocity*>(
               &_CartesianVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CartesianVelocity& a, CartesianVelocity& b) {
    a.Swap(&b);
  }
  inline void Swap(CartesianVelocity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartesianVelocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CartesianVelocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CartesianVelocity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CartesianVelocity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CartesianVelocity& from) {
    CartesianVelocity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianVelocity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.CartesianVelocity";
  }
  protected:
  explicit CartesianVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.Cartesian linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::abb::egm::wrapper::Cartesian& linear() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Cartesian* release_linear();
  ::abb::egm::wrapper::Cartesian* mutable_linear();
  void set_allocated_linear(::abb::egm::wrapper::Cartesian* linear);
  private:
  const ::abb::egm::wrapper::Cartesian& _internal_linear() const;
  ::abb::egm::wrapper::Cartesian* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::abb::egm::wrapper::Cartesian* linear);
  ::abb::egm::wrapper::Cartesian* unsafe_arena_release_linear();

  // optional .abb.egm.wrapper.Euler angular = 2;
  bool has_angular() const;
  private:
  bool _internal_has_angular() const;
  public:
  void clear_angular();
  const ::abb::egm::wrapper::Euler& angular() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Euler* release_angular();
  ::abb::egm::wrapper::Euler* mutable_angular();
  void set_allocated_angular(::abb::egm::wrapper::Euler* angular);
  private:
  const ::abb::egm::wrapper::Euler& _internal_angular() const;
  ::abb::egm::wrapper::Euler* _internal_mutable_angular();
  public:
  void unsafe_arena_set_allocated_angular(
      ::abb::egm::wrapper::Euler* angular);
  ::abb::egm::wrapper::Euler* unsafe_arena_release_angular();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianVelocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Cartesian* linear_;
    ::abb::egm::wrapper::Euler* angular_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class CartesianSpace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.CartesianSpace) */ {
 public:
  inline CartesianSpace() : CartesianSpace(nullptr) {}
  ~CartesianSpace() override;
  explicit PROTOBUF_CONSTEXPR CartesianSpace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CartesianSpace(const CartesianSpace& from);
  CartesianSpace(CartesianSpace&& from) noexcept
    : CartesianSpace() {
    *this = ::std::move(from);
  }

  inline CartesianSpace& operator=(const CartesianSpace& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartesianSpace& operator=(CartesianSpace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CartesianSpace& default_instance() {
    return *internal_default_instance();
  }
  static inline const CartesianSpace* internal_default_instance() {
    return reinterpret_cast<const CartesianSpace*>(
               &_CartesianSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CartesianSpace& a, CartesianSpace& b) {
    a.Swap(&b);
  }
  inline void Swap(CartesianSpace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartesianSpace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CartesianSpace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CartesianSpace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CartesianSpace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CartesianSpace& from) {
    CartesianSpace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianSpace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.CartesianSpace";
  }
  protected:
  explicit CartesianSpace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kVelocityFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::abb::egm::wrapper::CartesianPose& pose() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::CartesianPose* release_pose();
  ::abb::egm::wrapper::CartesianPose* mutable_pose();
  void set_allocated_pose(::abb::egm::wrapper::CartesianPose* pose);
  private:
  const ::abb::egm::wrapper::CartesianPose& _internal_pose() const;
  ::abb::egm::wrapper::CartesianPose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::abb::egm::wrapper::CartesianPose* pose);
  ::abb::egm::wrapper::CartesianPose* unsafe_arena_release_pose();

  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::abb::egm::wrapper::CartesianVelocity& velocity() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::CartesianVelocity* release_velocity();
  ::abb::egm::wrapper::CartesianVelocity* mutable_velocity();
  void set_allocated_velocity(::abb::egm::wrapper::CartesianVelocity* velocity);
  private:
  const ::abb::egm::wrapper::CartesianVelocity& _internal_velocity() const;
  ::abb::egm::wrapper::CartesianVelocity* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::abb::egm::wrapper::CartesianVelocity* velocity);
  ::abb::egm::wrapper::CartesianVelocity* unsafe_arena_release_velocity();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianSpace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::CartesianPose* pose_;
    ::abb::egm::wrapper::CartesianVelocity* velocity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Robot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Robot) */ {
 public:
  inline Robot() : Robot(nullptr) {}
  ~Robot() override;
  explicit PROTOBUF_CONSTEXPR Robot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot(const Robot& from);
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot& operator=(Robot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Robot& from) {
    Robot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Robot";
  }
  protected:
  explicit Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesianFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  bool has_joints() const;
  private:
  bool _internal_has_joints() const;
  public:
  void clear_joints();
  const ::abb::egm::wrapper::JointSpace& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::JointSpace* release_joints();
  ::abb::egm::wrapper::JointSpace* mutable_joints();
  void set_allocated_joints(::abb::egm::wrapper::JointSpace* joints);
  private:
  const ::abb::egm::wrapper::JointSpace& _internal_joints() const;
  ::abb::egm::wrapper::JointSpace* _internal_mutable_joints();
  public:
  void unsafe_arena_set_allocated_joints(
      ::abb::egm::wrapper::JointSpace* joints);
  ::abb::egm::wrapper::JointSpace* unsafe_arena_release_joints();

  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  bool has_cartesian() const;
  private:
  bool _internal_has_cartesian() const;
  public:
  void clear_cartesian();
  const ::abb::egm::wrapper::CartesianSpace& cartesian() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::CartesianSpace* release_cartesian();
  ::abb::egm::wrapper::CartesianSpace* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::wrapper::CartesianSpace* cartesian);
  private:
  const ::abb::egm::wrapper::CartesianSpace& _internal_cartesian() const;
  ::abb::egm::wrapper::CartesianSpace* _internal_mutable_cartesian();
  public:
  void unsafe_arena_set_allocated_cartesian(
      ::abb::egm::wrapper::CartesianSpace* cartesian);
  ::abb::egm::wrapper::CartesianSpace* unsafe_arena_release_cartesian();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Robot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::JointSpace* joints_;
    ::abb::egm::wrapper::CartesianSpace* cartesian_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class External final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.External) */ {
 public:
  inline External() : External(nullptr) {}
  ~External() override;
  explicit PROTOBUF_CONSTEXPR External(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  External(const External& from);
  External(External&& from) noexcept
    : External() {
    *this = ::std::move(from);
  }

  inline External& operator=(const External& from) {
    CopyFrom(from);
    return *this;
  }
  inline External& operator=(External&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const External& default_instance() {
    return *internal_default_instance();
  }
  static inline const External* internal_default_instance() {
    return reinterpret_cast<const External*>(
               &_External_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(External& a, External& b) {
    a.Swap(&b);
  }
  inline void Swap(External* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(External* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  External* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<External>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const External& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const External& from) {
    External::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(External* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.External";
  }
  protected:
  explicit External(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
  };
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  bool has_joints() const;
  private:
  bool _internal_has_joints() const;
  public:
  void clear_joints();
  const ::abb::egm::wrapper::JointSpace& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::JointSpace* release_joints();
  ::abb::egm::wrapper::JointSpace* mutable_joints();
  void set_allocated_joints(::abb::egm::wrapper::JointSpace* joints);
  private:
  const ::abb::egm::wrapper::JointSpace& _internal_joints() const;
  ::abb::egm::wrapper::JointSpace* _internal_mutable_joints();
  public:
  void unsafe_arena_set_allocated_joints(
      ::abb::egm::wrapper::JointSpace* joints);
  ::abb::egm::wrapper::JointSpace* unsafe_arena_release_joints();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.External)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::JointSpace* joints_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Feedback) */ {
 public:
  inline Feedback() : Feedback(nullptr) {}
  ~Feedback() override;
  explicit PROTOBUF_CONSTEXPR Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Feedback(const Feedback& from);
  Feedback(Feedback&& from) noexcept
    : Feedback() {
    *this = ::std::move(from);
  }

  inline Feedback& operator=(const Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline Feedback& operator=(Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const Feedback* internal_default_instance() {
    return reinterpret_cast<const Feedback*>(
               &_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Feedback& a, Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Feedback& from) {
    Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Feedback";
  }
  protected:
  explicit Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
    kExternalFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // optional .abb.egm.wrapper.Robot robot = 1;
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::abb::egm::wrapper::Robot& robot() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Robot* release_robot();
  ::abb::egm::wrapper::Robot* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::Robot* robot);
  private:
  const ::abb::egm::wrapper::Robot& _internal_robot() const;
  ::abb::egm::wrapper::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::abb::egm::wrapper::Robot* robot);
  ::abb::egm::wrapper::Robot* unsafe_arena_release_robot();

  // optional .abb.egm.wrapper.External external = 2;
  bool has_external() const;
  private:
  bool _internal_has_external() const;
  public:
  void clear_external();
  const ::abb::egm::wrapper::External& external() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::External* release_external();
  ::abb::egm::wrapper::External* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::External* external);
  private:
  const ::abb::egm::wrapper::External& _internal_external() const;
  ::abb::egm::wrapper::External* _internal_mutable_external();
  public:
  void unsafe_arena_set_allocated_external(
      ::abb::egm::wrapper::External* external);
  ::abb::egm::wrapper::External* unsafe_arena_release_external();

  // optional .abb.egm.wrapper.Clock time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::abb::egm::wrapper::Clock& time() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Clock* release_time();
  ::abb::egm::wrapper::Clock* mutable_time();
  void set_allocated_time(::abb::egm::wrapper::Clock* time);
  private:
  const ::abb::egm::wrapper::Clock& _internal_time() const;
  ::abb::egm::wrapper::Clock* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::abb::egm::wrapper::Clock* time);
  ::abb::egm::wrapper::Clock* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Robot* robot_;
    ::abb::egm::wrapper::External* external_;
    ::abb::egm::wrapper::Clock* time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Planned final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Planned) */ {
 public:
  inline Planned() : Planned(nullptr) {}
  ~Planned() override;
  explicit PROTOBUF_CONSTEXPR Planned(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Planned(const Planned& from);
  Planned(Planned&& from) noexcept
    : Planned() {
    *this = ::std::move(from);
  }

  inline Planned& operator=(const Planned& from) {
    CopyFrom(from);
    return *this;
  }
  inline Planned& operator=(Planned&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Planned& default_instance() {
    return *internal_default_instance();
  }
  static inline const Planned* internal_default_instance() {
    return reinterpret_cast<const Planned*>(
               &_Planned_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Planned& a, Planned& b) {
    a.Swap(&b);
  }
  inline void Swap(Planned* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Planned* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Planned* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Planned>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Planned& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Planned& from) {
    Planned::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Planned* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Planned";
  }
  protected:
  explicit Planned(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
    kExternalFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // optional .abb.egm.wrapper.Robot robot = 1;
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::abb::egm::wrapper::Robot& robot() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Robot* release_robot();
  ::abb::egm::wrapper::Robot* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::Robot* robot);
  private:
  const ::abb::egm::wrapper::Robot& _internal_robot() const;
  ::abb::egm::wrapper::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::abb::egm::wrapper::Robot* robot);
  ::abb::egm::wrapper::Robot* unsafe_arena_release_robot();

  // optional .abb.egm.wrapper.External external = 2;
  bool has_external() const;
  private:
  bool _internal_has_external() const;
  public:
  void clear_external();
  const ::abb::egm::wrapper::External& external() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::External* release_external();
  ::abb::egm::wrapper::External* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::External* external);
  private:
  const ::abb::egm::wrapper::External& _internal_external() const;
  ::abb::egm::wrapper::External* _internal_mutable_external();
  public:
  void unsafe_arena_set_allocated_external(
      ::abb::egm::wrapper::External* external);
  ::abb::egm::wrapper::External* unsafe_arena_release_external();

  // optional .abb.egm.wrapper.Clock time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::abb::egm::wrapper::Clock& time() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Clock* release_time();
  ::abb::egm::wrapper::Clock* mutable_time();
  void set_allocated_time(::abb::egm::wrapper::Clock* time);
  private:
  const ::abb::egm::wrapper::Clock& _internal_time() const;
  ::abb::egm::wrapper::Clock* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::abb::egm::wrapper::Clock* time);
  ::abb::egm::wrapper::Clock* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Planned)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Robot* robot_;
    ::abb::egm::wrapper::External* external_;
    ::abb::egm::wrapper::Clock* time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Input final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Input) */ {
 public:
  inline Input() : Input(nullptr) {}
  ~Input() override;
  explicit PROTOBUF_CONSTEXPR Input(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Input(const Input& from);
  Input(Input&& from) noexcept
    : Input() {
    *this = ::std::move(from);
  }

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }
  inline Input& operator=(Input&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Input& default_instance() {
    return *internal_default_instance();
  }
  static inline const Input* internal_default_instance() {
    return reinterpret_cast<const Input*>(
               &_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Input& a, Input& b) {
    a.Swap(&b);
  }
  inline void Swap(Input* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Input* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Input* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Input>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Input& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Input& from) {
    Input::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Input* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Input";
  }
  protected:
  explicit Input(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFeedbackFieldNumber = 2,
    kPlannedFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // optional .abb.egm.wrapper.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::abb::egm::wrapper::Header& header() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Header* release_header();
  ::abb::egm::wrapper::Header* mutable_header();
  void set_allocated_header(::abb::egm::wrapper::Header* header);
  private:
  const ::abb::egm::wrapper::Header& _internal_header() const;
  ::abb::egm::wrapper::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::abb::egm::wrapper::Header* header);
  ::abb::egm::wrapper::Header* unsafe_arena_release_header();

  // optional .abb.egm.wrapper.Feedback feedback = 2;
  bool has_feedback() const;
  private:
  bool _internal_has_feedback() const;
  public:
  void clear_feedback();
  const ::abb::egm::wrapper::Feedback& feedback() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Feedback* release_feedback();
  ::abb::egm::wrapper::Feedback* mutable_feedback();
  void set_allocated_feedback(::abb::egm::wrapper::Feedback* feedback);
  private:
  const ::abb::egm::wrapper::Feedback& _internal_feedback() const;
  ::abb::egm::wrapper::Feedback* _internal_mutable_feedback();
  public:
  void unsafe_arena_set_allocated_feedback(
      ::abb::egm::wrapper::Feedback* feedback);
  ::abb::egm::wrapper::Feedback* unsafe_arena_release_feedback();

  // optional .abb.egm.wrapper.Planned planned = 3;
  bool has_planned() const;
  private:
  bool _internal_has_planned() const;
  public:
  void clear_planned();
  const ::abb::egm::wrapper::Planned& planned() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Planned* release_planned();
  ::abb::egm::wrapper::Planned* mutable_planned();
  void set_allocated_planned(::abb::egm::wrapper::Planned* planned);
  private:
  const ::abb::egm::wrapper::Planned& _internal_planned() const;
  ::abb::egm::wrapper::Planned* _internal_mutable_planned();
  public:
  void unsafe_arena_set_allocated_planned(
      ::abb::egm::wrapper::Planned* planned);
  ::abb::egm::wrapper::Planned* unsafe_arena_release_planned();

  // optional .abb.egm.wrapper.Status status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::abb::egm::wrapper::Status& status() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Status* release_status();
  ::abb::egm::wrapper::Status* mutable_status();
  void set_allocated_status(::abb::egm::wrapper::Status* status);
  private:
  const ::abb::egm::wrapper::Status& _internal_status() const;
  ::abb::egm::wrapper::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::abb::egm::wrapper::Status* status);
  ::abb::egm::wrapper::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Input)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Header* header_;
    ::abb::egm::wrapper::Feedback* feedback_;
    ::abb::egm::wrapper::Planned* planned_;
    ::abb::egm::wrapper::Status* status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Output final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Output) */ {
 public:
  inline Output() : Output(nullptr) {}
  ~Output() override;
  explicit PROTOBUF_CONSTEXPR Output(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Output(const Output& from);
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  inline Output& operator=(Output&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Output& default_instance() {
    return *internal_default_instance();
  }
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }
  inline void Swap(Output* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Output* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Output* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Output& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Output& from) {
    Output::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Output";
  }
  protected:
  explicit Output(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
    kExternalFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.Robot robot = 1;
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::abb::egm::wrapper::Robot& robot() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::Robot* release_robot();
  ::abb::egm::wrapper::Robot* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::Robot* robot);
  private:
  const ::abb::egm::wrapper::Robot& _internal_robot() const;
  ::abb::egm::wrapper::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::abb::egm::wrapper::Robot* robot);
  ::abb::egm::wrapper::Robot* unsafe_arena_release_robot();

  // optional .abb.egm.wrapper.External external = 2;
  bool has_external() const;
  private:
  bool _internal_has_external() const;
  public:
  void clear_external();
  const ::abb::egm::wrapper::External& external() const;
  PROTOBUF_NODISCARD ::abb::egm::wrapper::External* release_external();
  ::abb::egm::wrapper::External* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::External* external);
  private:
  const ::abb::egm::wrapper::External& _internal_external() const;
  ::abb::egm::wrapper::External* _internal_mutable_external();
  public:
  void unsafe_arena_set_allocated_external(
      ::abb::egm::wrapper::External* external);
  ::abb::egm::wrapper::External* unsafe_arena_release_external();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Output)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::wrapper::Robot* robot_;
    ::abb::egm::wrapper::External* external_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// optional uint32 sequence_number = 1;
inline bool Header::_internal_has_sequence_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Header::has_sequence_number() const {
  return _internal_has_sequence_number();
}
inline void Header::clear_sequence_number() {
  _impl_.sequence_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Header::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline uint32_t Header::sequence_number() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.sequence_number)
  return _internal_sequence_number();
}
inline void Header::_internal_set_sequence_number(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sequence_number_ = value;
}
inline void Header::set_sequence_number(uint32_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.sequence_number)
}

// optional uint32 time_stamp = 2;
inline bool Header::_internal_has_time_stamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Header::has_time_stamp() const {
  return _internal_has_time_stamp();
}
inline void Header::clear_time_stamp() {
  _impl_.time_stamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Header::_internal_time_stamp() const {
  return _impl_.time_stamp_;
}
inline uint32_t Header::time_stamp() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.time_stamp)
  return _internal_time_stamp();
}
inline void Header::_internal_set_time_stamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.time_stamp_ = value;
}
inline void Header::set_time_stamp(uint32_t value) {
  _internal_set_time_stamp(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.time_stamp)
}

// optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
inline bool Header::_internal_has_message_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Header::has_message_type() const {
  return _internal_has_message_type();
}
inline void Header::clear_message_type() {
  _impl_.message_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::abb::egm::wrapper::Header_MessageType Header::_internal_message_type() const {
  return static_cast< ::abb::egm::wrapper::Header_MessageType >(_impl_.message_type_);
}
inline ::abb::egm::wrapper::Header_MessageType Header::message_type() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.message_type)
  return _internal_message_type();
}
inline void Header::_internal_set_message_type(::abb::egm::wrapper::Header_MessageType value) {
  assert(::abb::egm::wrapper::Header_MessageType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.message_type_ = value;
}
inline void Header::set_message_type(::abb::egm::wrapper::Header_MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.message_type)
}

// optional .abb.egm.wrapper.Header.RWVersion rw_version = 4 [default = RW_UNKNOWN];
inline bool Header::_internal_has_rw_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Header::has_rw_version() const {
  return _internal_has_rw_version();
}
inline void Header::clear_rw_version() {
  _impl_.rw_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::abb::egm::wrapper::Header_RWVersion Header::_internal_rw_version() const {
  return static_cast< ::abb::egm::wrapper::Header_RWVersion >(_impl_.rw_version_);
}
inline ::abb::egm::wrapper::Header_RWVersion Header::rw_version() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.rw_version)
  return _internal_rw_version();
}
inline void Header::_internal_set_rw_version(::abb::egm::wrapper::Header_RWVersion value) {
  assert(::abb::egm::wrapper::Header_RWVersion_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rw_version_ = value;
}
inline void Header::set_rw_version(::abb::egm::wrapper::Header_RWVersion value) {
  _internal_set_rw_version(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.rw_version)
}

// optional .abb.egm.wrapper.Header.EGMVersion egm_version = 5 [default = EGM_UNKNOWN];
inline bool Header::_internal_has_egm_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Header::has_egm_version() const {
  return _internal_has_egm_version();
}
inline void Header::clear_egm_version() {
  _impl_.egm_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::abb::egm::wrapper::Header_EGMVersion Header::_internal_egm_version() const {
  return static_cast< ::abb::egm::wrapper::Header_EGMVersion >(_impl_.egm_version_);
}
inline ::abb::egm::wrapper::Header_EGMVersion Header::egm_version() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.egm_version)
  return _internal_egm_version();
}
inline void Header::_internal_set_egm_version(::abb::egm::wrapper::Header_EGMVersion value) {
  assert(::abb::egm::wrapper::Header_EGMVersion_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.egm_version_ = value;
}
inline void Header::set_egm_version(::abb::egm::wrapper::Header_EGMVersion value) {
  _internal_set_egm_version(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.egm_version)
}

// -------------------------------------------------------------------

// Status

// optional bool egm_convergence_met = 1;
inline bool Status::_internal_has_egm_convergence_met() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Status::has_egm_convergence_met() const {
  return _internal_has_egm_convergence_met();
}
inline void Status::clear_egm_convergence_met() {
  _impl_.egm_convergence_met_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool Status::_internal_egm_convergence_met() const {
  return _impl_.egm_convergence_met_;
}
inline bool Status::egm_convergence_met() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.egm_convergence_met)
  return _internal_egm_convergence_met();
}
inline void Status::_internal_set_egm_convergence_met(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.egm_convergence_met_ = value;
}
inline void Status::set_egm_convergence_met(bool value) {
  _internal_set_egm_convergence_met(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.egm_convergence_met)
}

// optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
inline bool Status::_internal_has_egm_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Status::has_egm_state() const {
  return _internal_has_egm_state();
}
inline void Status::clear_egm_state() {
  _impl_.egm_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::abb::egm::wrapper::Status_EGMState Status::_internal_egm_state() const {
  return static_cast< ::abb::egm::wrapper::Status_EGMState >(_impl_.egm_state_);
}
inline ::abb::egm::wrapper::Status_EGMState Status::egm_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.egm_state)
  return _internal_egm_state();
}
inline void Status::_internal_set_egm_state(::abb::egm::wrapper::Status_EGMState value) {
  assert(::abb::egm::wrapper::Status_EGMState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.egm_state_ = value;
}
inline void Status::set_egm_state(::abb::egm::wrapper::Status_EGMState value) {
  _internal_set_egm_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.egm_state)
}

// optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
inline bool Status::_internal_has_motor_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Status::has_motor_state() const {
  return _internal_has_motor_state();
}
inline void Status::clear_motor_state() {
  _impl_.motor_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::abb::egm::wrapper::Status_MotorState Status::_internal_motor_state() const {
  return static_cast< ::abb::egm::wrapper::Status_MotorState >(_impl_.motor_state_);
}
inline ::abb::egm::wrapper::Status_MotorState Status::motor_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.motor_state)
  return _internal_motor_state();
}
inline void Status::_internal_set_motor_state(::abb::egm::wrapper::Status_MotorState value) {
  assert(::abb::egm::wrapper::Status_MotorState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.motor_state_ = value;
}
inline void Status::set_motor_state(::abb::egm::wrapper::Status_MotorState value) {
  _internal_set_motor_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.motor_state)
}

// optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
inline bool Status::_internal_has_rapid_execution_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Status::has_rapid_execution_state() const {
  return _internal_has_rapid_execution_state();
}
inline void Status::clear_rapid_execution_state() {
  _impl_.rapid_execution_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::abb::egm::wrapper::Status_RAPIDExecutionState Status::_internal_rapid_execution_state() const {
  return static_cast< ::abb::egm::wrapper::Status_RAPIDExecutionState >(_impl_.rapid_execution_state_);
}
inline ::abb::egm::wrapper::Status_RAPIDExecutionState Status::rapid_execution_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.rapid_execution_state)
  return _internal_rapid_execution_state();
}
inline void Status::_internal_set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value) {
  assert(::abb::egm::wrapper::Status_RAPIDExecutionState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rapid_execution_state_ = value;
}
inline void Status::set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value) {
  _internal_set_rapid_execution_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.rapid_execution_state)
}

// optional double utilization_rate = 5;
inline bool Status::_internal_has_utilization_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Status::has_utilization_rate() const {
  return _internal_has_utilization_rate();
}
inline void Status::clear_utilization_rate() {
  _impl_.utilization_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double Status::_internal_utilization_rate() const {
  return _impl_.utilization_rate_;
}
inline double Status::utilization_rate() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.utilization_rate)
  return _internal_utilization_rate();
}
inline void Status::_internal_set_utilization_rate(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.utilization_rate_ = value;
}
inline void Status::set_utilization_rate(double value) {
  _internal_set_utilization_rate(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.utilization_rate)
}

// -------------------------------------------------------------------

// Clock

// optional uint64 sec = 1;
inline bool Clock::_internal_has_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Clock::has_sec() const {
  return _internal_has_sec();
}
inline void Clock::clear_sec() {
  _impl_.sec_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Clock::_internal_sec() const {
  return _impl_.sec_;
}
inline uint64_t Clock::sec() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Clock.sec)
  return _internal_sec();
}
inline void Clock::_internal_set_sec(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sec_ = value;
}
inline void Clock::set_sec(uint64_t value) {
  _internal_set_sec(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Clock.sec)
}

// optional uint64 usec = 2;
inline bool Clock::_internal_has_usec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Clock::has_usec() const {
  return _internal_has_usec();
}
inline void Clock::clear_usec() {
  _impl_.usec_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Clock::_internal_usec() const {
  return _impl_.usec_;
}
inline uint64_t Clock::usec() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Clock.usec)
  return _internal_usec();
}
inline void Clock::_internal_set_usec(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.usec_ = value;
}
inline void Clock::set_usec(uint64_t value) {
  _internal_set_usec(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Clock.usec)
}

// -------------------------------------------------------------------

// Joints

// repeated double values = 1;
inline int Joints::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Joints::values_size() const {
  return _internal_values_size();
}
inline void Joints::clear_values() {
  _impl_.values_.Clear();
}
inline double Joints::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline double Joints::values(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Joints.values)
  return _internal_values(index);
}
inline void Joints::set_values(int index, double value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Joints.values)
}
inline void Joints::_internal_add_values(double value) {
  _impl_.values_.Add(value);
}
inline void Joints::add_values(double value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:abb.egm.wrapper.Joints.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Joints::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Joints::values() const {
  // @@protoc_insertion_point(field_list:abb.egm.wrapper.Joints.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Joints::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Joints::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.wrapper.Joints.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// JointSpace

// optional .abb.egm.wrapper.Joints position = 1;
inline bool JointSpace::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool JointSpace::has_position() const {
  return _internal_has_position();
}
inline void JointSpace::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Joints& JointSpace::_internal_position() const {
  const ::abb::egm::wrapper::Joints* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(
      ::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& JointSpace::position() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.JointSpace.position)
  return _internal_position();
}
inline void JointSpace::unsafe_arena_set_allocated_position(
    ::abb::egm::wrapper::Joints* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.JointSpace.position)
}
inline ::abb::egm::wrapper::Joints* JointSpace::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Joints* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointSpace::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.JointSpace.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Joints* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointSpace::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::abb::egm::wrapper::Joints* JointSpace::mutable_position() {
  ::abb::egm::wrapper::Joints* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.JointSpace.position)
  return _msg;
}
inline void JointSpace::set_allocated_position(::abb::egm::wrapper::Joints* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.JointSpace.position)
}

// optional .abb.egm.wrapper.Joints velocity = 2;
inline bool JointSpace::_internal_has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline bool JointSpace::has_velocity() const {
  return _internal_has_velocity();
}
inline void JointSpace::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::Joints& JointSpace::_internal_velocity() const {
  const ::abb::egm::wrapper::Joints* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(
      ::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& JointSpace::velocity() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.JointSpace.velocity)
  return _internal_velocity();
}
inline void JointSpace::unsafe_arena_set_allocated_velocity(
    ::abb::egm::wrapper::Joints* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.JointSpace.velocity)
}
inline ::abb::egm::wrapper::Joints* JointSpace::release_velocity() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Joints* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointSpace::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.JointSpace.velocity)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Joints* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointSpace::_internal_mutable_velocity() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::abb::egm::wrapper::Joints* JointSpace::mutable_velocity() {
  ::abb::egm::wrapper::Joints* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.JointSpace.velocity)
  return _msg;
}
inline void JointSpace::set_allocated_velocity(::abb::egm::wrapper::Joints* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.JointSpace.velocity)
}

// -------------------------------------------------------------------

// Cartesian

// optional double x = 1;
inline bool Cartesian::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Cartesian::has_x() const {
  return _internal_has_x();
}
inline void Cartesian::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Cartesian::_internal_x() const {
  return _impl_.x_;
}
inline double Cartesian::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.x)
  return _internal_x();
}
inline void Cartesian::_internal_set_x(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void Cartesian::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.x)
}

// optional double y = 2;
inline bool Cartesian::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Cartesian::has_y() const {
  return _internal_has_y();
}
inline void Cartesian::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Cartesian::_internal_y() const {
  return _impl_.y_;
}
inline double Cartesian::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.y)
  return _internal_y();
}
inline void Cartesian::_internal_set_y(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void Cartesian::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.y)
}

// optional double z = 3;
inline bool Cartesian::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Cartesian::has_z() const {
  return _internal_has_z();
}
inline void Cartesian::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Cartesian::_internal_z() const {
  return _impl_.z_;
}
inline double Cartesian::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.z)
  return _internal_z();
}
inline void Cartesian::_internal_set_z(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void Cartesian::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.z)
}

// -------------------------------------------------------------------

// Euler

// optional double x = 1;
inline bool Euler::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Euler::has_x() const {
  return _internal_has_x();
}
inline void Euler::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Euler::_internal_x() const {
  return _impl_.x_;
}
inline double Euler::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.x)
  return _internal_x();
}
inline void Euler::_internal_set_x(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void Euler::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.x)
}

// optional double y = 2;
inline bool Euler::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Euler::has_y() const {
  return _internal_has_y();
}
inline void Euler::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Euler::_internal_y() const {
  return _impl_.y_;
}
inline double Euler::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.y)
  return _internal_y();
}
inline void Euler::_internal_set_y(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void Euler::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.y)
}

// optional double z = 3;
inline bool Euler::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Euler::has_z() const {
  return _internal_has_z();
}
inline void Euler::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Euler::_internal_z() const {
  return _impl_.z_;
}
inline double Euler::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.z)
  return _internal_z();
}
inline void Euler::_internal_set_z(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void Euler::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.z)
}

// -------------------------------------------------------------------

// Quaternion

// optional double u0 = 1;
inline bool Quaternion::_internal_has_u0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Quaternion::has_u0() const {
  return _internal_has_u0();
}
inline void Quaternion::clear_u0() {
  _impl_.u0_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Quaternion::_internal_u0() const {
  return _impl_.u0_;
}
inline double Quaternion::u0() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u0)
  return _internal_u0();
}
inline void Quaternion::_internal_set_u0(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.u0_ = value;
}
inline void Quaternion::set_u0(double value) {
  _internal_set_u0(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u0)
}

// optional double u1 = 2;
inline bool Quaternion::_internal_has_u1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Quaternion::has_u1() const {
  return _internal_has_u1();
}
inline void Quaternion::clear_u1() {
  _impl_.u1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Quaternion::_internal_u1() const {
  return _impl_.u1_;
}
inline double Quaternion::u1() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u1)
  return _internal_u1();
}
inline void Quaternion::_internal_set_u1(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.u1_ = value;
}
inline void Quaternion::set_u1(double value) {
  _internal_set_u1(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u1)
}

// optional double u2 = 3;
inline bool Quaternion::_internal_has_u2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Quaternion::has_u2() const {
  return _internal_has_u2();
}
inline void Quaternion::clear_u2() {
  _impl_.u2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Quaternion::_internal_u2() const {
  return _impl_.u2_;
}
inline double Quaternion::u2() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u2)
  return _internal_u2();
}
inline void Quaternion::_internal_set_u2(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.u2_ = value;
}
inline void Quaternion::set_u2(double value) {
  _internal_set_u2(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u2)
}

// optional double u3 = 4;
inline bool Quaternion::_internal_has_u3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Quaternion::has_u3() const {
  return _internal_has_u3();
}
inline void Quaternion::clear_u3() {
  _impl_.u3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double Quaternion::_internal_u3() const {
  return _impl_.u3_;
}
inline double Quaternion::u3() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u3)
  return _internal_u3();
}
inline void Quaternion::_internal_set_u3(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.u3_ = value;
}
inline void Quaternion::set_u3(double value) {
  _internal_set_u3(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u3)
}

// -------------------------------------------------------------------

// CartesianPose

// optional .abb.egm.wrapper.Cartesian position = 1;
inline bool CartesianPose::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool CartesianPose::has_position() const {
  return _internal_has_position();
}
inline void CartesianPose::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Cartesian& CartesianPose::_internal_position() const {
  const ::abb::egm::wrapper::Cartesian* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Cartesian&>(
      ::abb::egm::wrapper::_Cartesian_default_instance_);
}
inline const ::abb::egm::wrapper::Cartesian& CartesianPose::position() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.position)
  return _internal_position();
}
inline void CartesianPose::unsafe_arena_set_allocated_position(
    ::abb::egm::wrapper::Cartesian* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianPose.position)
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Cartesian* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianPose.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Cartesian* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::mutable_position() {
  ::abb::egm::wrapper::Cartesian* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.position)
  return _msg;
}
inline void CartesianPose::set_allocated_position(::abb::egm::wrapper::Cartesian* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.position)
}

// optional .abb.egm.wrapper.Euler euler = 2;
inline bool CartesianPose::_internal_has_euler() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.euler_ != nullptr);
  return value;
}
inline bool CartesianPose::has_euler() const {
  return _internal_has_euler();
}
inline void CartesianPose::clear_euler() {
  if (_impl_.euler_ != nullptr) _impl_.euler_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::Euler& CartesianPose::_internal_euler() const {
  const ::abb::egm::wrapper::Euler* p = _impl_.euler_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Euler&>(
      ::abb::egm::wrapper::_Euler_default_instance_);
}
inline const ::abb::egm::wrapper::Euler& CartesianPose::euler() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.euler)
  return _internal_euler();
}
inline void CartesianPose::unsafe_arena_set_allocated_euler(
    ::abb::egm::wrapper::Euler* euler) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.euler_);
  }
  _impl_.euler_ = euler;
  if (euler) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianPose.euler)
}
inline ::abb::egm::wrapper::Euler* CartesianPose::release_euler() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Euler* temp = _impl_.euler_;
  _impl_.euler_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Euler* CartesianPose::unsafe_arena_release_euler() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianPose.euler)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Euler* temp = _impl_.euler_;
  _impl_.euler_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Euler* CartesianPose::_internal_mutable_euler() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.euler_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Euler>(GetArenaForAllocation());
    _impl_.euler_ = p;
  }
  return _impl_.euler_;
}
inline ::abb::egm::wrapper::Euler* CartesianPose::mutable_euler() {
  ::abb::egm::wrapper::Euler* _msg = _internal_mutable_euler();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.euler)
  return _msg;
}
inline void CartesianPose::set_allocated_euler(::abb::egm::wrapper::Euler* euler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.euler_;
  }
  if (euler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(euler);
    if (message_arena != submessage_arena) {
      euler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, euler, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.euler_ = euler;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.euler)
}

// optional .abb.egm.wrapper.Quaternion quaternion = 3;
inline bool CartesianPose::_internal_has_quaternion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quaternion_ != nullptr);
  return value;
}
inline bool CartesianPose::has_quaternion() const {
  return _internal_has_quaternion();
}
inline void CartesianPose::clear_quaternion() {
  if (_impl_.quaternion_ != nullptr) _impl_.quaternion_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::Quaternion& CartesianPose::_internal_quaternion() const {
  const ::abb::egm::wrapper::Quaternion* p = _impl_.quaternion_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Quaternion&>(
      ::abb::egm::wrapper::_Quaternion_default_instance_);
}
inline const ::abb::egm::wrapper::Quaternion& CartesianPose::quaternion() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.quaternion)
  return _internal_quaternion();
}
inline void CartesianPose::unsafe_arena_set_allocated_quaternion(
    ::abb::egm::wrapper::Quaternion* quaternion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quaternion_);
  }
  _impl_.quaternion_ = quaternion;
  if (quaternion) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianPose.quaternion)
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::release_quaternion() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Quaternion* temp = _impl_.quaternion_;
  _impl_.quaternion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::unsafe_arena_release_quaternion() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianPose.quaternion)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Quaternion* temp = _impl_.quaternion_;
  _impl_.quaternion_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::_internal_mutable_quaternion() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.quaternion_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Quaternion>(GetArenaForAllocation());
    _impl_.quaternion_ = p;
  }
  return _impl_.quaternion_;
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::mutable_quaternion() {
  ::abb::egm::wrapper::Quaternion* _msg = _internal_mutable_quaternion();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.quaternion)
  return _msg;
}
inline void CartesianPose::set_allocated_quaternion(::abb::egm::wrapper::Quaternion* quaternion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quaternion_;
  }
  if (quaternion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quaternion);
    if (message_arena != submessage_arena) {
      quaternion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quaternion, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.quaternion_ = quaternion;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.quaternion)
}

// -------------------------------------------------------------------

// CartesianVelocity

// optional .abb.egm.wrapper.Cartesian linear = 1;
inline bool CartesianVelocity::_internal_has_linear() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_ != nullptr);
  return value;
}
inline bool CartesianVelocity::has_linear() const {
  return _internal_has_linear();
}
inline void CartesianVelocity::clear_linear() {
  if (_impl_.linear_ != nullptr) _impl_.linear_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Cartesian& CartesianVelocity::_internal_linear() const {
  const ::abb::egm::wrapper::Cartesian* p = _impl_.linear_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Cartesian&>(
      ::abb::egm::wrapper::_Cartesian_default_instance_);
}
inline const ::abb::egm::wrapper::Cartesian& CartesianVelocity::linear() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianVelocity.linear)
  return _internal_linear();
}
inline void CartesianVelocity::unsafe_arena_set_allocated_linear(
    ::abb::egm::wrapper::Cartesian* linear) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_);
  }
  _impl_.linear_ = linear;
  if (linear) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianVelocity.linear)
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::release_linear() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Cartesian* temp = _impl_.linear_;
  _impl_.linear_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianVelocity.linear)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Cartesian* temp = _impl_.linear_;
  _impl_.linear_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::_internal_mutable_linear() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(GetArenaForAllocation());
    _impl_.linear_ = p;
  }
  return _impl_.linear_;
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::mutable_linear() {
  ::abb::egm::wrapper::Cartesian* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianVelocity.linear)
  return _msg;
}
inline void CartesianVelocity::set_allocated_linear(::abb::egm::wrapper::Cartesian* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_;
  }
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.linear_ = linear;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianVelocity.linear)
}

// optional .abb.egm.wrapper.Euler angular = 2;
inline bool CartesianVelocity::_internal_has_angular() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.angular_ != nullptr);
  return value;
}
inline bool CartesianVelocity::has_angular() const {
  return _internal_has_angular();
}
inline void CartesianVelocity::clear_angular() {
  if (_impl_.angular_ != nullptr) _impl_.angular_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::Euler& CartesianVelocity::_internal_angular() const {
  const ::abb::egm::wrapper::Euler* p = _impl_.angular_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Euler&>(
      ::abb::egm::wrapper::_Euler_default_instance_);
}
inline const ::abb::egm::wrapper::Euler& CartesianVelocity::angular() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianVelocity.angular)
  return _internal_angular();
}
inline void CartesianVelocity::unsafe_arena_set_allocated_angular(
    ::abb::egm::wrapper::Euler* angular) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angular_);
  }
  _impl_.angular_ = angular;
  if (angular) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianVelocity.angular)
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::release_angular() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Euler* temp = _impl_.angular_;
  _impl_.angular_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::unsafe_arena_release_angular() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianVelocity.angular)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Euler* temp = _impl_.angular_;
  _impl_.angular_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::_internal_mutable_angular() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.angular_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Euler>(GetArenaForAllocation());
    _impl_.angular_ = p;
  }
  return _impl_.angular_;
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::mutable_angular() {
  ::abb::egm::wrapper::Euler* _msg = _internal_mutable_angular();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianVelocity.angular)
  return _msg;
}
inline void CartesianVelocity::set_allocated_angular(::abb::egm::wrapper::Euler* angular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.angular_;
  }
  if (angular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(angular);
    if (message_arena != submessage_arena) {
      angular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.angular_ = angular;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianVelocity.angular)
}

// -------------------------------------------------------------------

// CartesianSpace

// optional .abb.egm.wrapper.CartesianPose pose = 1;
inline bool CartesianSpace::_internal_has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline bool CartesianSpace::has_pose() const {
  return _internal_has_pose();
}
inline void CartesianSpace::clear_pose() {
  if (_impl_.pose_ != nullptr) _impl_.pose_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::CartesianPose& CartesianSpace::_internal_pose() const {
  const ::abb::egm::wrapper::CartesianPose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::CartesianPose&>(
      ::abb::egm::wrapper::_CartesianPose_default_instance_);
}
inline const ::abb::egm::wrapper::CartesianPose& CartesianSpace::pose() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianSpace.pose)
  return _internal_pose();
}
inline void CartesianSpace::unsafe_arena_set_allocated_pose(
    ::abb::egm::wrapper::CartesianPose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = pose;
  if (pose) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianSpace.pose)
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::release_pose() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::CartesianPose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianSpace.pose)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::CartesianPose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::_internal_mutable_pose() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianPose>(GetArenaForAllocation());
    _impl_.pose_ = p;
  }
  return _impl_.pose_;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::mutable_pose() {
  ::abb::egm::wrapper::CartesianPose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianSpace.pose)
  return _msg;
}
inline void CartesianSpace::set_allocated_pose(::abb::egm::wrapper::CartesianPose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianSpace.pose)
}

// optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
inline bool CartesianSpace::_internal_has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline bool CartesianSpace::has_velocity() const {
  return _internal_has_velocity();
}
inline void CartesianSpace::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::CartesianVelocity& CartesianSpace::_internal_velocity() const {
  const ::abb::egm::wrapper::CartesianVelocity* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::CartesianVelocity&>(
      ::abb::egm::wrapper::_CartesianVelocity_default_instance_);
}
inline const ::abb::egm::wrapper::CartesianVelocity& CartesianSpace::velocity() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianSpace.velocity)
  return _internal_velocity();
}
inline void CartesianSpace::unsafe_arena_set_allocated_velocity(
    ::abb::egm::wrapper::CartesianVelocity* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianSpace.velocity)
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::release_velocity() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianVelocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianSpace.velocity)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianVelocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::_internal_mutable_velocity() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianVelocity>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::mutable_velocity() {
  ::abb::egm::wrapper::CartesianVelocity* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianSpace.velocity)
  return _msg;
}
inline void CartesianSpace::set_allocated_velocity(::abb::egm::wrapper::CartesianVelocity* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianSpace.velocity)
}

// -------------------------------------------------------------------

// Robot

// optional .abb.egm.wrapper.JointSpace joints = 1;
inline bool Robot::_internal_has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline bool Robot::has_joints() const {
  return _internal_has_joints();
}
inline void Robot::clear_joints() {
  if (_impl_.joints_ != nullptr) _impl_.joints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::JointSpace& Robot::_internal_joints() const {
  const ::abb::egm::wrapper::JointSpace* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::JointSpace&>(
      ::abb::egm::wrapper::_JointSpace_default_instance_);
}
inline const ::abb::egm::wrapper::JointSpace& Robot::joints() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Robot.joints)
  return _internal_joints();
}
inline void Robot::unsafe_arena_set_allocated_joints(
    ::abb::egm::wrapper::JointSpace* joints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = joints;
  if (joints) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Robot.joints)
}
inline ::abb::egm::wrapper::JointSpace* Robot::release_joints() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::JointSpace* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::JointSpace* Robot::unsafe_arena_release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Robot.joints)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::JointSpace* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::JointSpace* Robot::_internal_mutable_joints() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::JointSpace>(GetArenaForAllocation());
    _impl_.joints_ = p;
  }
  return _impl_.joints_;
}
inline ::abb::egm::wrapper::JointSpace* Robot::mutable_joints() {
  ::abb::egm::wrapper::JointSpace* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Robot.joints)
  return _msg;
}
inline void Robot::set_allocated_joints(::abb::egm::wrapper::JointSpace* joints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.joints_;
  }
  if (joints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(joints);
    if (message_arena != submessage_arena) {
      joints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Robot.joints)
}

// optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
inline bool Robot::_internal_has_cartesian() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cartesian_ != nullptr);
  return value;
}
inline bool Robot::has_cartesian() const {
  return _internal_has_cartesian();
}
inline void Robot::clear_cartesian() {
  if (_impl_.cartesian_ != nullptr) _impl_.cartesian_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::CartesianSpace& Robot::_internal_cartesian() const {
  const ::abb::egm::wrapper::CartesianSpace* p = _impl_.cartesian_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::CartesianSpace&>(
      ::abb::egm::wrapper::_CartesianSpace_default_instance_);
}
inline const ::abb::egm::wrapper::CartesianSpace& Robot::cartesian() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Robot.cartesian)
  return _internal_cartesian();
}
inline void Robot::unsafe_arena_set_allocated_cartesian(
    ::abb::egm::wrapper::CartesianSpace* cartesian) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cartesian_);
  }
  _impl_.cartesian_ = cartesian;
  if (cartesian) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Robot.cartesian)
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::release_cartesian() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianSpace* temp = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::unsafe_arena_release_cartesian() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Robot.cartesian)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianSpace* temp = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::_internal_mutable_cartesian() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cartesian_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianSpace>(GetArenaForAllocation());
    _impl_.cartesian_ = p;
  }
  return _impl_.cartesian_;
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::mutable_cartesian() {
  ::abb::egm::wrapper::CartesianSpace* _msg = _internal_mutable_cartesian();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Robot.cartesian)
  return _msg;
}
inline void Robot::set_allocated_cartesian(::abb::egm::wrapper::CartesianSpace* cartesian) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cartesian_;
  }
  if (cartesian) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cartesian);
    if (message_arena != submessage_arena) {
      cartesian = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cartesian, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cartesian_ = cartesian;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Robot.cartesian)
}

// -------------------------------------------------------------------

// External

// optional .abb.egm.wrapper.JointSpace joints = 1;
inline bool External::_internal_has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline bool External::has_joints() const {
  return _internal_has_joints();
}
inline void External::clear_joints() {
  if (_impl_.joints_ != nullptr) _impl_.joints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::JointSpace& External::_internal_joints() const {
  const ::abb::egm::wrapper::JointSpace* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::JointSpace&>(
      ::abb::egm::wrapper::_JointSpace_default_instance_);
}
inline const ::abb::egm::wrapper::JointSpace& External::joints() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.External.joints)
  return _internal_joints();
}
inline void External::unsafe_arena_set_allocated_joints(
    ::abb::egm::wrapper::JointSpace* joints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = joints;
  if (joints) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.External.joints)
}
inline ::abb::egm::wrapper::JointSpace* External::release_joints() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::JointSpace* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::JointSpace* External::unsafe_arena_release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.External.joints)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::JointSpace* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::JointSpace* External::_internal_mutable_joints() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::JointSpace>(GetArenaForAllocation());
    _impl_.joints_ = p;
  }
  return _impl_.joints_;
}
inline ::abb::egm::wrapper::JointSpace* External::mutable_joints() {
  ::abb::egm::wrapper::JointSpace* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.External.joints)
  return _msg;
}
inline void External::set_allocated_joints(::abb::egm::wrapper::JointSpace* joints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.joints_;
  }
  if (joints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(joints);
    if (message_arena != submessage_arena) {
      joints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.External.joints)
}

// -------------------------------------------------------------------

// Feedback

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Feedback::_internal_has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline bool Feedback::has_robot() const {
  return _internal_has_robot();
}
inline void Feedback::clear_robot() {
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Robot& Feedback::_internal_robot() const {
  const ::abb::egm::wrapper::Robot* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Robot&>(
      ::abb::egm::wrapper::_Robot_default_instance_);
}
inline const ::abb::egm::wrapper::Robot& Feedback::robot() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.robot)
  return _internal_robot();
}
inline void Feedback::unsafe_arena_set_allocated_robot(
    ::abb::egm::wrapper::Robot* robot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = robot;
  if (robot) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Feedback.robot)
}
inline ::abb::egm::wrapper::Robot* Feedback::release_robot() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Robot* Feedback::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Feedback.robot)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Robot* Feedback::_internal_mutable_robot() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Robot>(GetArenaForAllocation());
    _impl_.robot_ = p;
  }
  return _impl_.robot_;
}
inline ::abb::egm::wrapper::Robot* Feedback::mutable_robot() {
  ::abb::egm::wrapper::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.robot)
  return _msg;
}
inline void Feedback::set_allocated_robot(::abb::egm::wrapper::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Feedback::_internal_has_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_ != nullptr);
  return value;
}
inline bool Feedback::has_external() const {
  return _internal_has_external();
}
inline void Feedback::clear_external() {
  if (_impl_.external_ != nullptr) _impl_.external_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::External& Feedback::_internal_external() const {
  const ::abb::egm::wrapper::External* p = _impl_.external_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::External&>(
      ::abb::egm::wrapper::_External_default_instance_);
}
inline const ::abb::egm::wrapper::External& Feedback::external() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.external)
  return _internal_external();
}
inline void Feedback::unsafe_arena_set_allocated_external(
    ::abb::egm::wrapper::External* external) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_);
  }
  _impl_.external_ = external;
  if (external) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Feedback.external)
}
inline ::abb::egm::wrapper::External* Feedback::release_external() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = _impl_.external_;
  _impl_.external_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::External* Feedback::unsafe_arena_release_external() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Feedback.external)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = _impl_.external_;
  _impl_.external_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::External* Feedback::_internal_mutable_external() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.external_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::External>(GetArenaForAllocation());
    _impl_.external_ = p;
  }
  return _impl_.external_;
}
inline ::abb::egm::wrapper::External* Feedback::mutable_external() {
  ::abb::egm::wrapper::External* _msg = _internal_mutable_external();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.external)
  return _msg;
}
inline void Feedback::set_allocated_external(::abb::egm::wrapper::External* external) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_;
  }
  if (external) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external);
    if (message_arena != submessage_arena) {
      external = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.external_ = external;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.external)
}

// optional .abb.egm.wrapper.Clock time = 3;
inline bool Feedback::_internal_has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline bool Feedback::has_time() const {
  return _internal_has_time();
}
inline void Feedback::clear_time() {
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::Clock& Feedback::_internal_time() const {
  const ::abb::egm::wrapper::Clock* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Clock&>(
      ::abb::egm::wrapper::_Clock_default_instance_);
}
inline const ::abb::egm::wrapper::Clock& Feedback::time() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.time)
  return _internal_time();
}
inline void Feedback::unsafe_arena_set_allocated_time(
    ::abb::egm::wrapper::Clock* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Feedback.time)
}
inline ::abb::egm::wrapper::Clock* Feedback::release_time() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Clock* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Clock* Feedback::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Feedback.time)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Clock* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Clock* Feedback::_internal_mutable_time() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Clock>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::abb::egm::wrapper::Clock* Feedback::mutable_time() {
  ::abb::egm::wrapper::Clock* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.time)
  return _msg;
}
inline void Feedback::set_allocated_time(::abb::egm::wrapper::Clock* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.time)
}

// -------------------------------------------------------------------

// Planned

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Planned::_internal_has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline bool Planned::has_robot() const {
  return _internal_has_robot();
}
inline void Planned::clear_robot() {
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Robot& Planned::_internal_robot() const {
  const ::abb::egm::wrapper::Robot* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Robot&>(
      ::abb::egm::wrapper::_Robot_default_instance_);
}
inline const ::abb::egm::wrapper::Robot& Planned::robot() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.robot)
  return _internal_robot();
}
inline void Planned::unsafe_arena_set_allocated_robot(
    ::abb::egm::wrapper::Robot* robot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = robot;
  if (robot) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Planned.robot)
}
inline ::abb::egm::wrapper::Robot* Planned::release_robot() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Robot* Planned::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Planned.robot)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Robot* Planned::_internal_mutable_robot() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Robot>(GetArenaForAllocation());
    _impl_.robot_ = p;
  }
  return _impl_.robot_;
}
inline ::abb::egm::wrapper::Robot* Planned::mutable_robot() {
  ::abb::egm::wrapper::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.robot)
  return _msg;
}
inline void Planned::set_allocated_robot(::abb::egm::wrapper::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Planned::_internal_has_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_ != nullptr);
  return value;
}
inline bool Planned::has_external() const {
  return _internal_has_external();
}
inline void Planned::clear_external() {
  if (_impl_.external_ != nullptr) _impl_.external_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::External& Planned::_internal_external() const {
  const ::abb::egm::wrapper::External* p = _impl_.external_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::External&>(
      ::abb::egm::wrapper::_External_default_instance_);
}
inline const ::abb::egm::wrapper::External& Planned::external() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.external)
  return _internal_external();
}
inline void Planned::unsafe_arena_set_allocated_external(
    ::abb::egm::wrapper::External* external) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_);
  }
  _impl_.external_ = external;
  if (external) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Planned.external)
}
inline ::abb::egm::wrapper::External* Planned::release_external() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = _impl_.external_;
  _impl_.external_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::External* Planned::unsafe_arena_release_external() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Planned.external)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = _impl_.external_;
  _impl_.external_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::External* Planned::_internal_mutable_external() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.external_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::External>(GetArenaForAllocation());
    _impl_.external_ = p;
  }
  return _impl_.external_;
}
inline ::abb::egm::wrapper::External* Planned::mutable_external() {
  ::abb::egm::wrapper::External* _msg = _internal_mutable_external();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.external)
  return _msg;
}
inline void Planned::set_allocated_external(::abb::egm::wrapper::External* external) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_;
  }
  if (external) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external);
    if (message_arena != submessage_arena) {
      external = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.external_ = external;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.external)
}

// optional .abb.egm.wrapper.Clock time = 3;
inline bool Planned::_internal_has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline bool Planned::has_time() const {
  return _internal_has_time();
}
inline void Planned::clear_time() {
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::Clock& Planned::_internal_time() const {
  const ::abb::egm::wrapper::Clock* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Clock&>(
      ::abb::egm::wrapper::_Clock_default_instance_);
}
inline const ::abb::egm::wrapper::Clock& Planned::time() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.time)
  return _internal_time();
}
inline void Planned::unsafe_arena_set_allocated_time(
    ::abb::egm::wrapper::Clock* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Planned.time)
}
inline ::abb::egm::wrapper::Clock* Planned::release_time() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Clock* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Clock* Planned::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Planned.time)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Clock* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Clock* Planned::_internal_mutable_time() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Clock>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::abb::egm::wrapper::Clock* Planned::mutable_time() {
  ::abb::egm::wrapper::Clock* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.time)
  return _msg;
}
inline void Planned::set_allocated_time(::abb::egm::wrapper::Clock* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.time)
}

// -------------------------------------------------------------------

// Input

// optional .abb.egm.wrapper.Header header = 1;
inline bool Input::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline bool Input::has_header() const {
  return _internal_has_header();
}
inline void Input::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Header& Input::_internal_header() const {
  const ::abb::egm::wrapper::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Header&>(
      ::abb::egm::wrapper::_Header_default_instance_);
}
inline const ::abb::egm::wrapper::Header& Input::header() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.header)
  return _internal_header();
}
inline void Input::unsafe_arena_set_allocated_header(
    ::abb::egm::wrapper::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Input.header)
}
inline ::abb::egm::wrapper::Header* Input::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Header* Input::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Header* Input::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::abb::egm::wrapper::Header* Input::mutable_header() {
  ::abb::egm::wrapper::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.header)
  return _msg;
}
inline void Input::set_allocated_header(::abb::egm::wrapper::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.header)
}

// optional .abb.egm.wrapper.Feedback feedback = 2;
inline bool Input::_internal_has_feedback() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.feedback_ != nullptr);
  return value;
}
inline bool Input::has_feedback() const {
  return _internal_has_feedback();
}
inline void Input::clear_feedback() {
  if (_impl_.feedback_ != nullptr) _impl_.feedback_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::Feedback& Input::_internal_feedback() const {
  const ::abb::egm::wrapper::Feedback* p = _impl_.feedback_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Feedback&>(
      ::abb::egm::wrapper::_Feedback_default_instance_);
}
inline const ::abb::egm::wrapper::Feedback& Input::feedback() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.feedback)
  return _internal_feedback();
}
inline void Input::unsafe_arena_set_allocated_feedback(
    ::abb::egm::wrapper::Feedback* feedback) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feedback_);
  }
  _impl_.feedback_ = feedback;
  if (feedback) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Input.feedback)
}
inline ::abb::egm::wrapper::Feedback* Input::release_feedback() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Feedback* temp = _impl_.feedback_;
  _impl_.feedback_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Feedback* Input::unsafe_arena_release_feedback() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.feedback)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Feedback* temp = _impl_.feedback_;
  _impl_.feedback_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Feedback* Input::_internal_mutable_feedback() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Feedback>(GetArenaForAllocation());
    _impl_.feedback_ = p;
  }
  return _impl_.feedback_;
}
inline ::abb::egm::wrapper::Feedback* Input::mutable_feedback() {
  ::abb::egm::wrapper::Feedback* _msg = _internal_mutable_feedback();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.feedback)
  return _msg;
}
inline void Input::set_allocated_feedback(::abb::egm::wrapper::Feedback* feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.feedback_;
  }
  if (feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feedback);
    if (message_arena != submessage_arena) {
      feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feedback, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.feedback_ = feedback;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.feedback)
}

// optional .abb.egm.wrapper.Planned planned = 3;
inline bool Input::_internal_has_planned() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.planned_ != nullptr);
  return value;
}
inline bool Input::has_planned() const {
  return _internal_has_planned();
}
inline void Input::clear_planned() {
  if (_impl_.planned_ != nullptr) _impl_.planned_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::Planned& Input::_internal_planned() const {
  const ::abb::egm::wrapper::Planned* p = _impl_.planned_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Planned&>(
      ::abb::egm::wrapper::_Planned_default_instance_);
}
inline const ::abb::egm::wrapper::Planned& Input::planned() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.planned)
  return _internal_planned();
}
inline void Input::unsafe_arena_set_allocated_planned(
    ::abb::egm::wrapper::Planned* planned) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.planned_);
  }
  _impl_.planned_ = planned;
  if (planned) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Input.planned)
}
inline ::abb::egm::wrapper::Planned* Input::release_planned() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Planned* temp = _impl_.planned_;
  _impl_.planned_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Planned* Input::unsafe_arena_release_planned() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.planned)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Planned* temp = _impl_.planned_;
  _impl_.planned_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Planned* Input::_internal_mutable_planned() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.planned_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Planned>(GetArenaForAllocation());
    _impl_.planned_ = p;
  }
  return _impl_.planned_;
}
inline ::abb::egm::wrapper::Planned* Input::mutable_planned() {
  ::abb::egm::wrapper::Planned* _msg = _internal_mutable_planned();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.planned)
  return _msg;
}
inline void Input::set_allocated_planned(::abb::egm::wrapper::Planned* planned) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.planned_;
  }
  if (planned) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(planned);
    if (message_arena != submessage_arena) {
      planned = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planned, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.planned_ = planned;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.planned)
}

// optional .abb.egm.wrapper.Status status = 4;
inline bool Input::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline bool Input::has_status() const {
  return _internal_has_status();
}
inline void Input::clear_status() {
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::wrapper::Status& Input::_internal_status() const {
  const ::abb::egm::wrapper::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Status&>(
      ::abb::egm::wrapper::_Status_default_instance_);
}
inline const ::abb::egm::wrapper::Status& Input::status() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.status)
  return _internal_status();
}
inline void Input::unsafe_arena_set_allocated_status(
    ::abb::egm::wrapper::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Input.status)
}
inline ::abb::egm::wrapper::Status* Input::release_status() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::wrapper::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Status* Input::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.status)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::wrapper::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Status* Input::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::abb::egm::wrapper::Status* Input::mutable_status() {
  ::abb::egm::wrapper::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.status)
  return _msg;
}
inline void Input::set_allocated_status(::abb::egm::wrapper::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.status)
}

// -------------------------------------------------------------------

// Output

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Output::_internal_has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline bool Output::has_robot() const {
  return _internal_has_robot();
}
inline void Output::clear_robot() {
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Robot& Output::_internal_robot() const {
  const ::abb::egm::wrapper::Robot* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Robot&>(
      ::abb::egm::wrapper::_Robot_default_instance_);
}
inline const ::abb::egm::wrapper::Robot& Output::robot() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Output.robot)
  return _internal_robot();
}
inline void Output::unsafe_arena_set_allocated_robot(
    ::abb::egm::wrapper::Robot* robot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = robot;
  if (robot) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Output.robot)
}
inline ::abb::egm::wrapper::Robot* Output::release_robot() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::Robot* Output::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Output.robot)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Robot* Output::_internal_mutable_robot() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Robot>(GetArenaForAllocation());
    _impl_.robot_ = p;
  }
  return _impl_.robot_;
}
inline ::abb::egm::wrapper::Robot* Output::mutable_robot() {
  ::abb::egm::wrapper::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Output.robot)
  return _msg;
}
inline void Output::set_allocated_robot(::abb::egm::wrapper::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Output.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Output::_internal_has_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_ != nullptr);
  return value;
}
inline bool Output::has_external() const {
  return _internal_has_external();
}
inline void Output::clear_external() {
  if (_impl_.external_ != nullptr) _impl_.external_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::External& Output::_internal_external() const {
  const ::abb::egm::wrapper::External* p = _impl_.external_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::External&>(
      ::abb::egm::wrapper::_External_default_instance_);
}
inline const ::abb::egm::wrapper::External& Output::external() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Output.external)
  return _internal_external();
}
inline void Output::unsafe_arena_set_allocated_external(
    ::abb::egm::wrapper::External* external) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_);
  }
  _impl_.external_ = external;
  if (external) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Output.external)
}
inline ::abb::egm::wrapper::External* Output::release_external() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = _impl_.external_;
  _impl_.external_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::wrapper::External* Output::unsafe_arena_release_external() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Output.external)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = _impl_.external_;
  _impl_.external_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::External* Output::_internal_mutable_external() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.external_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::External>(GetArenaForAllocation());
    _impl_.external_ = p;
  }
  return _impl_.external_;
}
inline ::abb::egm::wrapper::External* Output::mutable_external() {
  ::abb::egm::wrapper::External* _msg = _internal_mutable_external();
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Output.external)
  return _msg;
}
inline void Output::set_allocated_external(::abb::egm::wrapper::External* external) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_;
  }
  if (external) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external);
    if (message_arena != submessage_arena) {
      external = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.external_ = external;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Output.external)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace wrapper
}  // namespace egm
}  // namespace abb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::abb::egm::wrapper::Header_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Header_MessageType>() {
  return ::abb::egm::wrapper::Header_MessageType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Header_RWVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Header_RWVersion>() {
  return ::abb::egm::wrapper::Header_RWVersion_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Header_EGMVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Header_EGMVersion>() {
  return ::abb::egm::wrapper::Header_EGMVersion_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Status_EGMState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Status_EGMState>() {
  return ::abb::egm::wrapper::Status_EGMState_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Status_MotorState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Status_MotorState>() {
  return ::abb::egm::wrapper::Status_MotorState_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Status_RAPIDExecutionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Status_RAPIDExecutionState>() {
  return ::abb::egm::wrapper::Status_RAPIDExecutionState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_egm_5fwrapper_2eproto
