// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot_controller_description.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_robot_5fcontroller_5fdescription_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_robot_5fcontroller_5fdescription_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_robot_5fcontroller_5fdescription_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_robot_5fcontroller_5fdescription_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robot_5fcontroller_5fdescription_2eproto;
namespace abb {
namespace robot {
class AddInIndicators;
struct AddInIndicatorsDefaultTypeInternal;
extern AddInIndicatorsDefaultTypeInternal _AddInIndicators_default_instance_;
class Arm;
struct ArmDefaultTypeInternal;
extern ArmDefaultTypeInternal _Arm_default_instance_;
class Cartesian;
struct CartesianDefaultTypeInternal;
extern CartesianDefaultTypeInternal _Cartesian_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Joint;
struct JointDefaultTypeInternal;
extern JointDefaultTypeInternal _Joint_default_instance_;
class MechanicalUnit;
struct MechanicalUnitDefaultTypeInternal;
extern MechanicalUnitDefaultTypeInternal _MechanicalUnit_default_instance_;
class MechanicalUnitGroup;
struct MechanicalUnitGroupDefaultTypeInternal;
extern MechanicalUnitGroupDefaultTypeInternal _MechanicalUnitGroup_default_instance_;
class OptionIndicators;
struct OptionIndicatorsDefaultTypeInternal;
extern OptionIndicatorsDefaultTypeInternal _OptionIndicators_default_instance_;
class Pose;
struct PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class RAPIDModule;
struct RAPIDModuleDefaultTypeInternal;
extern RAPIDModuleDefaultTypeInternal _RAPIDModule_default_instance_;
class RAPIDTask;
struct RAPIDTaskDefaultTypeInternal;
extern RAPIDTaskDefaultTypeInternal _RAPIDTask_default_instance_;
class Robot;
struct RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class RobotControllerDescription;
struct RobotControllerDescriptionDefaultTypeInternal;
extern RobotControllerDescriptionDefaultTypeInternal _RobotControllerDescription_default_instance_;
class RobotIndicators;
struct RobotIndicatorsDefaultTypeInternal;
extern RobotIndicatorsDefaultTypeInternal _RobotIndicators_default_instance_;
class RobotWareVersion;
struct RobotWareVersionDefaultTypeInternal;
extern RobotWareVersionDefaultTypeInternal _RobotWareVersion_default_instance_;
class Single;
struct SingleDefaultTypeInternal;
extern SingleDefaultTypeInternal _Single_default_instance_;
class StandardizedJoint;
struct StandardizedJointDefaultTypeInternal;
extern StandardizedJointDefaultTypeInternal _StandardizedJoint_default_instance_;
class SystemIndicators;
struct SystemIndicatorsDefaultTypeInternal;
extern SystemIndicatorsDefaultTypeInternal _SystemIndicators_default_instance_;
class Transmission;
struct TransmissionDefaultTypeInternal;
extern TransmissionDefaultTypeInternal _Transmission_default_instance_;
}  // namespace robot
}  // namespace abb
PROTOBUF_NAMESPACE_OPEN
template<> ::abb::robot::AddInIndicators* Arena::CreateMaybeMessage<::abb::robot::AddInIndicators>(Arena*);
template<> ::abb::robot::Arm* Arena::CreateMaybeMessage<::abb::robot::Arm>(Arena*);
template<> ::abb::robot::Cartesian* Arena::CreateMaybeMessage<::abb::robot::Cartesian>(Arena*);
template<> ::abb::robot::Header* Arena::CreateMaybeMessage<::abb::robot::Header>(Arena*);
template<> ::abb::robot::Joint* Arena::CreateMaybeMessage<::abb::robot::Joint>(Arena*);
template<> ::abb::robot::MechanicalUnit* Arena::CreateMaybeMessage<::abb::robot::MechanicalUnit>(Arena*);
template<> ::abb::robot::MechanicalUnitGroup* Arena::CreateMaybeMessage<::abb::robot::MechanicalUnitGroup>(Arena*);
template<> ::abb::robot::OptionIndicators* Arena::CreateMaybeMessage<::abb::robot::OptionIndicators>(Arena*);
template<> ::abb::robot::Pose* Arena::CreateMaybeMessage<::abb::robot::Pose>(Arena*);
template<> ::abb::robot::Quaternion* Arena::CreateMaybeMessage<::abb::robot::Quaternion>(Arena*);
template<> ::abb::robot::RAPIDModule* Arena::CreateMaybeMessage<::abb::robot::RAPIDModule>(Arena*);
template<> ::abb::robot::RAPIDTask* Arena::CreateMaybeMessage<::abb::robot::RAPIDTask>(Arena*);
template<> ::abb::robot::Robot* Arena::CreateMaybeMessage<::abb::robot::Robot>(Arena*);
template<> ::abb::robot::RobotControllerDescription* Arena::CreateMaybeMessage<::abb::robot::RobotControllerDescription>(Arena*);
template<> ::abb::robot::RobotIndicators* Arena::CreateMaybeMessage<::abb::robot::RobotIndicators>(Arena*);
template<> ::abb::robot::RobotWareVersion* Arena::CreateMaybeMessage<::abb::robot::RobotWareVersion>(Arena*);
template<> ::abb::robot::Single* Arena::CreateMaybeMessage<::abb::robot::Single>(Arena*);
template<> ::abb::robot::StandardizedJoint* Arena::CreateMaybeMessage<::abb::robot::StandardizedJoint>(Arena*);
template<> ::abb::robot::SystemIndicators* Arena::CreateMaybeMessage<::abb::robot::SystemIndicators>(Arena*);
template<> ::abb::robot::Transmission* Arena::CreateMaybeMessage<::abb::robot::Transmission>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace abb {
namespace robot {

enum MechanicalUnit_Type : int {
  MechanicalUnit_Type_UNDEFINED = 0,
  MechanicalUnit_Type_NONE = 1,
  MechanicalUnit_Type_TCP_ROBOT = 2,
  MechanicalUnit_Type_ROBOT = 3,
  MechanicalUnit_Type_SINGLE = 4
};
bool MechanicalUnit_Type_IsValid(int value);
constexpr MechanicalUnit_Type MechanicalUnit_Type_Type_MIN = MechanicalUnit_Type_UNDEFINED;
constexpr MechanicalUnit_Type MechanicalUnit_Type_Type_MAX = MechanicalUnit_Type_SINGLE;
constexpr int MechanicalUnit_Type_Type_ARRAYSIZE = MechanicalUnit_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MechanicalUnit_Type_descriptor();
template<typename T>
inline const std::string& MechanicalUnit_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MechanicalUnit_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MechanicalUnit_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MechanicalUnit_Type_descriptor(), enum_t_value);
}
inline bool MechanicalUnit_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MechanicalUnit_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MechanicalUnit_Type>(
    MechanicalUnit_Type_descriptor(), name, value);
}
enum MechanicalUnit_Mode : int {
  MechanicalUnit_Mode_DEACTIVATED = 0,
  MechanicalUnit_Mode_ACTIVATED = 1
};
bool MechanicalUnit_Mode_IsValid(int value);
constexpr MechanicalUnit_Mode MechanicalUnit_Mode_Mode_MIN = MechanicalUnit_Mode_DEACTIVATED;
constexpr MechanicalUnit_Mode MechanicalUnit_Mode_Mode_MAX = MechanicalUnit_Mode_ACTIVATED;
constexpr int MechanicalUnit_Mode_Mode_ARRAYSIZE = MechanicalUnit_Mode_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MechanicalUnit_Mode_descriptor();
template<typename T>
inline const std::string& MechanicalUnit_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MechanicalUnit_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MechanicalUnit_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MechanicalUnit_Mode_descriptor(), enum_t_value);
}
inline bool MechanicalUnit_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MechanicalUnit_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MechanicalUnit_Mode>(
    MechanicalUnit_Mode_descriptor(), name, value);
}
enum RAPIDTask_ExecutionState : int {
  RAPIDTask_ExecutionState_UNKNOWN = 1,
  RAPIDTask_ExecutionState_READY = 2,
  RAPIDTask_ExecutionState_STOPPED = 3,
  RAPIDTask_ExecutionState_STARTED = 4,
  RAPIDTask_ExecutionState_UNINITIALIZED = 5
};
bool RAPIDTask_ExecutionState_IsValid(int value);
constexpr RAPIDTask_ExecutionState RAPIDTask_ExecutionState_ExecutionState_MIN = RAPIDTask_ExecutionState_UNKNOWN;
constexpr RAPIDTask_ExecutionState RAPIDTask_ExecutionState_ExecutionState_MAX = RAPIDTask_ExecutionState_UNINITIALIZED;
constexpr int RAPIDTask_ExecutionState_ExecutionState_ARRAYSIZE = RAPIDTask_ExecutionState_ExecutionState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RAPIDTask_ExecutionState_descriptor();
template<typename T>
inline const std::string& RAPIDTask_ExecutionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RAPIDTask_ExecutionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RAPIDTask_ExecutionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RAPIDTask_ExecutionState_descriptor(), enum_t_value);
}
inline bool RAPIDTask_ExecutionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RAPIDTask_ExecutionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RAPIDTask_ExecutionState>(
    RAPIDTask_ExecutionState_descriptor(), name, value);
}
// ===================================================================

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit PROTOBUF_CONSTEXPR Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 6,
    kIpAddressFieldNumber = 1,
    kSystemNameFieldNumber = 4,
    kSystemTypeFieldNumber = 5,
    kRobotWareVersionFieldNumber = 3,
    kRwsPortNumberFieldNumber = 2,
  };
  // repeated string options = 6;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  const std::string& options(int index) const;
  std::string* mutable_options(int index);
  void set_options(int index, const std::string& value);
  void set_options(int index, std::string&& value);
  void set_options(int index, const char* value);
  void set_options(int index, const char* value, size_t size);
  std::string* add_options();
  void add_options(const std::string& value);
  void add_options(std::string&& value);
  void add_options(const char* value);
  void add_options(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& options() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_options();
  private:
  const std::string& _internal_options(int index) const;
  std::string* _internal_add_options();
  public:

  // optional string ip_address = 1;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // optional string system_name = 4;
  bool has_system_name() const;
  private:
  bool _internal_has_system_name() const;
  public:
  void clear_system_name();
  const std::string& system_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_system_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_system_name();
  PROTOBUF_NODISCARD std::string* release_system_name();
  void set_allocated_system_name(std::string* system_name);
  private:
  const std::string& _internal_system_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_name(const std::string& value);
  std::string* _internal_mutable_system_name();
  public:

  // optional string system_type = 5;
  bool has_system_type() const;
  private:
  bool _internal_has_system_type() const;
  public:
  void clear_system_type();
  const std::string& system_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_system_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_system_type();
  PROTOBUF_NODISCARD std::string* release_system_type();
  void set_allocated_system_type(std::string* system_type);
  private:
  const std::string& _internal_system_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_type(const std::string& value);
  std::string* _internal_mutable_system_type();
  public:

  // optional .abb.robot.RobotWareVersion robot_ware_version = 3;
  bool has_robot_ware_version() const;
  private:
  bool _internal_has_robot_ware_version() const;
  public:
  void clear_robot_ware_version();
  const ::abb::robot::RobotWareVersion& robot_ware_version() const;
  PROTOBUF_NODISCARD ::abb::robot::RobotWareVersion* release_robot_ware_version();
  ::abb::robot::RobotWareVersion* mutable_robot_ware_version();
  void set_allocated_robot_ware_version(::abb::robot::RobotWareVersion* robot_ware_version);
  private:
  const ::abb::robot::RobotWareVersion& _internal_robot_ware_version() const;
  ::abb::robot::RobotWareVersion* _internal_mutable_robot_ware_version();
  public:
  void unsafe_arena_set_allocated_robot_ware_version(
      ::abb::robot::RobotWareVersion* robot_ware_version);
  ::abb::robot::RobotWareVersion* unsafe_arena_release_robot_ware_version();

  // optional uint32 rws_port_number = 2;
  bool has_rws_port_number() const;
  private:
  bool _internal_has_rws_port_number() const;
  public:
  void clear_rws_port_number();
  uint32_t rws_port_number() const;
  void set_rws_port_number(uint32_t value);
  private:
  uint32_t _internal_rws_port_number() const;
  void _internal_set_rws_port_number(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_type_;
    ::abb::robot::RobotWareVersion* robot_ware_version_;
    uint32_t rws_port_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class RobotControllerDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.RobotControllerDescription) */ {
 public:
  inline RobotControllerDescription() : RobotControllerDescription(nullptr) {}
  ~RobotControllerDescription() override;
  explicit PROTOBUF_CONSTEXPR RobotControllerDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotControllerDescription(const RobotControllerDescription& from);
  RobotControllerDescription(RobotControllerDescription&& from) noexcept
    : RobotControllerDescription() {
    *this = ::std::move(from);
  }

  inline RobotControllerDescription& operator=(const RobotControllerDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotControllerDescription& operator=(RobotControllerDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotControllerDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotControllerDescription* internal_default_instance() {
    return reinterpret_cast<const RobotControllerDescription*>(
               &_RobotControllerDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RobotControllerDescription& a, RobotControllerDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotControllerDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotControllerDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotControllerDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotControllerDescription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotControllerDescription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotControllerDescription& from) {
    RobotControllerDescription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotControllerDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.RobotControllerDescription";
  }
  protected:
  explicit RobotControllerDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMechanicalUnitsGroupsFieldNumber = 3,
    kRapidTasksFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kSystemIndicatorsFieldNumber = 2,
  };
  // repeated .abb.robot.MechanicalUnitGroup mechanical_units_groups = 3;
  int mechanical_units_groups_size() const;
  private:
  int _internal_mechanical_units_groups_size() const;
  public:
  void clear_mechanical_units_groups();
  ::abb::robot::MechanicalUnitGroup* mutable_mechanical_units_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup >*
      mutable_mechanical_units_groups();
  private:
  const ::abb::robot::MechanicalUnitGroup& _internal_mechanical_units_groups(int index) const;
  ::abb::robot::MechanicalUnitGroup* _internal_add_mechanical_units_groups();
  public:
  const ::abb::robot::MechanicalUnitGroup& mechanical_units_groups(int index) const;
  ::abb::robot::MechanicalUnitGroup* add_mechanical_units_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup >&
      mechanical_units_groups() const;

  // repeated .abb.robot.RAPIDTask rapid_tasks = 4;
  int rapid_tasks_size() const;
  private:
  int _internal_rapid_tasks_size() const;
  public:
  void clear_rapid_tasks();
  ::abb::robot::RAPIDTask* mutable_rapid_tasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::RAPIDTask >*
      mutable_rapid_tasks();
  private:
  const ::abb::robot::RAPIDTask& _internal_rapid_tasks(int index) const;
  ::abb::robot::RAPIDTask* _internal_add_rapid_tasks();
  public:
  const ::abb::robot::RAPIDTask& rapid_tasks(int index) const;
  ::abb::robot::RAPIDTask* add_rapid_tasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::RAPIDTask >&
      rapid_tasks() const;

  // optional .abb.robot.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::abb::robot::Header& header() const;
  PROTOBUF_NODISCARD ::abb::robot::Header* release_header();
  ::abb::robot::Header* mutable_header();
  void set_allocated_header(::abb::robot::Header* header);
  private:
  const ::abb::robot::Header& _internal_header() const;
  ::abb::robot::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::abb::robot::Header* header);
  ::abb::robot::Header* unsafe_arena_release_header();

  // optional .abb.robot.SystemIndicators system_indicators = 2;
  bool has_system_indicators() const;
  private:
  bool _internal_has_system_indicators() const;
  public:
  void clear_system_indicators();
  const ::abb::robot::SystemIndicators& system_indicators() const;
  PROTOBUF_NODISCARD ::abb::robot::SystemIndicators* release_system_indicators();
  ::abb::robot::SystemIndicators* mutable_system_indicators();
  void set_allocated_system_indicators(::abb::robot::SystemIndicators* system_indicators);
  private:
  const ::abb::robot::SystemIndicators& _internal_system_indicators() const;
  ::abb::robot::SystemIndicators* _internal_mutable_system_indicators();
  public:
  void unsafe_arena_set_allocated_system_indicators(
      ::abb::robot::SystemIndicators* system_indicators);
  ::abb::robot::SystemIndicators* unsafe_arena_release_system_indicators();

  // @@protoc_insertion_point(class_scope:abb.robot.RobotControllerDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup > mechanical_units_groups_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::RAPIDTask > rapid_tasks_;
    ::abb::robot::Header* header_;
    ::abb::robot::SystemIndicators* system_indicators_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class RobotWareVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.RobotWareVersion) */ {
 public:
  inline RobotWareVersion() : RobotWareVersion(nullptr) {}
  ~RobotWareVersion() override;
  explicit PROTOBUF_CONSTEXPR RobotWareVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotWareVersion(const RobotWareVersion& from);
  RobotWareVersion(RobotWareVersion&& from) noexcept
    : RobotWareVersion() {
    *this = ::std::move(from);
  }

  inline RobotWareVersion& operator=(const RobotWareVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotWareVersion& operator=(RobotWareVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotWareVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotWareVersion* internal_default_instance() {
    return reinterpret_cast<const RobotWareVersion*>(
               &_RobotWareVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RobotWareVersion& a, RobotWareVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotWareVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotWareVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotWareVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotWareVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotWareVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotWareVersion& from) {
    RobotWareVersion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotWareVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.RobotWareVersion";
  }
  protected:
  explicit RobotWareVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMajorNumberFieldNumber = 2,
    kMinorNumberFieldNumber = 3,
    kPatchNumberFieldNumber = 4,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint32 major_number = 2;
  bool has_major_number() const;
  private:
  bool _internal_has_major_number() const;
  public:
  void clear_major_number();
  uint32_t major_number() const;
  void set_major_number(uint32_t value);
  private:
  uint32_t _internal_major_number() const;
  void _internal_set_major_number(uint32_t value);
  public:

  // optional uint32 minor_number = 3;
  bool has_minor_number() const;
  private:
  bool _internal_has_minor_number() const;
  public:
  void clear_minor_number();
  uint32_t minor_number() const;
  void set_minor_number(uint32_t value);
  private:
  uint32_t _internal_minor_number() const;
  void _internal_set_minor_number(uint32_t value);
  public:

  // optional uint32 patch_number = 4;
  bool has_patch_number() const;
  private:
  bool _internal_has_patch_number() const;
  public:
  void clear_patch_number();
  uint32_t patch_number() const;
  void set_patch_number(uint32_t value);
  private:
  uint32_t _internal_patch_number() const;
  void _internal_set_patch_number(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.RobotWareVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t major_number_;
    uint32_t minor_number_;
    uint32_t patch_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class Cartesian final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.Cartesian) */ {
 public:
  inline Cartesian() : Cartesian(nullptr) {}
  ~Cartesian() override;
  explicit PROTOBUF_CONSTEXPR Cartesian(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cartesian(const Cartesian& from);
  Cartesian(Cartesian&& from) noexcept
    : Cartesian() {
    *this = ::std::move(from);
  }

  inline Cartesian& operator=(const Cartesian& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cartesian& operator=(Cartesian&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cartesian& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cartesian* internal_default_instance() {
    return reinterpret_cast<const Cartesian*>(
               &_Cartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Cartesian& a, Cartesian& b) {
    a.Swap(&b);
  }
  inline void Swap(Cartesian* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cartesian* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cartesian* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cartesian>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cartesian& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cartesian& from) {
    Cartesian::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cartesian* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.Cartesian";
  }
  protected:
  explicit Cartesian(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // optional double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.Cartesian)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class Quaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  explicit PROTOBUF_CONSTEXPR Quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQ1FieldNumber = 1,
    kQ2FieldNumber = 2,
    kQ3FieldNumber = 3,
    kQ4FieldNumber = 4,
  };
  // optional double q1 = 1;
  bool has_q1() const;
  private:
  bool _internal_has_q1() const;
  public:
  void clear_q1();
  double q1() const;
  void set_q1(double value);
  private:
  double _internal_q1() const;
  void _internal_set_q1(double value);
  public:

  // optional double q2 = 2;
  bool has_q2() const;
  private:
  bool _internal_has_q2() const;
  public:
  void clear_q2();
  double q2() const;
  void set_q2(double value);
  private:
  double _internal_q2() const;
  void _internal_set_q2(double value);
  public:

  // optional double q3 = 3;
  bool has_q3() const;
  private:
  bool _internal_has_q3() const;
  public:
  void clear_q3();
  double q3() const;
  void set_q3(double value);
  private:
  double _internal_q3() const;
  void _internal_set_q3(double value);
  public:

  // optional double q4 = 4;
  bool has_q4() const;
  private:
  bool _internal_has_q4() const;
  public:
  void clear_q4();
  double q4() const;
  void set_q4(double value);
  private:
  double _internal_q4() const;
  void _internal_set_q4(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double q1_;
    double q2_;
    double q3_;
    double q4_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class Pose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.Pose) */ {
 public:
  inline Pose() : Pose(nullptr) {}
  ~Pose() override;
  explicit PROTOBUF_CONSTEXPR Pose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pose(const Pose& from);
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose& operator=(Pose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(Pose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pose& from) {
    Pose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.Pose";
  }
  protected:
  explicit Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
  };
  // optional .abb.robot.Cartesian position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::abb::robot::Cartesian& position() const;
  PROTOBUF_NODISCARD ::abb::robot::Cartesian* release_position();
  ::abb::robot::Cartesian* mutable_position();
  void set_allocated_position(::abb::robot::Cartesian* position);
  private:
  const ::abb::robot::Cartesian& _internal_position() const;
  ::abb::robot::Cartesian* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::abb::robot::Cartesian* position);
  ::abb::robot::Cartesian* unsafe_arena_release_position();

  // optional .abb.robot.Quaternion rotation = 2;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::abb::robot::Quaternion& rotation() const;
  PROTOBUF_NODISCARD ::abb::robot::Quaternion* release_rotation();
  ::abb::robot::Quaternion* mutable_rotation();
  void set_allocated_rotation(::abb::robot::Quaternion* rotation);
  private:
  const ::abb::robot::Quaternion& _internal_rotation() const;
  ::abb::robot::Quaternion* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::abb::robot::Quaternion* rotation);
  ::abb::robot::Quaternion* unsafe_arena_release_rotation();

  // @@protoc_insertion_point(class_scope:abb.robot.Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::robot::Cartesian* position_;
    ::abb::robot::Quaternion* rotation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class RobotIndicators final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.RobotIndicators) */ {
 public:
  inline RobotIndicators() : RobotIndicators(nullptr) {}
  ~RobotIndicators() override;
  explicit PROTOBUF_CONSTEXPR RobotIndicators(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotIndicators(const RobotIndicators& from);
  RobotIndicators(RobotIndicators&& from) noexcept
    : RobotIndicators() {
    *this = ::std::move(from);
  }

  inline RobotIndicators& operator=(const RobotIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotIndicators& operator=(RobotIndicators&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotIndicators& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotIndicators* internal_default_instance() {
    return reinterpret_cast<const RobotIndicators*>(
               &_RobotIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RobotIndicators& a, RobotIndicators& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotIndicators* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotIndicators* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotIndicators* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotIndicators>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotIndicators& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotIndicators& from) {
    RobotIndicators::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotIndicators* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.RobotIndicators";
  }
  protected:
  explicit RobotIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIrb14000FieldNumber = 1,
  };
  // optional bool irb14000 = 1;
  bool has_irb14000() const;
  private:
  bool _internal_has_irb14000() const;
  public:
  void clear_irb14000();
  bool irb14000() const;
  void set_irb14000(bool value);
  private:
  bool _internal_irb14000() const;
  void _internal_set_irb14000(bool value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.RobotIndicators)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool irb14000_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class OptionIndicators final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.OptionIndicators) */ {
 public:
  inline OptionIndicators() : OptionIndicators(nullptr) {}
  ~OptionIndicators() override;
  explicit PROTOBUF_CONSTEXPR OptionIndicators(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OptionIndicators(const OptionIndicators& from);
  OptionIndicators(OptionIndicators&& from) noexcept
    : OptionIndicators() {
    *this = ::std::move(from);
  }

  inline OptionIndicators& operator=(const OptionIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionIndicators& operator=(OptionIndicators&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionIndicators& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptionIndicators* internal_default_instance() {
    return reinterpret_cast<const OptionIndicators*>(
               &_OptionIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OptionIndicators& a, OptionIndicators& b) {
    a.Swap(&b);
  }
  inline void Swap(OptionIndicators* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionIndicators* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionIndicators* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptionIndicators>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OptionIndicators& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OptionIndicators& from) {
    OptionIndicators::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptionIndicators* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.OptionIndicators";
  }
  protected:
  explicit OptionIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEgmFieldNumber = 1,
    kLeadthroughFieldNumber = 2,
    kMultimoveFieldNumber = 3,
  };
  // optional bool egm = 1;
  bool has_egm() const;
  private:
  bool _internal_has_egm() const;
  public:
  void clear_egm();
  bool egm() const;
  void set_egm(bool value);
  private:
  bool _internal_egm() const;
  void _internal_set_egm(bool value);
  public:

  // optional bool leadthrough = 2;
  bool has_leadthrough() const;
  private:
  bool _internal_has_leadthrough() const;
  public:
  void clear_leadthrough();
  bool leadthrough() const;
  void set_leadthrough(bool value);
  private:
  bool _internal_leadthrough() const;
  void _internal_set_leadthrough(bool value);
  public:

  // optional bool multimove = 3;
  bool has_multimove() const;
  private:
  bool _internal_has_multimove() const;
  public:
  void clear_multimove();
  bool multimove() const;
  void set_multimove(bool value);
  private:
  bool _internal_multimove() const;
  void _internal_set_multimove(bool value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.OptionIndicators)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool egm_;
    bool leadthrough_;
    bool multimove_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class AddInIndicators final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.AddInIndicators) */ {
 public:
  inline AddInIndicators() : AddInIndicators(nullptr) {}
  ~AddInIndicators() override;
  explicit PROTOBUF_CONSTEXPR AddInIndicators(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddInIndicators(const AddInIndicators& from);
  AddInIndicators(AddInIndicators&& from) noexcept
    : AddInIndicators() {
    *this = ::std::move(from);
  }

  inline AddInIndicators& operator=(const AddInIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddInIndicators& operator=(AddInIndicators&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddInIndicators& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddInIndicators* internal_default_instance() {
    return reinterpret_cast<const AddInIndicators*>(
               &_AddInIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AddInIndicators& a, AddInIndicators& b) {
    a.Swap(&b);
  }
  inline void Swap(AddInIndicators* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddInIndicators* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddInIndicators* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddInIndicators>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddInIndicators& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddInIndicators& from) {
    AddInIndicators::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddInIndicators* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.AddInIndicators";
  }
  protected:
  explicit AddInIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSmartGripperFieldNumber = 1,
    kStateMachine10FieldNumber = 2,
    kStateMachine11FieldNumber = 3,
  };
  // optional bool smart_gripper = 1;
  bool has_smart_gripper() const;
  private:
  bool _internal_has_smart_gripper() const;
  public:
  void clear_smart_gripper();
  bool smart_gripper() const;
  void set_smart_gripper(bool value);
  private:
  bool _internal_smart_gripper() const;
  void _internal_set_smart_gripper(bool value);
  public:

  // optional bool state_machine_1_0 = 2;
  bool has_state_machine_1_0() const;
  private:
  bool _internal_has_state_machine_1_0() const;
  public:
  void clear_state_machine_1_0();
  bool state_machine_1_0() const;
  void set_state_machine_1_0(bool value);
  private:
  bool _internal_state_machine_1_0() const;
  void _internal_set_state_machine_1_0(bool value);
  public:

  // optional bool state_machine_1_1 = 3;
  bool has_state_machine_1_1() const;
  private:
  bool _internal_has_state_machine_1_1() const;
  public:
  void clear_state_machine_1_1();
  bool state_machine_1_1() const;
  void set_state_machine_1_1(bool value);
  private:
  bool _internal_state_machine_1_1() const;
  void _internal_set_state_machine_1_1(bool value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.AddInIndicators)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool smart_gripper_;
    bool state_machine_1_0_;
    bool state_machine_1_1_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class SystemIndicators final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.SystemIndicators) */ {
 public:
  inline SystemIndicators() : SystemIndicators(nullptr) {}
  ~SystemIndicators() override;
  explicit PROTOBUF_CONSTEXPR SystemIndicators(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemIndicators(const SystemIndicators& from);
  SystemIndicators(SystemIndicators&& from) noexcept
    : SystemIndicators() {
    *this = ::std::move(from);
  }

  inline SystemIndicators& operator=(const SystemIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemIndicators& operator=(SystemIndicators&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemIndicators& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemIndicators* internal_default_instance() {
    return reinterpret_cast<const SystemIndicators*>(
               &_SystemIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SystemIndicators& a, SystemIndicators& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemIndicators* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemIndicators* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemIndicators* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemIndicators>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemIndicators& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemIndicators& from) {
    SystemIndicators::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemIndicators* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.SystemIndicators";
  }
  protected:
  explicit SystemIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotsFieldNumber = 1,
    kOptionsFieldNumber = 2,
    kAddinsFieldNumber = 3,
  };
  // optional .abb.robot.RobotIndicators robots = 1;
  bool has_robots() const;
  private:
  bool _internal_has_robots() const;
  public:
  void clear_robots();
  const ::abb::robot::RobotIndicators& robots() const;
  PROTOBUF_NODISCARD ::abb::robot::RobotIndicators* release_robots();
  ::abb::robot::RobotIndicators* mutable_robots();
  void set_allocated_robots(::abb::robot::RobotIndicators* robots);
  private:
  const ::abb::robot::RobotIndicators& _internal_robots() const;
  ::abb::robot::RobotIndicators* _internal_mutable_robots();
  public:
  void unsafe_arena_set_allocated_robots(
      ::abb::robot::RobotIndicators* robots);
  ::abb::robot::RobotIndicators* unsafe_arena_release_robots();

  // optional .abb.robot.OptionIndicators options = 2;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::abb::robot::OptionIndicators& options() const;
  PROTOBUF_NODISCARD ::abb::robot::OptionIndicators* release_options();
  ::abb::robot::OptionIndicators* mutable_options();
  void set_allocated_options(::abb::robot::OptionIndicators* options);
  private:
  const ::abb::robot::OptionIndicators& _internal_options() const;
  ::abb::robot::OptionIndicators* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::abb::robot::OptionIndicators* options);
  ::abb::robot::OptionIndicators* unsafe_arena_release_options();

  // optional .abb.robot.AddInIndicators addins = 3;
  bool has_addins() const;
  private:
  bool _internal_has_addins() const;
  public:
  void clear_addins();
  const ::abb::robot::AddInIndicators& addins() const;
  PROTOBUF_NODISCARD ::abb::robot::AddInIndicators* release_addins();
  ::abb::robot::AddInIndicators* mutable_addins();
  void set_allocated_addins(::abb::robot::AddInIndicators* addins);
  private:
  const ::abb::robot::AddInIndicators& _internal_addins() const;
  ::abb::robot::AddInIndicators* _internal_mutable_addins();
  public:
  void unsafe_arena_set_allocated_addins(
      ::abb::robot::AddInIndicators* addins);
  ::abb::robot::AddInIndicators* unsafe_arena_release_addins();

  // @@protoc_insertion_point(class_scope:abb.robot.SystemIndicators)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::robot::RobotIndicators* robots_;
    ::abb::robot::OptionIndicators* options_;
    ::abb::robot::AddInIndicators* addins_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class Transmission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.Transmission) */ {
 public:
  inline Transmission() : Transmission(nullptr) {}
  ~Transmission() override;
  explicit PROTOBUF_CONSTEXPR Transmission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transmission(const Transmission& from);
  Transmission(Transmission&& from) noexcept
    : Transmission() {
    *this = ::std::move(from);
  }

  inline Transmission& operator=(const Transmission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transmission& operator=(Transmission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transmission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transmission* internal_default_instance() {
    return reinterpret_cast<const Transmission*>(
               &_Transmission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Transmission& a, Transmission& b) {
    a.Swap(&b);
  }
  inline void Swap(Transmission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transmission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transmission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transmission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transmission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Transmission& from) {
    Transmission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transmission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.Transmission";
  }
  protected:
  explicit Transmission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRotatingMoveFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool rotating_move = 2;
  bool has_rotating_move() const;
  private:
  bool _internal_has_rotating_move() const;
  public:
  void clear_rotating_move();
  bool rotating_move() const;
  void set_rotating_move(bool value);
  private:
  bool _internal_rotating_move() const;
  void _internal_set_rotating_move(bool value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.Transmission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool rotating_move_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class Arm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.Arm) */ {
 public:
  inline Arm() : Arm(nullptr) {}
  ~Arm() override;
  explicit PROTOBUF_CONSTEXPR Arm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Arm(const Arm& from);
  Arm(Arm&& from) noexcept
    : Arm() {
    *this = ::std::move(from);
  }

  inline Arm& operator=(const Arm& from) {
    CopyFrom(from);
    return *this;
  }
  inline Arm& operator=(Arm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Arm& default_instance() {
    return *internal_default_instance();
  }
  static inline const Arm* internal_default_instance() {
    return reinterpret_cast<const Arm*>(
               &_Arm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Arm& a, Arm& b) {
    a.Swap(&b);
  }
  inline void Swap(Arm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Arm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Arm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Arm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Arm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Arm& from) {
    Arm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Arm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.Arm";
  }
  protected:
  explicit Arm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLowerJointBoundFieldNumber = 2,
    kUpperJointBoundFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional double lower_joint_bound = 2;
  bool has_lower_joint_bound() const;
  private:
  bool _internal_has_lower_joint_bound() const;
  public:
  void clear_lower_joint_bound();
  double lower_joint_bound() const;
  void set_lower_joint_bound(double value);
  private:
  double _internal_lower_joint_bound() const;
  void _internal_set_lower_joint_bound(double value);
  public:

  // optional double upper_joint_bound = 3;
  bool has_upper_joint_bound() const;
  private:
  bool _internal_has_upper_joint_bound() const;
  public:
  void clear_upper_joint_bound();
  double upper_joint_bound() const;
  void set_upper_joint_bound(double value);
  private:
  double _internal_upper_joint_bound() const;
  void _internal_set_upper_joint_bound(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.Arm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    double lower_joint_bound_;
    double upper_joint_bound_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class Joint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.Joint) */ {
 public:
  inline Joint() : Joint(nullptr) {}
  ~Joint() override;
  explicit PROTOBUF_CONSTEXPR Joint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Joint(const Joint& from);
  Joint(Joint&& from) noexcept
    : Joint() {
    *this = ::std::move(from);
  }

  inline Joint& operator=(const Joint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Joint& operator=(Joint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Joint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Joint* internal_default_instance() {
    return reinterpret_cast<const Joint*>(
               &_Joint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Joint& a, Joint& b) {
    a.Swap(&b);
  }
  inline void Swap(Joint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Joint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Joint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Joint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Joint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Joint& from) {
    Joint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Joint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.Joint";
  }
  protected:
  explicit Joint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kArmFieldNumber = 4,
    kTransmissionFieldNumber = 5,
    kLogicalAxisFieldNumber = 2,
    kKinematicAxisNumberFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .abb.robot.Arm arm = 4;
  bool has_arm() const;
  private:
  bool _internal_has_arm() const;
  public:
  void clear_arm();
  const ::abb::robot::Arm& arm() const;
  PROTOBUF_NODISCARD ::abb::robot::Arm* release_arm();
  ::abb::robot::Arm* mutable_arm();
  void set_allocated_arm(::abb::robot::Arm* arm);
  private:
  const ::abb::robot::Arm& _internal_arm() const;
  ::abb::robot::Arm* _internal_mutable_arm();
  public:
  void unsafe_arena_set_allocated_arm(
      ::abb::robot::Arm* arm);
  ::abb::robot::Arm* unsafe_arena_release_arm();

  // optional .abb.robot.Transmission transmission = 5;
  bool has_transmission() const;
  private:
  bool _internal_has_transmission() const;
  public:
  void clear_transmission();
  const ::abb::robot::Transmission& transmission() const;
  PROTOBUF_NODISCARD ::abb::robot::Transmission* release_transmission();
  ::abb::robot::Transmission* mutable_transmission();
  void set_allocated_transmission(::abb::robot::Transmission* transmission);
  private:
  const ::abb::robot::Transmission& _internal_transmission() const;
  ::abb::robot::Transmission* _internal_mutable_transmission();
  public:
  void unsafe_arena_set_allocated_transmission(
      ::abb::robot::Transmission* transmission);
  ::abb::robot::Transmission* unsafe_arena_release_transmission();

  // optional int32 logical_axis = 2;
  bool has_logical_axis() const;
  private:
  bool _internal_has_logical_axis() const;
  public:
  void clear_logical_axis();
  int32_t logical_axis() const;
  void set_logical_axis(int32_t value);
  private:
  int32_t _internal_logical_axis() const;
  void _internal_set_logical_axis(int32_t value);
  public:

  // optional int32 kinematic_axis_number = 3;
  bool has_kinematic_axis_number() const;
  private:
  bool _internal_has_kinematic_axis_number() const;
  public:
  void clear_kinematic_axis_number();
  int32_t kinematic_axis_number() const;
  void set_kinematic_axis_number(int32_t value);
  private:
  int32_t _internal_kinematic_axis_number() const;
  void _internal_set_kinematic_axis_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.Joint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::abb::robot::Arm* arm_;
    ::abb::robot::Transmission* transmission_;
    int32_t logical_axis_;
    int32_t kinematic_axis_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class StandardizedJoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.StandardizedJoint) */ {
 public:
  inline StandardizedJoint() : StandardizedJoint(nullptr) {}
  ~StandardizedJoint() override;
  explicit PROTOBUF_CONSTEXPR StandardizedJoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StandardizedJoint(const StandardizedJoint& from);
  StandardizedJoint(StandardizedJoint&& from) noexcept
    : StandardizedJoint() {
    *this = ::std::move(from);
  }

  inline StandardizedJoint& operator=(const StandardizedJoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline StandardizedJoint& operator=(StandardizedJoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StandardizedJoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const StandardizedJoint* internal_default_instance() {
    return reinterpret_cast<const StandardizedJoint*>(
               &_StandardizedJoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StandardizedJoint& a, StandardizedJoint& b) {
    a.Swap(&b);
  }
  inline void Swap(StandardizedJoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StandardizedJoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StandardizedJoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StandardizedJoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StandardizedJoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StandardizedJoint& from) {
    StandardizedJoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StandardizedJoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.StandardizedJoint";
  }
  protected:
  explicit StandardizedJoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginalNameFieldNumber = 1,
    kStandardizedNameFieldNumber = 2,
    kLowerJointBoundFieldNumber = 4,
    kUpperJointBoundFieldNumber = 5,
    kRotatingMoveFieldNumber = 3,
  };
  // optional string original_name = 1;
  bool has_original_name() const;
  private:
  bool _internal_has_original_name() const;
  public:
  void clear_original_name();
  const std::string& original_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_name();
  PROTOBUF_NODISCARD std::string* release_original_name();
  void set_allocated_original_name(std::string* original_name);
  private:
  const std::string& _internal_original_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_name(const std::string& value);
  std::string* _internal_mutable_original_name();
  public:

  // optional string standardized_name = 2;
  bool has_standardized_name() const;
  private:
  bool _internal_has_standardized_name() const;
  public:
  void clear_standardized_name();
  const std::string& standardized_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_standardized_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_standardized_name();
  PROTOBUF_NODISCARD std::string* release_standardized_name();
  void set_allocated_standardized_name(std::string* standardized_name);
  private:
  const std::string& _internal_standardized_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_standardized_name(const std::string& value);
  std::string* _internal_mutable_standardized_name();
  public:

  // optional double lower_joint_bound = 4;
  bool has_lower_joint_bound() const;
  private:
  bool _internal_has_lower_joint_bound() const;
  public:
  void clear_lower_joint_bound();
  double lower_joint_bound() const;
  void set_lower_joint_bound(double value);
  private:
  double _internal_lower_joint_bound() const;
  void _internal_set_lower_joint_bound(double value);
  public:

  // optional double upper_joint_bound = 5;
  bool has_upper_joint_bound() const;
  private:
  bool _internal_has_upper_joint_bound() const;
  public:
  void clear_upper_joint_bound();
  double upper_joint_bound() const;
  void set_upper_joint_bound(double value);
  private:
  double _internal_upper_joint_bound() const;
  void _internal_set_upper_joint_bound(double value);
  public:

  // optional bool rotating_move = 3;
  bool has_rotating_move() const;
  private:
  bool _internal_has_rotating_move() const;
  public:
  void clear_rotating_move();
  bool rotating_move() const;
  void set_rotating_move(bool value);
  private:
  bool _internal_rotating_move() const;
  void _internal_set_rotating_move(bool value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.StandardizedJoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr standardized_name_;
    double lower_joint_bound_;
    double upper_joint_bound_;
    bool rotating_move_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class Single final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.Single) */ {
 public:
  inline Single() : Single(nullptr) {}
  ~Single() override;
  explicit PROTOBUF_CONSTEXPR Single(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Single(const Single& from);
  Single(Single&& from) noexcept
    : Single() {
    *this = ::std::move(from);
  }

  inline Single& operator=(const Single& from) {
    CopyFrom(from);
    return *this;
  }
  inline Single& operator=(Single&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Single& default_instance() {
    return *internal_default_instance();
  }
  static inline const Single* internal_default_instance() {
    return reinterpret_cast<const Single*>(
               &_Single_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Single& a, Single& b) {
    a.Swap(&b);
  }
  inline void Swap(Single* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Single* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Single* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Single>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Single& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Single& from) {
    Single::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Single* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.Single";
  }
  protected:
  explicit Single(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kBaseFrameMovedByFieldNumber = 5,
    kJointFieldNumber = 3,
    kBaseFrameFieldNumber = 4,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string base_frame_moved_by = 5;
  bool has_base_frame_moved_by() const;
  private:
  bool _internal_has_base_frame_moved_by() const;
  public:
  void clear_base_frame_moved_by();
  const std::string& base_frame_moved_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_frame_moved_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_frame_moved_by();
  PROTOBUF_NODISCARD std::string* release_base_frame_moved_by();
  void set_allocated_base_frame_moved_by(std::string* base_frame_moved_by);
  private:
  const std::string& _internal_base_frame_moved_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_frame_moved_by(const std::string& value);
  std::string* _internal_mutable_base_frame_moved_by();
  public:

  // optional .abb.robot.Joint joint = 3;
  bool has_joint() const;
  private:
  bool _internal_has_joint() const;
  public:
  void clear_joint();
  const ::abb::robot::Joint& joint() const;
  PROTOBUF_NODISCARD ::abb::robot::Joint* release_joint();
  ::abb::robot::Joint* mutable_joint();
  void set_allocated_joint(::abb::robot::Joint* joint);
  private:
  const ::abb::robot::Joint& _internal_joint() const;
  ::abb::robot::Joint* _internal_mutable_joint();
  public:
  void unsafe_arena_set_allocated_joint(
      ::abb::robot::Joint* joint);
  ::abb::robot::Joint* unsafe_arena_release_joint();

  // optional .abb.robot.Pose base_frame = 4;
  bool has_base_frame() const;
  private:
  bool _internal_has_base_frame() const;
  public:
  void clear_base_frame();
  const ::abb::robot::Pose& base_frame() const;
  PROTOBUF_NODISCARD ::abb::robot::Pose* release_base_frame();
  ::abb::robot::Pose* mutable_base_frame();
  void set_allocated_base_frame(::abb::robot::Pose* base_frame);
  private:
  const ::abb::robot::Pose& _internal_base_frame() const;
  ::abb::robot::Pose* _internal_mutable_base_frame();
  public:
  void unsafe_arena_set_allocated_base_frame(
      ::abb::robot::Pose* base_frame);
  ::abb::robot::Pose* unsafe_arena_release_base_frame();

  // @@protoc_insertion_point(class_scope:abb.robot.Single)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_frame_moved_by_;
    ::abb::robot::Joint* joint_;
    ::abb::robot::Pose* base_frame_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class Robot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.Robot) */ {
 public:
  inline Robot() : Robot(nullptr) {}
  ~Robot() override;
  explicit PROTOBUF_CONSTEXPR Robot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot(const Robot& from);
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot& operator=(Robot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Robot& from) {
    Robot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.Robot";
  }
  protected:
  explicit Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 3,
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kBaseFrameMovedByFieldNumber = 5,
    kBaseFrameFieldNumber = 4,
  };
  // repeated .abb.robot.Joint joints = 3;
  int joints_size() const;
  private:
  int _internal_joints_size() const;
  public:
  void clear_joints();
  ::abb::robot::Joint* mutable_joints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::Joint >*
      mutable_joints();
  private:
  const ::abb::robot::Joint& _internal_joints(int index) const;
  ::abb::robot::Joint* _internal_add_joints();
  public:
  const ::abb::robot::Joint& joints(int index) const;
  ::abb::robot::Joint* add_joints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::Joint >&
      joints() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string base_frame_moved_by = 5;
  bool has_base_frame_moved_by() const;
  private:
  bool _internal_has_base_frame_moved_by() const;
  public:
  void clear_base_frame_moved_by();
  const std::string& base_frame_moved_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_frame_moved_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_frame_moved_by();
  PROTOBUF_NODISCARD std::string* release_base_frame_moved_by();
  void set_allocated_base_frame_moved_by(std::string* base_frame_moved_by);
  private:
  const std::string& _internal_base_frame_moved_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_frame_moved_by(const std::string& value);
  std::string* _internal_mutable_base_frame_moved_by();
  public:

  // optional .abb.robot.Pose base_frame = 4;
  bool has_base_frame() const;
  private:
  bool _internal_has_base_frame() const;
  public:
  void clear_base_frame();
  const ::abb::robot::Pose& base_frame() const;
  PROTOBUF_NODISCARD ::abb::robot::Pose* release_base_frame();
  ::abb::robot::Pose* mutable_base_frame();
  void set_allocated_base_frame(::abb::robot::Pose* base_frame);
  private:
  const ::abb::robot::Pose& _internal_base_frame() const;
  ::abb::robot::Pose* _internal_mutable_base_frame();
  public:
  void unsafe_arena_set_allocated_base_frame(
      ::abb::robot::Pose* base_frame);
  ::abb::robot::Pose* unsafe_arena_release_base_frame();

  // @@protoc_insertion_point(class_scope:abb.robot.Robot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::Joint > joints_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_frame_moved_by_;
    ::abb::robot::Pose* base_frame_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class MechanicalUnit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.MechanicalUnit) */ {
 public:
  inline MechanicalUnit() : MechanicalUnit(nullptr) {}
  ~MechanicalUnit() override;
  explicit PROTOBUF_CONSTEXPR MechanicalUnit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MechanicalUnit(const MechanicalUnit& from);
  MechanicalUnit(MechanicalUnit&& from) noexcept
    : MechanicalUnit() {
    *this = ::std::move(from);
  }

  inline MechanicalUnit& operator=(const MechanicalUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MechanicalUnit& operator=(MechanicalUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MechanicalUnit& default_instance() {
    return *internal_default_instance();
  }
  static inline const MechanicalUnit* internal_default_instance() {
    return reinterpret_cast<const MechanicalUnit*>(
               &_MechanicalUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MechanicalUnit& a, MechanicalUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(MechanicalUnit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MechanicalUnit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MechanicalUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MechanicalUnit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MechanicalUnit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MechanicalUnit& from) {
    MechanicalUnit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MechanicalUnit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.MechanicalUnit";
  }
  protected:
  explicit MechanicalUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MechanicalUnit_Type Type;
  static constexpr Type UNDEFINED =
    MechanicalUnit_Type_UNDEFINED;
  static constexpr Type NONE =
    MechanicalUnit_Type_NONE;
  static constexpr Type TCP_ROBOT =
    MechanicalUnit_Type_TCP_ROBOT;
  static constexpr Type ROBOT =
    MechanicalUnit_Type_ROBOT;
  static constexpr Type SINGLE =
    MechanicalUnit_Type_SINGLE;
  static inline bool Type_IsValid(int value) {
    return MechanicalUnit_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    MechanicalUnit_Type_Type_MIN;
  static constexpr Type Type_MAX =
    MechanicalUnit_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    MechanicalUnit_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return MechanicalUnit_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return MechanicalUnit_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return MechanicalUnit_Type_Parse(name, value);
  }

  typedef MechanicalUnit_Mode Mode;
  static constexpr Mode DEACTIVATED =
    MechanicalUnit_Mode_DEACTIVATED;
  static constexpr Mode ACTIVATED =
    MechanicalUnit_Mode_ACTIVATED;
  static inline bool Mode_IsValid(int value) {
    return MechanicalUnit_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    MechanicalUnit_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    MechanicalUnit_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    MechanicalUnit_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Mode_descriptor() {
    return MechanicalUnit_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return MechanicalUnit_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return MechanicalUnit_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSinglesFieldNumber = 3,
    kStandardizedJointsFieldNumber = 12,
    kNameFieldNumber = 1,
    kTaskNameFieldNumber = 5,
    kIsIntegratedUnitFieldNumber = 8,
    kHasIntegratedUnitFieldNumber = 9,
    kStatusFieldNumber = 10,
    kRobotFieldNumber = 2,
    kTypeFieldNumber = 4,
    kAxesFieldNumber = 6,
    kAxesTotalFieldNumber = 7,
    kModeFieldNumber = 11,
  };
  // repeated .abb.robot.Single singles = 3;
  int singles_size() const;
  private:
  int _internal_singles_size() const;
  public:
  void clear_singles();
  ::abb::robot::Single* mutable_singles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::Single >*
      mutable_singles();
  private:
  const ::abb::robot::Single& _internal_singles(int index) const;
  ::abb::robot::Single* _internal_add_singles();
  public:
  const ::abb::robot::Single& singles(int index) const;
  ::abb::robot::Single* add_singles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::Single >&
      singles() const;

  // repeated .abb.robot.StandardizedJoint standardized_joints = 12;
  int standardized_joints_size() const;
  private:
  int _internal_standardized_joints_size() const;
  public:
  void clear_standardized_joints();
  ::abb::robot::StandardizedJoint* mutable_standardized_joints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::StandardizedJoint >*
      mutable_standardized_joints();
  private:
  const ::abb::robot::StandardizedJoint& _internal_standardized_joints(int index) const;
  ::abb::robot::StandardizedJoint* _internal_add_standardized_joints();
  public:
  const ::abb::robot::StandardizedJoint& standardized_joints(int index) const;
  ::abb::robot::StandardizedJoint* add_standardized_joints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::StandardizedJoint >&
      standardized_joints() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string task_name = 5;
  bool has_task_name() const;
  private:
  bool _internal_has_task_name() const;
  public:
  void clear_task_name();
  const std::string& task_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_name();
  PROTOBUF_NODISCARD std::string* release_task_name();
  void set_allocated_task_name(std::string* task_name);
  private:
  const std::string& _internal_task_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_name(const std::string& value);
  std::string* _internal_mutable_task_name();
  public:

  // optional string is_integrated_unit = 8;
  bool has_is_integrated_unit() const;
  private:
  bool _internal_has_is_integrated_unit() const;
  public:
  void clear_is_integrated_unit();
  const std::string& is_integrated_unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_is_integrated_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_is_integrated_unit();
  PROTOBUF_NODISCARD std::string* release_is_integrated_unit();
  void set_allocated_is_integrated_unit(std::string* is_integrated_unit);
  private:
  const std::string& _internal_is_integrated_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_is_integrated_unit(const std::string& value);
  std::string* _internal_mutable_is_integrated_unit();
  public:

  // optional string has_integrated_unit = 9;
  bool has_has_integrated_unit() const;
  private:
  bool _internal_has_has_integrated_unit() const;
  public:
  void clear_has_integrated_unit();
  const std::string& has_integrated_unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_has_integrated_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_has_integrated_unit();
  PROTOBUF_NODISCARD std::string* release_has_integrated_unit();
  void set_allocated_has_integrated_unit(std::string* has_integrated_unit);
  private:
  const std::string& _internal_has_integrated_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_has_integrated_unit(const std::string& value);
  std::string* _internal_mutable_has_integrated_unit();
  public:

  // optional string status = 10;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional .abb.robot.Robot robot = 2;
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::abb::robot::Robot& robot() const;
  PROTOBUF_NODISCARD ::abb::robot::Robot* release_robot();
  ::abb::robot::Robot* mutable_robot();
  void set_allocated_robot(::abb::robot::Robot* robot);
  private:
  const ::abb::robot::Robot& _internal_robot() const;
  ::abb::robot::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::abb::robot::Robot* robot);
  ::abb::robot::Robot* unsafe_arena_release_robot();

  // optional .abb.robot.MechanicalUnit.Type type = 4 [default = UNDEFINED];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::abb::robot::MechanicalUnit_Type type() const;
  void set_type(::abb::robot::MechanicalUnit_Type value);
  private:
  ::abb::robot::MechanicalUnit_Type _internal_type() const;
  void _internal_set_type(::abb::robot::MechanicalUnit_Type value);
  public:

  // optional int32 axes = 6;
  bool has_axes() const;
  private:
  bool _internal_has_axes() const;
  public:
  void clear_axes();
  int32_t axes() const;
  void set_axes(int32_t value);
  private:
  int32_t _internal_axes() const;
  void _internal_set_axes(int32_t value);
  public:

  // optional int32 axes_total = 7;
  bool has_axes_total() const;
  private:
  bool _internal_has_axes_total() const;
  public:
  void clear_axes_total();
  int32_t axes_total() const;
  void set_axes_total(int32_t value);
  private:
  int32_t _internal_axes_total() const;
  void _internal_set_axes_total(int32_t value);
  public:

  // optional .abb.robot.MechanicalUnit.Mode mode = 11 [default = DEACTIVATED];
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::abb::robot::MechanicalUnit_Mode mode() const;
  void set_mode(::abb::robot::MechanicalUnit_Mode value);
  private:
  ::abb::robot::MechanicalUnit_Mode _internal_mode() const;
  void _internal_set_mode(::abb::robot::MechanicalUnit_Mode value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.MechanicalUnit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::Single > singles_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::StandardizedJoint > standardized_joints_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr is_integrated_unit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr has_integrated_unit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::abb::robot::Robot* robot_;
    int type_;
    int32_t axes_;
    int32_t axes_total_;
    int mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class MechanicalUnitGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.MechanicalUnitGroup) */ {
 public:
  inline MechanicalUnitGroup() : MechanicalUnitGroup(nullptr) {}
  ~MechanicalUnitGroup() override;
  explicit PROTOBUF_CONSTEXPR MechanicalUnitGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MechanicalUnitGroup(const MechanicalUnitGroup& from);
  MechanicalUnitGroup(MechanicalUnitGroup&& from) noexcept
    : MechanicalUnitGroup() {
    *this = ::std::move(from);
  }

  inline MechanicalUnitGroup& operator=(const MechanicalUnitGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline MechanicalUnitGroup& operator=(MechanicalUnitGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MechanicalUnitGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const MechanicalUnitGroup* internal_default_instance() {
    return reinterpret_cast<const MechanicalUnitGroup*>(
               &_MechanicalUnitGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MechanicalUnitGroup& a, MechanicalUnitGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(MechanicalUnitGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MechanicalUnitGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MechanicalUnitGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MechanicalUnitGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MechanicalUnitGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MechanicalUnitGroup& from) {
    MechanicalUnitGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MechanicalUnitGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.MechanicalUnitGroup";
  }
  protected:
  explicit MechanicalUnitGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMechanicalUnitsFieldNumber = 3,
    kNameFieldNumber = 1,
    kRobotFieldNumber = 2,
  };
  // repeated .abb.robot.MechanicalUnit mechanical_units = 3;
  int mechanical_units_size() const;
  private:
  int _internal_mechanical_units_size() const;
  public:
  void clear_mechanical_units();
  ::abb::robot::MechanicalUnit* mutable_mechanical_units(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::MechanicalUnit >*
      mutable_mechanical_units();
  private:
  const ::abb::robot::MechanicalUnit& _internal_mechanical_units(int index) const;
  ::abb::robot::MechanicalUnit* _internal_add_mechanical_units();
  public:
  const ::abb::robot::MechanicalUnit& mechanical_units(int index) const;
  ::abb::robot::MechanicalUnit* add_mechanical_units();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::MechanicalUnit >&
      mechanical_units() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .abb.robot.MechanicalUnit robot = 2;
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::abb::robot::MechanicalUnit& robot() const;
  PROTOBUF_NODISCARD ::abb::robot::MechanicalUnit* release_robot();
  ::abb::robot::MechanicalUnit* mutable_robot();
  void set_allocated_robot(::abb::robot::MechanicalUnit* robot);
  private:
  const ::abb::robot::MechanicalUnit& _internal_robot() const;
  ::abb::robot::MechanicalUnit* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::abb::robot::MechanicalUnit* robot);
  ::abb::robot::MechanicalUnit* unsafe_arena_release_robot();

  // @@protoc_insertion_point(class_scope:abb.robot.MechanicalUnitGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::MechanicalUnit > mechanical_units_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::abb::robot::MechanicalUnit* robot_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class RAPIDModule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.RAPIDModule) */ {
 public:
  inline RAPIDModule() : RAPIDModule(nullptr) {}
  ~RAPIDModule() override;
  explicit PROTOBUF_CONSTEXPR RAPIDModule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RAPIDModule(const RAPIDModule& from);
  RAPIDModule(RAPIDModule&& from) noexcept
    : RAPIDModule() {
    *this = ::std::move(from);
  }

  inline RAPIDModule& operator=(const RAPIDModule& from) {
    CopyFrom(from);
    return *this;
  }
  inline RAPIDModule& operator=(RAPIDModule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RAPIDModule& default_instance() {
    return *internal_default_instance();
  }
  static inline const RAPIDModule* internal_default_instance() {
    return reinterpret_cast<const RAPIDModule*>(
               &_RAPIDModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RAPIDModule& a, RAPIDModule& b) {
    a.Swap(&b);
  }
  inline void Swap(RAPIDModule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RAPIDModule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RAPIDModule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RAPIDModule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RAPIDModule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RAPIDModule& from) {
    RAPIDModule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RAPIDModule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.RAPIDModule";
  }
  protected:
  explicit RAPIDModule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.RAPIDModule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// -------------------------------------------------------------------

class RAPIDTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.robot.RAPIDTask) */ {
 public:
  inline RAPIDTask() : RAPIDTask(nullptr) {}
  ~RAPIDTask() override;
  explicit PROTOBUF_CONSTEXPR RAPIDTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RAPIDTask(const RAPIDTask& from);
  RAPIDTask(RAPIDTask&& from) noexcept
    : RAPIDTask() {
    *this = ::std::move(from);
  }

  inline RAPIDTask& operator=(const RAPIDTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline RAPIDTask& operator=(RAPIDTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RAPIDTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const RAPIDTask* internal_default_instance() {
    return reinterpret_cast<const RAPIDTask*>(
               &_RAPIDTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RAPIDTask& a, RAPIDTask& b) {
    a.Swap(&b);
  }
  inline void Swap(RAPIDTask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RAPIDTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RAPIDTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RAPIDTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RAPIDTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RAPIDTask& from) {
    RAPIDTask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RAPIDTask* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.robot.RAPIDTask";
  }
  protected:
  explicit RAPIDTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RAPIDTask_ExecutionState ExecutionState;
  static constexpr ExecutionState UNKNOWN =
    RAPIDTask_ExecutionState_UNKNOWN;
  static constexpr ExecutionState READY =
    RAPIDTask_ExecutionState_READY;
  static constexpr ExecutionState STOPPED =
    RAPIDTask_ExecutionState_STOPPED;
  static constexpr ExecutionState STARTED =
    RAPIDTask_ExecutionState_STARTED;
  static constexpr ExecutionState UNINITIALIZED =
    RAPIDTask_ExecutionState_UNINITIALIZED;
  static inline bool ExecutionState_IsValid(int value) {
    return RAPIDTask_ExecutionState_IsValid(value);
  }
  static constexpr ExecutionState ExecutionState_MIN =
    RAPIDTask_ExecutionState_ExecutionState_MIN;
  static constexpr ExecutionState ExecutionState_MAX =
    RAPIDTask_ExecutionState_ExecutionState_MAX;
  static constexpr int ExecutionState_ARRAYSIZE =
    RAPIDTask_ExecutionState_ExecutionState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ExecutionState_descriptor() {
    return RAPIDTask_ExecutionState_descriptor();
  }
  template<typename T>
  static inline const std::string& ExecutionState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExecutionState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExecutionState_Name.");
    return RAPIDTask_ExecutionState_Name(enum_t_value);
  }
  static inline bool ExecutionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ExecutionState* value) {
    return RAPIDTask_ExecutionState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModulesFieldNumber = 5,
    kNameFieldNumber = 1,
    kIsMotionTaskFieldNumber = 2,
    kIsActiveFieldNumber = 3,
    kExecutionStateFieldNumber = 4,
  };
  // repeated .abb.robot.RAPIDModule modules = 5;
  int modules_size() const;
  private:
  int _internal_modules_size() const;
  public:
  void clear_modules();
  ::abb::robot::RAPIDModule* mutable_modules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::RAPIDModule >*
      mutable_modules();
  private:
  const ::abb::robot::RAPIDModule& _internal_modules(int index) const;
  ::abb::robot::RAPIDModule* _internal_add_modules();
  public:
  const ::abb::robot::RAPIDModule& modules(int index) const;
  ::abb::robot::RAPIDModule* add_modules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::RAPIDModule >&
      modules() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool is_motion_task = 2;
  bool has_is_motion_task() const;
  private:
  bool _internal_has_is_motion_task() const;
  public:
  void clear_is_motion_task();
  bool is_motion_task() const;
  void set_is_motion_task(bool value);
  private:
  bool _internal_is_motion_task() const;
  void _internal_set_is_motion_task(bool value);
  public:

  // optional bool is_active = 3;
  bool has_is_active() const;
  private:
  bool _internal_has_is_active() const;
  public:
  void clear_is_active();
  bool is_active() const;
  void set_is_active(bool value);
  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);
  public:

  // optional .abb.robot.RAPIDTask.ExecutionState execution_state = 4 [default = UNKNOWN];
  bool has_execution_state() const;
  private:
  bool _internal_has_execution_state() const;
  public:
  void clear_execution_state();
  ::abb::robot::RAPIDTask_ExecutionState execution_state() const;
  void set_execution_state(::abb::robot::RAPIDTask_ExecutionState value);
  private:
  ::abb::robot::RAPIDTask_ExecutionState _internal_execution_state() const;
  void _internal_set_execution_state(::abb::robot::RAPIDTask_ExecutionState value);
  public:

  // @@protoc_insertion_point(class_scope:abb.robot.RAPIDTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::RAPIDModule > modules_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool is_motion_task_;
    bool is_active_;
    int execution_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_5fcontroller_5fdescription_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// optional string ip_address = 1;
inline bool Header::_internal_has_ip_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Header::has_ip_address() const {
  return _internal_has_ip_address();
}
inline void Header::clear_ip_address() {
  _impl_.ip_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Header::ip_address() const {
  // @@protoc_insertion_point(field_get:abb.robot.Header.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_ip_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ip_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.Header.ip_address)
}
inline std::string* Header::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.ip_address)
  return _s;
}
inline const std::string& Header::_internal_ip_address() const {
  return _impl_.ip_address_.Get();
}
inline void Header::_internal_set_ip_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_ip_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ip_address_.Mutable(GetArenaForAllocation());
}
inline std::string* Header::release_ip_address() {
  // @@protoc_insertion_point(field_release:abb.robot.Header.ip_address)
  if (!_internal_has_ip_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ip_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Header::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ip_address_.SetAllocated(ip_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Header.ip_address)
}

// optional uint32 rws_port_number = 2;
inline bool Header::_internal_has_rws_port_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Header::has_rws_port_number() const {
  return _internal_has_rws_port_number();
}
inline void Header::clear_rws_port_number() {
  _impl_.rws_port_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t Header::_internal_rws_port_number() const {
  return _impl_.rws_port_number_;
}
inline uint32_t Header::rws_port_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.Header.rws_port_number)
  return _internal_rws_port_number();
}
inline void Header::_internal_set_rws_port_number(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rws_port_number_ = value;
}
inline void Header::set_rws_port_number(uint32_t value) {
  _internal_set_rws_port_number(value);
  // @@protoc_insertion_point(field_set:abb.robot.Header.rws_port_number)
}

// optional .abb.robot.RobotWareVersion robot_ware_version = 3;
inline bool Header::_internal_has_robot_ware_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ware_version_ != nullptr);
  return value;
}
inline bool Header::has_robot_ware_version() const {
  return _internal_has_robot_ware_version();
}
inline void Header::clear_robot_ware_version() {
  if (_impl_.robot_ware_version_ != nullptr) _impl_.robot_ware_version_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::robot::RobotWareVersion& Header::_internal_robot_ware_version() const {
  const ::abb::robot::RobotWareVersion* p = _impl_.robot_ware_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::RobotWareVersion&>(
      ::abb::robot::_RobotWareVersion_default_instance_);
}
inline const ::abb::robot::RobotWareVersion& Header::robot_ware_version() const {
  // @@protoc_insertion_point(field_get:abb.robot.Header.robot_ware_version)
  return _internal_robot_ware_version();
}
inline void Header::unsafe_arena_set_allocated_robot_ware_version(
    ::abb::robot::RobotWareVersion* robot_ware_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_ware_version_);
  }
  _impl_.robot_ware_version_ = robot_ware_version;
  if (robot_ware_version) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Header.robot_ware_version)
}
inline ::abb::robot::RobotWareVersion* Header::release_robot_ware_version() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::robot::RobotWareVersion* temp = _impl_.robot_ware_version_;
  _impl_.robot_ware_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::RobotWareVersion* Header::unsafe_arena_release_robot_ware_version() {
  // @@protoc_insertion_point(field_release:abb.robot.Header.robot_ware_version)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::robot::RobotWareVersion* temp = _impl_.robot_ware_version_;
  _impl_.robot_ware_version_ = nullptr;
  return temp;
}
inline ::abb::robot::RobotWareVersion* Header::_internal_mutable_robot_ware_version() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.robot_ware_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::RobotWareVersion>(GetArenaForAllocation());
    _impl_.robot_ware_version_ = p;
  }
  return _impl_.robot_ware_version_;
}
inline ::abb::robot::RobotWareVersion* Header::mutable_robot_ware_version() {
  ::abb::robot::RobotWareVersion* _msg = _internal_mutable_robot_ware_version();
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.robot_ware_version)
  return _msg;
}
inline void Header::set_allocated_robot_ware_version(::abb::robot::RobotWareVersion* robot_ware_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_ware_version_;
  }
  if (robot_ware_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot_ware_version);
    if (message_arena != submessage_arena) {
      robot_ware_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_ware_version, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.robot_ware_version_ = robot_ware_version;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Header.robot_ware_version)
}

// optional string system_name = 4;
inline bool Header::_internal_has_system_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Header::has_system_name() const {
  return _internal_has_system_name();
}
inline void Header::clear_system_name() {
  _impl_.system_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Header::system_name() const {
  // @@protoc_insertion_point(field_get:abb.robot.Header.system_name)
  return _internal_system_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_system_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.system_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.Header.system_name)
}
inline std::string* Header::mutable_system_name() {
  std::string* _s = _internal_mutable_system_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.system_name)
  return _s;
}
inline const std::string& Header::_internal_system_name() const {
  return _impl_.system_name_.Get();
}
inline void Header::_internal_set_system_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.system_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_system_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.system_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Header::release_system_name() {
  // @@protoc_insertion_point(field_release:abb.robot.Header.system_name)
  if (!_internal_has_system_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.system_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.system_name_.IsDefault()) {
    _impl_.system_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Header::set_allocated_system_name(std::string* system_name) {
  if (system_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.system_name_.SetAllocated(system_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.system_name_.IsDefault()) {
    _impl_.system_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Header.system_name)
}

// optional string system_type = 5;
inline bool Header::_internal_has_system_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Header::has_system_type() const {
  return _internal_has_system_type();
}
inline void Header::clear_system_type() {
  _impl_.system_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Header::system_type() const {
  // @@protoc_insertion_point(field_get:abb.robot.Header.system_type)
  return _internal_system_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_system_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.system_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.Header.system_type)
}
inline std::string* Header::mutable_system_type() {
  std::string* _s = _internal_mutable_system_type();
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.system_type)
  return _s;
}
inline const std::string& Header::_internal_system_type() const {
  return _impl_.system_type_.Get();
}
inline void Header::_internal_set_system_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.system_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_system_type() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.system_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Header::release_system_type() {
  // @@protoc_insertion_point(field_release:abb.robot.Header.system_type)
  if (!_internal_has_system_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.system_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.system_type_.IsDefault()) {
    _impl_.system_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Header::set_allocated_system_type(std::string* system_type) {
  if (system_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.system_type_.SetAllocated(system_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.system_type_.IsDefault()) {
    _impl_.system_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Header.system_type)
}

// repeated string options = 6;
inline int Header::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int Header::options_size() const {
  return _internal_options_size();
}
inline void Header::clear_options() {
  _impl_.options_.Clear();
}
inline std::string* Header::add_options() {
  std::string* _s = _internal_add_options();
  // @@protoc_insertion_point(field_add_mutable:abb.robot.Header.options)
  return _s;
}
inline const std::string& Header::_internal_options(int index) const {
  return _impl_.options_.Get(index);
}
inline const std::string& Header::options(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.Header.options)
  return _internal_options(index);
}
inline std::string* Header::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.options)
  return _impl_.options_.Mutable(index);
}
inline void Header::set_options(int index, const std::string& value) {
  _impl_.options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:abb.robot.Header.options)
}
inline void Header::set_options(int index, std::string&& value) {
  _impl_.options_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:abb.robot.Header.options)
}
inline void Header::set_options(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:abb.robot.Header.options)
}
inline void Header::set_options(int index, const char* value, size_t size) {
  _impl_.options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Header.options)
}
inline std::string* Header::_internal_add_options() {
  return _impl_.options_.Add();
}
inline void Header::add_options(const std::string& value) {
  _impl_.options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:abb.robot.Header.options)
}
inline void Header::add_options(std::string&& value) {
  _impl_.options_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:abb.robot.Header.options)
}
inline void Header::add_options(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:abb.robot.Header.options)
}
inline void Header::add_options(const char* value, size_t size) {
  _impl_.options_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:abb.robot.Header.options)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Header::options() const {
  // @@protoc_insertion_point(field_list:abb.robot.Header.options)
  return _impl_.options_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Header::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.Header.options)
  return &_impl_.options_;
}

// -------------------------------------------------------------------

// RobotControllerDescription

// optional .abb.robot.Header header = 1;
inline bool RobotControllerDescription::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline bool RobotControllerDescription::has_header() const {
  return _internal_has_header();
}
inline void RobotControllerDescription::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::robot::Header& RobotControllerDescription::_internal_header() const {
  const ::abb::robot::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Header&>(
      ::abb::robot::_Header_default_instance_);
}
inline const ::abb::robot::Header& RobotControllerDescription::header() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotControllerDescription.header)
  return _internal_header();
}
inline void RobotControllerDescription::unsafe_arena_set_allocated_header(
    ::abb::robot::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.RobotControllerDescription.header)
}
inline ::abb::robot::Header* RobotControllerDescription::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::robot::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::Header* RobotControllerDescription::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:abb.robot.RobotControllerDescription.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::robot::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::abb::robot::Header* RobotControllerDescription::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::abb::robot::Header* RobotControllerDescription::mutable_header() {
  ::abb::robot::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotControllerDescription.header)
  return _msg;
}
inline void RobotControllerDescription::set_allocated_header(::abb::robot::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RobotControllerDescription.header)
}

// optional .abb.robot.SystemIndicators system_indicators = 2;
inline bool RobotControllerDescription::_internal_has_system_indicators() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_indicators_ != nullptr);
  return value;
}
inline bool RobotControllerDescription::has_system_indicators() const {
  return _internal_has_system_indicators();
}
inline void RobotControllerDescription::clear_system_indicators() {
  if (_impl_.system_indicators_ != nullptr) _impl_.system_indicators_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::robot::SystemIndicators& RobotControllerDescription::_internal_system_indicators() const {
  const ::abb::robot::SystemIndicators* p = _impl_.system_indicators_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::SystemIndicators&>(
      ::abb::robot::_SystemIndicators_default_instance_);
}
inline const ::abb::robot::SystemIndicators& RobotControllerDescription::system_indicators() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotControllerDescription.system_indicators)
  return _internal_system_indicators();
}
inline void RobotControllerDescription::unsafe_arena_set_allocated_system_indicators(
    ::abb::robot::SystemIndicators* system_indicators) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_indicators_);
  }
  _impl_.system_indicators_ = system_indicators;
  if (system_indicators) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.RobotControllerDescription.system_indicators)
}
inline ::abb::robot::SystemIndicators* RobotControllerDescription::release_system_indicators() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::SystemIndicators* temp = _impl_.system_indicators_;
  _impl_.system_indicators_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::SystemIndicators* RobotControllerDescription::unsafe_arena_release_system_indicators() {
  // @@protoc_insertion_point(field_release:abb.robot.RobotControllerDescription.system_indicators)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::SystemIndicators* temp = _impl_.system_indicators_;
  _impl_.system_indicators_ = nullptr;
  return temp;
}
inline ::abb::robot::SystemIndicators* RobotControllerDescription::_internal_mutable_system_indicators() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.system_indicators_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::SystemIndicators>(GetArenaForAllocation());
    _impl_.system_indicators_ = p;
  }
  return _impl_.system_indicators_;
}
inline ::abb::robot::SystemIndicators* RobotControllerDescription::mutable_system_indicators() {
  ::abb::robot::SystemIndicators* _msg = _internal_mutable_system_indicators();
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotControllerDescription.system_indicators)
  return _msg;
}
inline void RobotControllerDescription::set_allocated_system_indicators(::abb::robot::SystemIndicators* system_indicators) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.system_indicators_;
  }
  if (system_indicators) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(system_indicators);
    if (message_arena != submessage_arena) {
      system_indicators = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_indicators, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.system_indicators_ = system_indicators;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RobotControllerDescription.system_indicators)
}

// repeated .abb.robot.MechanicalUnitGroup mechanical_units_groups = 3;
inline int RobotControllerDescription::_internal_mechanical_units_groups_size() const {
  return _impl_.mechanical_units_groups_.size();
}
inline int RobotControllerDescription::mechanical_units_groups_size() const {
  return _internal_mechanical_units_groups_size();
}
inline void RobotControllerDescription::clear_mechanical_units_groups() {
  _impl_.mechanical_units_groups_.Clear();
}
inline ::abb::robot::MechanicalUnitGroup* RobotControllerDescription::mutable_mechanical_units_groups(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return _impl_.mechanical_units_groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup >*
RobotControllerDescription::mutable_mechanical_units_groups() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return &_impl_.mechanical_units_groups_;
}
inline const ::abb::robot::MechanicalUnitGroup& RobotControllerDescription::_internal_mechanical_units_groups(int index) const {
  return _impl_.mechanical_units_groups_.Get(index);
}
inline const ::abb::robot::MechanicalUnitGroup& RobotControllerDescription::mechanical_units_groups(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return _internal_mechanical_units_groups(index);
}
inline ::abb::robot::MechanicalUnitGroup* RobotControllerDescription::_internal_add_mechanical_units_groups() {
  return _impl_.mechanical_units_groups_.Add();
}
inline ::abb::robot::MechanicalUnitGroup* RobotControllerDescription::add_mechanical_units_groups() {
  ::abb::robot::MechanicalUnitGroup* _add = _internal_add_mechanical_units_groups();
  // @@protoc_insertion_point(field_add:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup >&
RobotControllerDescription::mechanical_units_groups() const {
  // @@protoc_insertion_point(field_list:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return _impl_.mechanical_units_groups_;
}

// repeated .abb.robot.RAPIDTask rapid_tasks = 4;
inline int RobotControllerDescription::_internal_rapid_tasks_size() const {
  return _impl_.rapid_tasks_.size();
}
inline int RobotControllerDescription::rapid_tasks_size() const {
  return _internal_rapid_tasks_size();
}
inline void RobotControllerDescription::clear_rapid_tasks() {
  _impl_.rapid_tasks_.Clear();
}
inline ::abb::robot::RAPIDTask* RobotControllerDescription::mutable_rapid_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotControllerDescription.rapid_tasks)
  return _impl_.rapid_tasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::RAPIDTask >*
RobotControllerDescription::mutable_rapid_tasks() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.RobotControllerDescription.rapid_tasks)
  return &_impl_.rapid_tasks_;
}
inline const ::abb::robot::RAPIDTask& RobotControllerDescription::_internal_rapid_tasks(int index) const {
  return _impl_.rapid_tasks_.Get(index);
}
inline const ::abb::robot::RAPIDTask& RobotControllerDescription::rapid_tasks(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotControllerDescription.rapid_tasks)
  return _internal_rapid_tasks(index);
}
inline ::abb::robot::RAPIDTask* RobotControllerDescription::_internal_add_rapid_tasks() {
  return _impl_.rapid_tasks_.Add();
}
inline ::abb::robot::RAPIDTask* RobotControllerDescription::add_rapid_tasks() {
  ::abb::robot::RAPIDTask* _add = _internal_add_rapid_tasks();
  // @@protoc_insertion_point(field_add:abb.robot.RobotControllerDescription.rapid_tasks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::RAPIDTask >&
RobotControllerDescription::rapid_tasks() const {
  // @@protoc_insertion_point(field_list:abb.robot.RobotControllerDescription.rapid_tasks)
  return _impl_.rapid_tasks_;
}

// -------------------------------------------------------------------

// RobotWareVersion

// optional string name = 1;
inline bool RobotWareVersion::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotWareVersion::has_name() const {
  return _internal_has_name();
}
inline void RobotWareVersion::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RobotWareVersion::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotWareVersion.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotWareVersion::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.RobotWareVersion.name)
}
inline std::string* RobotWareVersion::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotWareVersion.name)
  return _s;
}
inline const std::string& RobotWareVersion::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RobotWareVersion::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotWareVersion::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotWareVersion::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.RobotWareVersion.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RobotWareVersion::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RobotWareVersion.name)
}

// optional uint32 major_number = 2;
inline bool RobotWareVersion::_internal_has_major_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RobotWareVersion::has_major_number() const {
  return _internal_has_major_number();
}
inline void RobotWareVersion::clear_major_number() {
  _impl_.major_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RobotWareVersion::_internal_major_number() const {
  return _impl_.major_number_;
}
inline uint32_t RobotWareVersion::major_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotWareVersion.major_number)
  return _internal_major_number();
}
inline void RobotWareVersion::_internal_set_major_number(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.major_number_ = value;
}
inline void RobotWareVersion::set_major_number(uint32_t value) {
  _internal_set_major_number(value);
  // @@protoc_insertion_point(field_set:abb.robot.RobotWareVersion.major_number)
}

// optional uint32 minor_number = 3;
inline bool RobotWareVersion::_internal_has_minor_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RobotWareVersion::has_minor_number() const {
  return _internal_has_minor_number();
}
inline void RobotWareVersion::clear_minor_number() {
  _impl_.minor_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RobotWareVersion::_internal_minor_number() const {
  return _impl_.minor_number_;
}
inline uint32_t RobotWareVersion::minor_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotWareVersion.minor_number)
  return _internal_minor_number();
}
inline void RobotWareVersion::_internal_set_minor_number(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.minor_number_ = value;
}
inline void RobotWareVersion::set_minor_number(uint32_t value) {
  _internal_set_minor_number(value);
  // @@protoc_insertion_point(field_set:abb.robot.RobotWareVersion.minor_number)
}

// optional uint32 patch_number = 4;
inline bool RobotWareVersion::_internal_has_patch_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RobotWareVersion::has_patch_number() const {
  return _internal_has_patch_number();
}
inline void RobotWareVersion::clear_patch_number() {
  _impl_.patch_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RobotWareVersion::_internal_patch_number() const {
  return _impl_.patch_number_;
}
inline uint32_t RobotWareVersion::patch_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotWareVersion.patch_number)
  return _internal_patch_number();
}
inline void RobotWareVersion::_internal_set_patch_number(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.patch_number_ = value;
}
inline void RobotWareVersion::set_patch_number(uint32_t value) {
  _internal_set_patch_number(value);
  // @@protoc_insertion_point(field_set:abb.robot.RobotWareVersion.patch_number)
}

// -------------------------------------------------------------------

// Cartesian

// optional double x = 1;
inline bool Cartesian::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Cartesian::has_x() const {
  return _internal_has_x();
}
inline void Cartesian::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Cartesian::_internal_x() const {
  return _impl_.x_;
}
inline double Cartesian::x() const {
  // @@protoc_insertion_point(field_get:abb.robot.Cartesian.x)
  return _internal_x();
}
inline void Cartesian::_internal_set_x(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void Cartesian::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.robot.Cartesian.x)
}

// optional double y = 2;
inline bool Cartesian::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Cartesian::has_y() const {
  return _internal_has_y();
}
inline void Cartesian::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Cartesian::_internal_y() const {
  return _impl_.y_;
}
inline double Cartesian::y() const {
  // @@protoc_insertion_point(field_get:abb.robot.Cartesian.y)
  return _internal_y();
}
inline void Cartesian::_internal_set_y(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void Cartesian::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.robot.Cartesian.y)
}

// optional double z = 3;
inline bool Cartesian::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Cartesian::has_z() const {
  return _internal_has_z();
}
inline void Cartesian::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Cartesian::_internal_z() const {
  return _impl_.z_;
}
inline double Cartesian::z() const {
  // @@protoc_insertion_point(field_get:abb.robot.Cartesian.z)
  return _internal_z();
}
inline void Cartesian::_internal_set_z(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void Cartesian::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.robot.Cartesian.z)
}

// -------------------------------------------------------------------

// Quaternion

// optional double q1 = 1;
inline bool Quaternion::_internal_has_q1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Quaternion::has_q1() const {
  return _internal_has_q1();
}
inline void Quaternion::clear_q1() {
  _impl_.q1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Quaternion::_internal_q1() const {
  return _impl_.q1_;
}
inline double Quaternion::q1() const {
  // @@protoc_insertion_point(field_get:abb.robot.Quaternion.q1)
  return _internal_q1();
}
inline void Quaternion::_internal_set_q1(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.q1_ = value;
}
inline void Quaternion::set_q1(double value) {
  _internal_set_q1(value);
  // @@protoc_insertion_point(field_set:abb.robot.Quaternion.q1)
}

// optional double q2 = 2;
inline bool Quaternion::_internal_has_q2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Quaternion::has_q2() const {
  return _internal_has_q2();
}
inline void Quaternion::clear_q2() {
  _impl_.q2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Quaternion::_internal_q2() const {
  return _impl_.q2_;
}
inline double Quaternion::q2() const {
  // @@protoc_insertion_point(field_get:abb.robot.Quaternion.q2)
  return _internal_q2();
}
inline void Quaternion::_internal_set_q2(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.q2_ = value;
}
inline void Quaternion::set_q2(double value) {
  _internal_set_q2(value);
  // @@protoc_insertion_point(field_set:abb.robot.Quaternion.q2)
}

// optional double q3 = 3;
inline bool Quaternion::_internal_has_q3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Quaternion::has_q3() const {
  return _internal_has_q3();
}
inline void Quaternion::clear_q3() {
  _impl_.q3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Quaternion::_internal_q3() const {
  return _impl_.q3_;
}
inline double Quaternion::q3() const {
  // @@protoc_insertion_point(field_get:abb.robot.Quaternion.q3)
  return _internal_q3();
}
inline void Quaternion::_internal_set_q3(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.q3_ = value;
}
inline void Quaternion::set_q3(double value) {
  _internal_set_q3(value);
  // @@protoc_insertion_point(field_set:abb.robot.Quaternion.q3)
}

// optional double q4 = 4;
inline bool Quaternion::_internal_has_q4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Quaternion::has_q4() const {
  return _internal_has_q4();
}
inline void Quaternion::clear_q4() {
  _impl_.q4_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double Quaternion::_internal_q4() const {
  return _impl_.q4_;
}
inline double Quaternion::q4() const {
  // @@protoc_insertion_point(field_get:abb.robot.Quaternion.q4)
  return _internal_q4();
}
inline void Quaternion::_internal_set_q4(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.q4_ = value;
}
inline void Quaternion::set_q4(double value) {
  _internal_set_q4(value);
  // @@protoc_insertion_point(field_set:abb.robot.Quaternion.q4)
}

// -------------------------------------------------------------------

// Pose

// optional .abb.robot.Cartesian position = 1;
inline bool Pose::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool Pose::has_position() const {
  return _internal_has_position();
}
inline void Pose::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::robot::Cartesian& Pose::_internal_position() const {
  const ::abb::robot::Cartesian* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Cartesian&>(
      ::abb::robot::_Cartesian_default_instance_);
}
inline const ::abb::robot::Cartesian& Pose::position() const {
  // @@protoc_insertion_point(field_get:abb.robot.Pose.position)
  return _internal_position();
}
inline void Pose::unsafe_arena_set_allocated_position(
    ::abb::robot::Cartesian* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Pose.position)
}
inline ::abb::robot::Cartesian* Pose::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::robot::Cartesian* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::Cartesian* Pose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:abb.robot.Pose.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::robot::Cartesian* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::abb::robot::Cartesian* Pose::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Cartesian>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::abb::robot::Cartesian* Pose::mutable_position() {
  ::abb::robot::Cartesian* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:abb.robot.Pose.position)
  return _msg;
}
inline void Pose::set_allocated_position(::abb::robot::Cartesian* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Pose.position)
}

// optional .abb.robot.Quaternion rotation = 2;
inline bool Pose::_internal_has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline bool Pose::has_rotation() const {
  return _internal_has_rotation();
}
inline void Pose::clear_rotation() {
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::robot::Quaternion& Pose::_internal_rotation() const {
  const ::abb::robot::Quaternion* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Quaternion&>(
      ::abb::robot::_Quaternion_default_instance_);
}
inline const ::abb::robot::Quaternion& Pose::rotation() const {
  // @@protoc_insertion_point(field_get:abb.robot.Pose.rotation)
  return _internal_rotation();
}
inline void Pose::unsafe_arena_set_allocated_rotation(
    ::abb::robot::Quaternion* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Pose.rotation)
}
inline ::abb::robot::Quaternion* Pose::release_rotation() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::Quaternion* Pose::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:abb.robot.Pose.rotation)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::Quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::abb::robot::Quaternion* Pose::_internal_mutable_rotation() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Quaternion>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::abb::robot::Quaternion* Pose::mutable_rotation() {
  ::abb::robot::Quaternion* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:abb.robot.Pose.rotation)
  return _msg;
}
inline void Pose::set_allocated_rotation(::abb::robot::Quaternion* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Pose.rotation)
}

// -------------------------------------------------------------------

// RobotIndicators

// optional bool irb14000 = 1;
inline bool RobotIndicators::_internal_has_irb14000() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotIndicators::has_irb14000() const {
  return _internal_has_irb14000();
}
inline void RobotIndicators::clear_irb14000() {
  _impl_.irb14000_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool RobotIndicators::_internal_irb14000() const {
  return _impl_.irb14000_;
}
inline bool RobotIndicators::irb14000() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotIndicators.irb14000)
  return _internal_irb14000();
}
inline void RobotIndicators::_internal_set_irb14000(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.irb14000_ = value;
}
inline void RobotIndicators::set_irb14000(bool value) {
  _internal_set_irb14000(value);
  // @@protoc_insertion_point(field_set:abb.robot.RobotIndicators.irb14000)
}

// -------------------------------------------------------------------

// OptionIndicators

// optional bool egm = 1;
inline bool OptionIndicators::_internal_has_egm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OptionIndicators::has_egm() const {
  return _internal_has_egm();
}
inline void OptionIndicators::clear_egm() {
  _impl_.egm_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool OptionIndicators::_internal_egm() const {
  return _impl_.egm_;
}
inline bool OptionIndicators::egm() const {
  // @@protoc_insertion_point(field_get:abb.robot.OptionIndicators.egm)
  return _internal_egm();
}
inline void OptionIndicators::_internal_set_egm(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.egm_ = value;
}
inline void OptionIndicators::set_egm(bool value) {
  _internal_set_egm(value);
  // @@protoc_insertion_point(field_set:abb.robot.OptionIndicators.egm)
}

// optional bool leadthrough = 2;
inline bool OptionIndicators::_internal_has_leadthrough() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OptionIndicators::has_leadthrough() const {
  return _internal_has_leadthrough();
}
inline void OptionIndicators::clear_leadthrough() {
  _impl_.leadthrough_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool OptionIndicators::_internal_leadthrough() const {
  return _impl_.leadthrough_;
}
inline bool OptionIndicators::leadthrough() const {
  // @@protoc_insertion_point(field_get:abb.robot.OptionIndicators.leadthrough)
  return _internal_leadthrough();
}
inline void OptionIndicators::_internal_set_leadthrough(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.leadthrough_ = value;
}
inline void OptionIndicators::set_leadthrough(bool value) {
  _internal_set_leadthrough(value);
  // @@protoc_insertion_point(field_set:abb.robot.OptionIndicators.leadthrough)
}

// optional bool multimove = 3;
inline bool OptionIndicators::_internal_has_multimove() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OptionIndicators::has_multimove() const {
  return _internal_has_multimove();
}
inline void OptionIndicators::clear_multimove() {
  _impl_.multimove_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool OptionIndicators::_internal_multimove() const {
  return _impl_.multimove_;
}
inline bool OptionIndicators::multimove() const {
  // @@protoc_insertion_point(field_get:abb.robot.OptionIndicators.multimove)
  return _internal_multimove();
}
inline void OptionIndicators::_internal_set_multimove(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.multimove_ = value;
}
inline void OptionIndicators::set_multimove(bool value) {
  _internal_set_multimove(value);
  // @@protoc_insertion_point(field_set:abb.robot.OptionIndicators.multimove)
}

// -------------------------------------------------------------------

// AddInIndicators

// optional bool smart_gripper = 1;
inline bool AddInIndicators::_internal_has_smart_gripper() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AddInIndicators::has_smart_gripper() const {
  return _internal_has_smart_gripper();
}
inline void AddInIndicators::clear_smart_gripper() {
  _impl_.smart_gripper_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool AddInIndicators::_internal_smart_gripper() const {
  return _impl_.smart_gripper_;
}
inline bool AddInIndicators::smart_gripper() const {
  // @@protoc_insertion_point(field_get:abb.robot.AddInIndicators.smart_gripper)
  return _internal_smart_gripper();
}
inline void AddInIndicators::_internal_set_smart_gripper(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.smart_gripper_ = value;
}
inline void AddInIndicators::set_smart_gripper(bool value) {
  _internal_set_smart_gripper(value);
  // @@protoc_insertion_point(field_set:abb.robot.AddInIndicators.smart_gripper)
}

// optional bool state_machine_1_0 = 2;
inline bool AddInIndicators::_internal_has_state_machine_1_0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AddInIndicators::has_state_machine_1_0() const {
  return _internal_has_state_machine_1_0();
}
inline void AddInIndicators::clear_state_machine_1_0() {
  _impl_.state_machine_1_0_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool AddInIndicators::_internal_state_machine_1_0() const {
  return _impl_.state_machine_1_0_;
}
inline bool AddInIndicators::state_machine_1_0() const {
  // @@protoc_insertion_point(field_get:abb.robot.AddInIndicators.state_machine_1_0)
  return _internal_state_machine_1_0();
}
inline void AddInIndicators::_internal_set_state_machine_1_0(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_machine_1_0_ = value;
}
inline void AddInIndicators::set_state_machine_1_0(bool value) {
  _internal_set_state_machine_1_0(value);
  // @@protoc_insertion_point(field_set:abb.robot.AddInIndicators.state_machine_1_0)
}

// optional bool state_machine_1_1 = 3;
inline bool AddInIndicators::_internal_has_state_machine_1_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AddInIndicators::has_state_machine_1_1() const {
  return _internal_has_state_machine_1_1();
}
inline void AddInIndicators::clear_state_machine_1_1() {
  _impl_.state_machine_1_1_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool AddInIndicators::_internal_state_machine_1_1() const {
  return _impl_.state_machine_1_1_;
}
inline bool AddInIndicators::state_machine_1_1() const {
  // @@protoc_insertion_point(field_get:abb.robot.AddInIndicators.state_machine_1_1)
  return _internal_state_machine_1_1();
}
inline void AddInIndicators::_internal_set_state_machine_1_1(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.state_machine_1_1_ = value;
}
inline void AddInIndicators::set_state_machine_1_1(bool value) {
  _internal_set_state_machine_1_1(value);
  // @@protoc_insertion_point(field_set:abb.robot.AddInIndicators.state_machine_1_1)
}

// -------------------------------------------------------------------

// SystemIndicators

// optional .abb.robot.RobotIndicators robots = 1;
inline bool SystemIndicators::_internal_has_robots() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robots_ != nullptr);
  return value;
}
inline bool SystemIndicators::has_robots() const {
  return _internal_has_robots();
}
inline void SystemIndicators::clear_robots() {
  if (_impl_.robots_ != nullptr) _impl_.robots_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::robot::RobotIndicators& SystemIndicators::_internal_robots() const {
  const ::abb::robot::RobotIndicators* p = _impl_.robots_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::RobotIndicators&>(
      ::abb::robot::_RobotIndicators_default_instance_);
}
inline const ::abb::robot::RobotIndicators& SystemIndicators::robots() const {
  // @@protoc_insertion_point(field_get:abb.robot.SystemIndicators.robots)
  return _internal_robots();
}
inline void SystemIndicators::unsafe_arena_set_allocated_robots(
    ::abb::robot::RobotIndicators* robots) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robots_);
  }
  _impl_.robots_ = robots;
  if (robots) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.SystemIndicators.robots)
}
inline ::abb::robot::RobotIndicators* SystemIndicators::release_robots() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::robot::RobotIndicators* temp = _impl_.robots_;
  _impl_.robots_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::RobotIndicators* SystemIndicators::unsafe_arena_release_robots() {
  // @@protoc_insertion_point(field_release:abb.robot.SystemIndicators.robots)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::robot::RobotIndicators* temp = _impl_.robots_;
  _impl_.robots_ = nullptr;
  return temp;
}
inline ::abb::robot::RobotIndicators* SystemIndicators::_internal_mutable_robots() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.robots_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::RobotIndicators>(GetArenaForAllocation());
    _impl_.robots_ = p;
  }
  return _impl_.robots_;
}
inline ::abb::robot::RobotIndicators* SystemIndicators::mutable_robots() {
  ::abb::robot::RobotIndicators* _msg = _internal_mutable_robots();
  // @@protoc_insertion_point(field_mutable:abb.robot.SystemIndicators.robots)
  return _msg;
}
inline void SystemIndicators::set_allocated_robots(::abb::robot::RobotIndicators* robots) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robots_;
  }
  if (robots) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robots);
    if (message_arena != submessage_arena) {
      robots = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robots, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.robots_ = robots;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.SystemIndicators.robots)
}

// optional .abb.robot.OptionIndicators options = 2;
inline bool SystemIndicators::_internal_has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline bool SystemIndicators::has_options() const {
  return _internal_has_options();
}
inline void SystemIndicators::clear_options() {
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::robot::OptionIndicators& SystemIndicators::_internal_options() const {
  const ::abb::robot::OptionIndicators* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::OptionIndicators&>(
      ::abb::robot::_OptionIndicators_default_instance_);
}
inline const ::abb::robot::OptionIndicators& SystemIndicators::options() const {
  // @@protoc_insertion_point(field_get:abb.robot.SystemIndicators.options)
  return _internal_options();
}
inline void SystemIndicators::unsafe_arena_set_allocated_options(
    ::abb::robot::OptionIndicators* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.SystemIndicators.options)
}
inline ::abb::robot::OptionIndicators* SystemIndicators::release_options() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::OptionIndicators* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::OptionIndicators* SystemIndicators::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:abb.robot.SystemIndicators.options)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::OptionIndicators* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::abb::robot::OptionIndicators* SystemIndicators::_internal_mutable_options() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::OptionIndicators>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::abb::robot::OptionIndicators* SystemIndicators::mutable_options() {
  ::abb::robot::OptionIndicators* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:abb.robot.SystemIndicators.options)
  return _msg;
}
inline void SystemIndicators::set_allocated_options(::abb::robot::OptionIndicators* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.SystemIndicators.options)
}

// optional .abb.robot.AddInIndicators addins = 3;
inline bool SystemIndicators::_internal_has_addins() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.addins_ != nullptr);
  return value;
}
inline bool SystemIndicators::has_addins() const {
  return _internal_has_addins();
}
inline void SystemIndicators::clear_addins() {
  if (_impl_.addins_ != nullptr) _impl_.addins_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::robot::AddInIndicators& SystemIndicators::_internal_addins() const {
  const ::abb::robot::AddInIndicators* p = _impl_.addins_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::AddInIndicators&>(
      ::abb::robot::_AddInIndicators_default_instance_);
}
inline const ::abb::robot::AddInIndicators& SystemIndicators::addins() const {
  // @@protoc_insertion_point(field_get:abb.robot.SystemIndicators.addins)
  return _internal_addins();
}
inline void SystemIndicators::unsafe_arena_set_allocated_addins(
    ::abb::robot::AddInIndicators* addins) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.addins_);
  }
  _impl_.addins_ = addins;
  if (addins) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.SystemIndicators.addins)
}
inline ::abb::robot::AddInIndicators* SystemIndicators::release_addins() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::robot::AddInIndicators* temp = _impl_.addins_;
  _impl_.addins_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::AddInIndicators* SystemIndicators::unsafe_arena_release_addins() {
  // @@protoc_insertion_point(field_release:abb.robot.SystemIndicators.addins)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::robot::AddInIndicators* temp = _impl_.addins_;
  _impl_.addins_ = nullptr;
  return temp;
}
inline ::abb::robot::AddInIndicators* SystemIndicators::_internal_mutable_addins() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.addins_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::AddInIndicators>(GetArenaForAllocation());
    _impl_.addins_ = p;
  }
  return _impl_.addins_;
}
inline ::abb::robot::AddInIndicators* SystemIndicators::mutable_addins() {
  ::abb::robot::AddInIndicators* _msg = _internal_mutable_addins();
  // @@protoc_insertion_point(field_mutable:abb.robot.SystemIndicators.addins)
  return _msg;
}
inline void SystemIndicators::set_allocated_addins(::abb::robot::AddInIndicators* addins) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.addins_;
  }
  if (addins) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(addins);
    if (message_arena != submessage_arena) {
      addins = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addins, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.addins_ = addins;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.SystemIndicators.addins)
}

// -------------------------------------------------------------------

// Transmission

// optional string name = 1;
inline bool Transmission::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Transmission::has_name() const {
  return _internal_has_name();
}
inline void Transmission::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Transmission::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.Transmission.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transmission::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.Transmission.name)
}
inline std::string* Transmission::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Transmission.name)
  return _s;
}
inline const std::string& Transmission::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Transmission::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Transmission::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Transmission::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.Transmission.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Transmission::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Transmission.name)
}

// optional bool rotating_move = 2;
inline bool Transmission::_internal_has_rotating_move() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Transmission::has_rotating_move() const {
  return _internal_has_rotating_move();
}
inline void Transmission::clear_rotating_move() {
  _impl_.rotating_move_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Transmission::_internal_rotating_move() const {
  return _impl_.rotating_move_;
}
inline bool Transmission::rotating_move() const {
  // @@protoc_insertion_point(field_get:abb.robot.Transmission.rotating_move)
  return _internal_rotating_move();
}
inline void Transmission::_internal_set_rotating_move(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rotating_move_ = value;
}
inline void Transmission::set_rotating_move(bool value) {
  _internal_set_rotating_move(value);
  // @@protoc_insertion_point(field_set:abb.robot.Transmission.rotating_move)
}

// -------------------------------------------------------------------

// Arm

// optional string name = 1;
inline bool Arm::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Arm::has_name() const {
  return _internal_has_name();
}
inline void Arm::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Arm::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.Arm.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Arm::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.Arm.name)
}
inline std::string* Arm::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Arm.name)
  return _s;
}
inline const std::string& Arm::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Arm::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Arm::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Arm::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.Arm.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Arm::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Arm.name)
}

// optional double lower_joint_bound = 2;
inline bool Arm::_internal_has_lower_joint_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Arm::has_lower_joint_bound() const {
  return _internal_has_lower_joint_bound();
}
inline void Arm::clear_lower_joint_bound() {
  _impl_.lower_joint_bound_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Arm::_internal_lower_joint_bound() const {
  return _impl_.lower_joint_bound_;
}
inline double Arm::lower_joint_bound() const {
  // @@protoc_insertion_point(field_get:abb.robot.Arm.lower_joint_bound)
  return _internal_lower_joint_bound();
}
inline void Arm::_internal_set_lower_joint_bound(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.lower_joint_bound_ = value;
}
inline void Arm::set_lower_joint_bound(double value) {
  _internal_set_lower_joint_bound(value);
  // @@protoc_insertion_point(field_set:abb.robot.Arm.lower_joint_bound)
}

// optional double upper_joint_bound = 3;
inline bool Arm::_internal_has_upper_joint_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Arm::has_upper_joint_bound() const {
  return _internal_has_upper_joint_bound();
}
inline void Arm::clear_upper_joint_bound() {
  _impl_.upper_joint_bound_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Arm::_internal_upper_joint_bound() const {
  return _impl_.upper_joint_bound_;
}
inline double Arm::upper_joint_bound() const {
  // @@protoc_insertion_point(field_get:abb.robot.Arm.upper_joint_bound)
  return _internal_upper_joint_bound();
}
inline void Arm::_internal_set_upper_joint_bound(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.upper_joint_bound_ = value;
}
inline void Arm::set_upper_joint_bound(double value) {
  _internal_set_upper_joint_bound(value);
  // @@protoc_insertion_point(field_set:abb.robot.Arm.upper_joint_bound)
}

// -------------------------------------------------------------------

// Joint

// optional string name = 1;
inline bool Joint::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Joint::has_name() const {
  return _internal_has_name();
}
inline void Joint::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Joint::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Joint::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.Joint.name)
}
inline std::string* Joint::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Joint.name)
  return _s;
}
inline const std::string& Joint::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Joint::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Joint::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Joint::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.Joint.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Joint::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Joint.name)
}

// optional int32 logical_axis = 2;
inline bool Joint::_internal_has_logical_axis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Joint::has_logical_axis() const {
  return _internal_has_logical_axis();
}
inline void Joint::clear_logical_axis() {
  _impl_.logical_axis_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t Joint::_internal_logical_axis() const {
  return _impl_.logical_axis_;
}
inline int32_t Joint::logical_axis() const {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.logical_axis)
  return _internal_logical_axis();
}
inline void Joint::_internal_set_logical_axis(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.logical_axis_ = value;
}
inline void Joint::set_logical_axis(int32_t value) {
  _internal_set_logical_axis(value);
  // @@protoc_insertion_point(field_set:abb.robot.Joint.logical_axis)
}

// optional int32 kinematic_axis_number = 3;
inline bool Joint::_internal_has_kinematic_axis_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Joint::has_kinematic_axis_number() const {
  return _internal_has_kinematic_axis_number();
}
inline void Joint::clear_kinematic_axis_number() {
  _impl_.kinematic_axis_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t Joint::_internal_kinematic_axis_number() const {
  return _impl_.kinematic_axis_number_;
}
inline int32_t Joint::kinematic_axis_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.kinematic_axis_number)
  return _internal_kinematic_axis_number();
}
inline void Joint::_internal_set_kinematic_axis_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.kinematic_axis_number_ = value;
}
inline void Joint::set_kinematic_axis_number(int32_t value) {
  _internal_set_kinematic_axis_number(value);
  // @@protoc_insertion_point(field_set:abb.robot.Joint.kinematic_axis_number)
}

// optional .abb.robot.Arm arm = 4;
inline bool Joint::_internal_has_arm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arm_ != nullptr);
  return value;
}
inline bool Joint::has_arm() const {
  return _internal_has_arm();
}
inline void Joint::clear_arm() {
  if (_impl_.arm_ != nullptr) _impl_.arm_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::robot::Arm& Joint::_internal_arm() const {
  const ::abb::robot::Arm* p = _impl_.arm_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Arm&>(
      ::abb::robot::_Arm_default_instance_);
}
inline const ::abb::robot::Arm& Joint::arm() const {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.arm)
  return _internal_arm();
}
inline void Joint::unsafe_arena_set_allocated_arm(
    ::abb::robot::Arm* arm) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arm_);
  }
  _impl_.arm_ = arm;
  if (arm) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Joint.arm)
}
inline ::abb::robot::Arm* Joint::release_arm() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::Arm* temp = _impl_.arm_;
  _impl_.arm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::Arm* Joint::unsafe_arena_release_arm() {
  // @@protoc_insertion_point(field_release:abb.robot.Joint.arm)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::Arm* temp = _impl_.arm_;
  _impl_.arm_ = nullptr;
  return temp;
}
inline ::abb::robot::Arm* Joint::_internal_mutable_arm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.arm_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Arm>(GetArenaForAllocation());
    _impl_.arm_ = p;
  }
  return _impl_.arm_;
}
inline ::abb::robot::Arm* Joint::mutable_arm() {
  ::abb::robot::Arm* _msg = _internal_mutable_arm();
  // @@protoc_insertion_point(field_mutable:abb.robot.Joint.arm)
  return _msg;
}
inline void Joint::set_allocated_arm(::abb::robot::Arm* arm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arm_;
  }
  if (arm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arm);
    if (message_arena != submessage_arena) {
      arm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arm, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.arm_ = arm;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Joint.arm)
}

// optional .abb.robot.Transmission transmission = 5;
inline bool Joint::_internal_has_transmission() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transmission_ != nullptr);
  return value;
}
inline bool Joint::has_transmission() const {
  return _internal_has_transmission();
}
inline void Joint::clear_transmission() {
  if (_impl_.transmission_ != nullptr) _impl_.transmission_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::robot::Transmission& Joint::_internal_transmission() const {
  const ::abb::robot::Transmission* p = _impl_.transmission_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Transmission&>(
      ::abb::robot::_Transmission_default_instance_);
}
inline const ::abb::robot::Transmission& Joint::transmission() const {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.transmission)
  return _internal_transmission();
}
inline void Joint::unsafe_arena_set_allocated_transmission(
    ::abb::robot::Transmission* transmission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transmission_);
  }
  _impl_.transmission_ = transmission;
  if (transmission) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Joint.transmission)
}
inline ::abb::robot::Transmission* Joint::release_transmission() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::robot::Transmission* temp = _impl_.transmission_;
  _impl_.transmission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::Transmission* Joint::unsafe_arena_release_transmission() {
  // @@protoc_insertion_point(field_release:abb.robot.Joint.transmission)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::robot::Transmission* temp = _impl_.transmission_;
  _impl_.transmission_ = nullptr;
  return temp;
}
inline ::abb::robot::Transmission* Joint::_internal_mutable_transmission() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.transmission_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Transmission>(GetArenaForAllocation());
    _impl_.transmission_ = p;
  }
  return _impl_.transmission_;
}
inline ::abb::robot::Transmission* Joint::mutable_transmission() {
  ::abb::robot::Transmission* _msg = _internal_mutable_transmission();
  // @@protoc_insertion_point(field_mutable:abb.robot.Joint.transmission)
  return _msg;
}
inline void Joint::set_allocated_transmission(::abb::robot::Transmission* transmission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.transmission_;
  }
  if (transmission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transmission);
    if (message_arena != submessage_arena) {
      transmission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transmission, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.transmission_ = transmission;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Joint.transmission)
}

// -------------------------------------------------------------------

// StandardizedJoint

// optional string original_name = 1;
inline bool StandardizedJoint::_internal_has_original_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StandardizedJoint::has_original_name() const {
  return _internal_has_original_name();
}
inline void StandardizedJoint::clear_original_name() {
  _impl_.original_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StandardizedJoint::original_name() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.original_name)
  return _internal_original_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StandardizedJoint::set_original_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.original_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.original_name)
}
inline std::string* StandardizedJoint::mutable_original_name() {
  std::string* _s = _internal_mutable_original_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.StandardizedJoint.original_name)
  return _s;
}
inline const std::string& StandardizedJoint::_internal_original_name() const {
  return _impl_.original_name_.Get();
}
inline void StandardizedJoint::_internal_set_original_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.original_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StandardizedJoint::_internal_mutable_original_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.original_name_.Mutable(GetArenaForAllocation());
}
inline std::string* StandardizedJoint::release_original_name() {
  // @@protoc_insertion_point(field_release:abb.robot.StandardizedJoint.original_name)
  if (!_internal_has_original_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.original_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.original_name_.IsDefault()) {
    _impl_.original_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StandardizedJoint::set_allocated_original_name(std::string* original_name) {
  if (original_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.original_name_.SetAllocated(original_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.original_name_.IsDefault()) {
    _impl_.original_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.StandardizedJoint.original_name)
}

// optional string standardized_name = 2;
inline bool StandardizedJoint::_internal_has_standardized_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StandardizedJoint::has_standardized_name() const {
  return _internal_has_standardized_name();
}
inline void StandardizedJoint::clear_standardized_name() {
  _impl_.standardized_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StandardizedJoint::standardized_name() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.standardized_name)
  return _internal_standardized_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StandardizedJoint::set_standardized_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.standardized_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.standardized_name)
}
inline std::string* StandardizedJoint::mutable_standardized_name() {
  std::string* _s = _internal_mutable_standardized_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.StandardizedJoint.standardized_name)
  return _s;
}
inline const std::string& StandardizedJoint::_internal_standardized_name() const {
  return _impl_.standardized_name_.Get();
}
inline void StandardizedJoint::_internal_set_standardized_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.standardized_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StandardizedJoint::_internal_mutable_standardized_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.standardized_name_.Mutable(GetArenaForAllocation());
}
inline std::string* StandardizedJoint::release_standardized_name() {
  // @@protoc_insertion_point(field_release:abb.robot.StandardizedJoint.standardized_name)
  if (!_internal_has_standardized_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.standardized_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.standardized_name_.IsDefault()) {
    _impl_.standardized_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StandardizedJoint::set_allocated_standardized_name(std::string* standardized_name) {
  if (standardized_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.standardized_name_.SetAllocated(standardized_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.standardized_name_.IsDefault()) {
    _impl_.standardized_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.StandardizedJoint.standardized_name)
}

// optional bool rotating_move = 3;
inline bool StandardizedJoint::_internal_has_rotating_move() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StandardizedJoint::has_rotating_move() const {
  return _internal_has_rotating_move();
}
inline void StandardizedJoint::clear_rotating_move() {
  _impl_.rotating_move_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool StandardizedJoint::_internal_rotating_move() const {
  return _impl_.rotating_move_;
}
inline bool StandardizedJoint::rotating_move() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.rotating_move)
  return _internal_rotating_move();
}
inline void StandardizedJoint::_internal_set_rotating_move(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rotating_move_ = value;
}
inline void StandardizedJoint::set_rotating_move(bool value) {
  _internal_set_rotating_move(value);
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.rotating_move)
}

// optional double lower_joint_bound = 4;
inline bool StandardizedJoint::_internal_has_lower_joint_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StandardizedJoint::has_lower_joint_bound() const {
  return _internal_has_lower_joint_bound();
}
inline void StandardizedJoint::clear_lower_joint_bound() {
  _impl_.lower_joint_bound_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double StandardizedJoint::_internal_lower_joint_bound() const {
  return _impl_.lower_joint_bound_;
}
inline double StandardizedJoint::lower_joint_bound() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.lower_joint_bound)
  return _internal_lower_joint_bound();
}
inline void StandardizedJoint::_internal_set_lower_joint_bound(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lower_joint_bound_ = value;
}
inline void StandardizedJoint::set_lower_joint_bound(double value) {
  _internal_set_lower_joint_bound(value);
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.lower_joint_bound)
}

// optional double upper_joint_bound = 5;
inline bool StandardizedJoint::_internal_has_upper_joint_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StandardizedJoint::has_upper_joint_bound() const {
  return _internal_has_upper_joint_bound();
}
inline void StandardizedJoint::clear_upper_joint_bound() {
  _impl_.upper_joint_bound_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double StandardizedJoint::_internal_upper_joint_bound() const {
  return _impl_.upper_joint_bound_;
}
inline double StandardizedJoint::upper_joint_bound() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.upper_joint_bound)
  return _internal_upper_joint_bound();
}
inline void StandardizedJoint::_internal_set_upper_joint_bound(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.upper_joint_bound_ = value;
}
inline void StandardizedJoint::set_upper_joint_bound(double value) {
  _internal_set_upper_joint_bound(value);
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.upper_joint_bound)
}

// -------------------------------------------------------------------

// Single

// optional string name = 1;
inline bool Single::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Single::has_name() const {
  return _internal_has_name();
}
inline void Single::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Single::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.Single.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Single::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.Single.name)
}
inline std::string* Single::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.name)
  return _s;
}
inline const std::string& Single::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Single::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Single::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Single::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.Single.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Single::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.name)
}

// optional string type = 2;
inline bool Single::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Single::has_type() const {
  return _internal_has_type();
}
inline void Single::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Single::type() const {
  // @@protoc_insertion_point(field_get:abb.robot.Single.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Single::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.Single.type)
}
inline std::string* Single::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.type)
  return _s;
}
inline const std::string& Single::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Single::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Single::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Single::release_type() {
  // @@protoc_insertion_point(field_release:abb.robot.Single.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Single::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.type)
}

// optional .abb.robot.Joint joint = 3;
inline bool Single::_internal_has_joint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joint_ != nullptr);
  return value;
}
inline bool Single::has_joint() const {
  return _internal_has_joint();
}
inline void Single::clear_joint() {
  if (_impl_.joint_ != nullptr) _impl_.joint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::robot::Joint& Single::_internal_joint() const {
  const ::abb::robot::Joint* p = _impl_.joint_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Joint&>(
      ::abb::robot::_Joint_default_instance_);
}
inline const ::abb::robot::Joint& Single::joint() const {
  // @@protoc_insertion_point(field_get:abb.robot.Single.joint)
  return _internal_joint();
}
inline void Single::unsafe_arena_set_allocated_joint(
    ::abb::robot::Joint* joint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.joint_);
  }
  _impl_.joint_ = joint;
  if (joint) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Single.joint)
}
inline ::abb::robot::Joint* Single::release_joint() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::robot::Joint* temp = _impl_.joint_;
  _impl_.joint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::Joint* Single::unsafe_arena_release_joint() {
  // @@protoc_insertion_point(field_release:abb.robot.Single.joint)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::robot::Joint* temp = _impl_.joint_;
  _impl_.joint_ = nullptr;
  return temp;
}
inline ::abb::robot::Joint* Single::_internal_mutable_joint() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.joint_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Joint>(GetArenaForAllocation());
    _impl_.joint_ = p;
  }
  return _impl_.joint_;
}
inline ::abb::robot::Joint* Single::mutable_joint() {
  ::abb::robot::Joint* _msg = _internal_mutable_joint();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.joint)
  return _msg;
}
inline void Single::set_allocated_joint(::abb::robot::Joint* joint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.joint_;
  }
  if (joint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(joint);
    if (message_arena != submessage_arena) {
      joint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joint, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.joint_ = joint;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.joint)
}

// optional .abb.robot.Pose base_frame = 4;
inline bool Single::_internal_has_base_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_frame_ != nullptr);
  return value;
}
inline bool Single::has_base_frame() const {
  return _internal_has_base_frame();
}
inline void Single::clear_base_frame() {
  if (_impl_.base_frame_ != nullptr) _impl_.base_frame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::abb::robot::Pose& Single::_internal_base_frame() const {
  const ::abb::robot::Pose* p = _impl_.base_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Pose&>(
      ::abb::robot::_Pose_default_instance_);
}
inline const ::abb::robot::Pose& Single::base_frame() const {
  // @@protoc_insertion_point(field_get:abb.robot.Single.base_frame)
  return _internal_base_frame();
}
inline void Single::unsafe_arena_set_allocated_base_frame(
    ::abb::robot::Pose* base_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_frame_);
  }
  _impl_.base_frame_ = base_frame;
  if (base_frame) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Single.base_frame)
}
inline ::abb::robot::Pose* Single::release_base_frame() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::abb::robot::Pose* temp = _impl_.base_frame_;
  _impl_.base_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::Pose* Single::unsafe_arena_release_base_frame() {
  // @@protoc_insertion_point(field_release:abb.robot.Single.base_frame)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::abb::robot::Pose* temp = _impl_.base_frame_;
  _impl_.base_frame_ = nullptr;
  return temp;
}
inline ::abb::robot::Pose* Single::_internal_mutable_base_frame() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.base_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Pose>(GetArenaForAllocation());
    _impl_.base_frame_ = p;
  }
  return _impl_.base_frame_;
}
inline ::abb::robot::Pose* Single::mutable_base_frame() {
  ::abb::robot::Pose* _msg = _internal_mutable_base_frame();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.base_frame)
  return _msg;
}
inline void Single::set_allocated_base_frame(::abb::robot::Pose* base_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_frame_;
  }
  if (base_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base_frame);
    if (message_arena != submessage_arena) {
      base_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_frame, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.base_frame_ = base_frame;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.base_frame)
}

// optional string base_frame_moved_by = 5;
inline bool Single::_internal_has_base_frame_moved_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Single::has_base_frame_moved_by() const {
  return _internal_has_base_frame_moved_by();
}
inline void Single::clear_base_frame_moved_by() {
  _impl_.base_frame_moved_by_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Single::base_frame_moved_by() const {
  // @@protoc_insertion_point(field_get:abb.robot.Single.base_frame_moved_by)
  return _internal_base_frame_moved_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Single::set_base_frame_moved_by(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.base_frame_moved_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.Single.base_frame_moved_by)
}
inline std::string* Single::mutable_base_frame_moved_by() {
  std::string* _s = _internal_mutable_base_frame_moved_by();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.base_frame_moved_by)
  return _s;
}
inline const std::string& Single::_internal_base_frame_moved_by() const {
  return _impl_.base_frame_moved_by_.Get();
}
inline void Single::_internal_set_base_frame_moved_by(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.base_frame_moved_by_.Set(value, GetArenaForAllocation());
}
inline std::string* Single::_internal_mutable_base_frame_moved_by() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.base_frame_moved_by_.Mutable(GetArenaForAllocation());
}
inline std::string* Single::release_base_frame_moved_by() {
  // @@protoc_insertion_point(field_release:abb.robot.Single.base_frame_moved_by)
  if (!_internal_has_base_frame_moved_by()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.base_frame_moved_by_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_frame_moved_by_.IsDefault()) {
    _impl_.base_frame_moved_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Single::set_allocated_base_frame_moved_by(std::string* base_frame_moved_by) {
  if (base_frame_moved_by != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.base_frame_moved_by_.SetAllocated(base_frame_moved_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_frame_moved_by_.IsDefault()) {
    _impl_.base_frame_moved_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.base_frame_moved_by)
}

// -------------------------------------------------------------------

// Robot

// optional string name = 1;
inline bool Robot::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Robot::has_name() const {
  return _internal_has_name();
}
inline void Robot::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Robot::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.Robot.name)
}
inline std::string* Robot::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.name)
  return _s;
}
inline const std::string& Robot::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Robot::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Robot::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.Robot.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Robot::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Robot.name)
}

// optional string type = 2;
inline bool Robot::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Robot::has_type() const {
  return _internal_has_type();
}
inline void Robot::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Robot::type() const {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.Robot.type)
}
inline std::string* Robot::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.type)
  return _s;
}
inline const std::string& Robot::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Robot::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Robot::release_type() {
  // @@protoc_insertion_point(field_release:abb.robot.Robot.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Robot::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Robot.type)
}

// repeated .abb.robot.Joint joints = 3;
inline int Robot::_internal_joints_size() const {
  return _impl_.joints_.size();
}
inline int Robot::joints_size() const {
  return _internal_joints_size();
}
inline void Robot::clear_joints() {
  _impl_.joints_.Clear();
}
inline ::abb::robot::Joint* Robot::mutable_joints(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.joints)
  return _impl_.joints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::Joint >*
Robot::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.Robot.joints)
  return &_impl_.joints_;
}
inline const ::abb::robot::Joint& Robot::_internal_joints(int index) const {
  return _impl_.joints_.Get(index);
}
inline const ::abb::robot::Joint& Robot::joints(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.joints)
  return _internal_joints(index);
}
inline ::abb::robot::Joint* Robot::_internal_add_joints() {
  return _impl_.joints_.Add();
}
inline ::abb::robot::Joint* Robot::add_joints() {
  ::abb::robot::Joint* _add = _internal_add_joints();
  // @@protoc_insertion_point(field_add:abb.robot.Robot.joints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::Joint >&
Robot::joints() const {
  // @@protoc_insertion_point(field_list:abb.robot.Robot.joints)
  return _impl_.joints_;
}

// optional .abb.robot.Pose base_frame = 4;
inline bool Robot::_internal_has_base_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_frame_ != nullptr);
  return value;
}
inline bool Robot::has_base_frame() const {
  return _internal_has_base_frame();
}
inline void Robot::clear_base_frame() {
  if (_impl_.base_frame_ != nullptr) _impl_.base_frame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::robot::Pose& Robot::_internal_base_frame() const {
  const ::abb::robot::Pose* p = _impl_.base_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Pose&>(
      ::abb::robot::_Pose_default_instance_);
}
inline const ::abb::robot::Pose& Robot::base_frame() const {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.base_frame)
  return _internal_base_frame();
}
inline void Robot::unsafe_arena_set_allocated_base_frame(
    ::abb::robot::Pose* base_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_frame_);
  }
  _impl_.base_frame_ = base_frame;
  if (base_frame) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.Robot.base_frame)
}
inline ::abb::robot::Pose* Robot::release_base_frame() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::robot::Pose* temp = _impl_.base_frame_;
  _impl_.base_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::Pose* Robot::unsafe_arena_release_base_frame() {
  // @@protoc_insertion_point(field_release:abb.robot.Robot.base_frame)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::robot::Pose* temp = _impl_.base_frame_;
  _impl_.base_frame_ = nullptr;
  return temp;
}
inline ::abb::robot::Pose* Robot::_internal_mutable_base_frame() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.base_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Pose>(GetArenaForAllocation());
    _impl_.base_frame_ = p;
  }
  return _impl_.base_frame_;
}
inline ::abb::robot::Pose* Robot::mutable_base_frame() {
  ::abb::robot::Pose* _msg = _internal_mutable_base_frame();
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.base_frame)
  return _msg;
}
inline void Robot::set_allocated_base_frame(::abb::robot::Pose* base_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_frame_;
  }
  if (base_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base_frame);
    if (message_arena != submessage_arena) {
      base_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_frame, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.base_frame_ = base_frame;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Robot.base_frame)
}

// optional string base_frame_moved_by = 5;
inline bool Robot::_internal_has_base_frame_moved_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Robot::has_base_frame_moved_by() const {
  return _internal_has_base_frame_moved_by();
}
inline void Robot::clear_base_frame_moved_by() {
  _impl_.base_frame_moved_by_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Robot::base_frame_moved_by() const {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.base_frame_moved_by)
  return _internal_base_frame_moved_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_base_frame_moved_by(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.base_frame_moved_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.Robot.base_frame_moved_by)
}
inline std::string* Robot::mutable_base_frame_moved_by() {
  std::string* _s = _internal_mutable_base_frame_moved_by();
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.base_frame_moved_by)
  return _s;
}
inline const std::string& Robot::_internal_base_frame_moved_by() const {
  return _impl_.base_frame_moved_by_.Get();
}
inline void Robot::_internal_set_base_frame_moved_by(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.base_frame_moved_by_.Set(value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_base_frame_moved_by() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.base_frame_moved_by_.Mutable(GetArenaForAllocation());
}
inline std::string* Robot::release_base_frame_moved_by() {
  // @@protoc_insertion_point(field_release:abb.robot.Robot.base_frame_moved_by)
  if (!_internal_has_base_frame_moved_by()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.base_frame_moved_by_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_frame_moved_by_.IsDefault()) {
    _impl_.base_frame_moved_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Robot::set_allocated_base_frame_moved_by(std::string* base_frame_moved_by) {
  if (base_frame_moved_by != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.base_frame_moved_by_.SetAllocated(base_frame_moved_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_frame_moved_by_.IsDefault()) {
    _impl_.base_frame_moved_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Robot.base_frame_moved_by)
}

// -------------------------------------------------------------------

// MechanicalUnit

// optional string name = 1;
inline bool MechanicalUnit::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MechanicalUnit::has_name() const {
  return _internal_has_name();
}
inline void MechanicalUnit::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MechanicalUnit::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MechanicalUnit::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.name)
}
inline std::string* MechanicalUnit::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.name)
  return _s;
}
inline const std::string& MechanicalUnit::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MechanicalUnit::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MechanicalUnit::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MechanicalUnit::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MechanicalUnit::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.name)
}

// optional .abb.robot.Robot robot = 2;
inline bool MechanicalUnit::_internal_has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline bool MechanicalUnit::has_robot() const {
  return _internal_has_robot();
}
inline void MechanicalUnit::clear_robot() {
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::abb::robot::Robot& MechanicalUnit::_internal_robot() const {
  const ::abb::robot::Robot* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::Robot&>(
      ::abb::robot::_Robot_default_instance_);
}
inline const ::abb::robot::Robot& MechanicalUnit::robot() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.robot)
  return _internal_robot();
}
inline void MechanicalUnit::unsafe_arena_set_allocated_robot(
    ::abb::robot::Robot* robot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = robot;
  if (robot) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.MechanicalUnit.robot)
}
inline ::abb::robot::Robot* MechanicalUnit::release_robot() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::abb::robot::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::Robot* MechanicalUnit::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.robot)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::abb::robot::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::robot::Robot* MechanicalUnit::_internal_mutable_robot() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::Robot>(GetArenaForAllocation());
    _impl_.robot_ = p;
  }
  return _impl_.robot_;
}
inline ::abb::robot::Robot* MechanicalUnit::mutable_robot() {
  ::abb::robot::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.robot)
  return _msg;
}
inline void MechanicalUnit::set_allocated_robot(::abb::robot::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.robot)
}

// repeated .abb.robot.Single singles = 3;
inline int MechanicalUnit::_internal_singles_size() const {
  return _impl_.singles_.size();
}
inline int MechanicalUnit::singles_size() const {
  return _internal_singles_size();
}
inline void MechanicalUnit::clear_singles() {
  _impl_.singles_.Clear();
}
inline ::abb::robot::Single* MechanicalUnit::mutable_singles(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.singles)
  return _impl_.singles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::Single >*
MechanicalUnit::mutable_singles() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.MechanicalUnit.singles)
  return &_impl_.singles_;
}
inline const ::abb::robot::Single& MechanicalUnit::_internal_singles(int index) const {
  return _impl_.singles_.Get(index);
}
inline const ::abb::robot::Single& MechanicalUnit::singles(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.singles)
  return _internal_singles(index);
}
inline ::abb::robot::Single* MechanicalUnit::_internal_add_singles() {
  return _impl_.singles_.Add();
}
inline ::abb::robot::Single* MechanicalUnit::add_singles() {
  ::abb::robot::Single* _add = _internal_add_singles();
  // @@protoc_insertion_point(field_add:abb.robot.MechanicalUnit.singles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::Single >&
MechanicalUnit::singles() const {
  // @@protoc_insertion_point(field_list:abb.robot.MechanicalUnit.singles)
  return _impl_.singles_;
}

// optional .abb.robot.MechanicalUnit.Type type = 4 [default = UNDEFINED];
inline bool MechanicalUnit::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MechanicalUnit::has_type() const {
  return _internal_has_type();
}
inline void MechanicalUnit::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::abb::robot::MechanicalUnit_Type MechanicalUnit::_internal_type() const {
  return static_cast< ::abb::robot::MechanicalUnit_Type >(_impl_.type_);
}
inline ::abb::robot::MechanicalUnit_Type MechanicalUnit::type() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.type)
  return _internal_type();
}
inline void MechanicalUnit::_internal_set_type(::abb::robot::MechanicalUnit_Type value) {
  assert(::abb::robot::MechanicalUnit_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.type_ = value;
}
inline void MechanicalUnit::set_type(::abb::robot::MechanicalUnit_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.type)
}

// optional string task_name = 5;
inline bool MechanicalUnit::_internal_has_task_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MechanicalUnit::has_task_name() const {
  return _internal_has_task_name();
}
inline void MechanicalUnit::clear_task_name() {
  _impl_.task_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MechanicalUnit::task_name() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.task_name)
  return _internal_task_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MechanicalUnit::set_task_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.task_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.task_name)
}
inline std::string* MechanicalUnit::mutable_task_name() {
  std::string* _s = _internal_mutable_task_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.task_name)
  return _s;
}
inline const std::string& MechanicalUnit::_internal_task_name() const {
  return _impl_.task_name_.Get();
}
inline void MechanicalUnit::_internal_set_task_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.task_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MechanicalUnit::_internal_mutable_task_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.task_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MechanicalUnit::release_task_name() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.task_name)
  if (!_internal_has_task_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.task_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_name_.IsDefault()) {
    _impl_.task_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MechanicalUnit::set_allocated_task_name(std::string* task_name) {
  if (task_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.task_name_.SetAllocated(task_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_name_.IsDefault()) {
    _impl_.task_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.task_name)
}

// optional int32 axes = 6;
inline bool MechanicalUnit::_internal_has_axes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MechanicalUnit::has_axes() const {
  return _internal_has_axes();
}
inline void MechanicalUnit::clear_axes() {
  _impl_.axes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t MechanicalUnit::_internal_axes() const {
  return _impl_.axes_;
}
inline int32_t MechanicalUnit::axes() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.axes)
  return _internal_axes();
}
inline void MechanicalUnit::_internal_set_axes(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.axes_ = value;
}
inline void MechanicalUnit::set_axes(int32_t value) {
  _internal_set_axes(value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.axes)
}

// optional int32 axes_total = 7;
inline bool MechanicalUnit::_internal_has_axes_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MechanicalUnit::has_axes_total() const {
  return _internal_has_axes_total();
}
inline void MechanicalUnit::clear_axes_total() {
  _impl_.axes_total_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t MechanicalUnit::_internal_axes_total() const {
  return _impl_.axes_total_;
}
inline int32_t MechanicalUnit::axes_total() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.axes_total)
  return _internal_axes_total();
}
inline void MechanicalUnit::_internal_set_axes_total(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.axes_total_ = value;
}
inline void MechanicalUnit::set_axes_total(int32_t value) {
  _internal_set_axes_total(value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.axes_total)
}

// optional string is_integrated_unit = 8;
inline bool MechanicalUnit::_internal_has_is_integrated_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MechanicalUnit::has_is_integrated_unit() const {
  return _internal_has_is_integrated_unit();
}
inline void MechanicalUnit::clear_is_integrated_unit() {
  _impl_.is_integrated_unit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MechanicalUnit::is_integrated_unit() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.is_integrated_unit)
  return _internal_is_integrated_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MechanicalUnit::set_is_integrated_unit(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.is_integrated_unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.is_integrated_unit)
}
inline std::string* MechanicalUnit::mutable_is_integrated_unit() {
  std::string* _s = _internal_mutable_is_integrated_unit();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.is_integrated_unit)
  return _s;
}
inline const std::string& MechanicalUnit::_internal_is_integrated_unit() const {
  return _impl_.is_integrated_unit_.Get();
}
inline void MechanicalUnit::_internal_set_is_integrated_unit(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_integrated_unit_.Set(value, GetArenaForAllocation());
}
inline std::string* MechanicalUnit::_internal_mutable_is_integrated_unit() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.is_integrated_unit_.Mutable(GetArenaForAllocation());
}
inline std::string* MechanicalUnit::release_is_integrated_unit() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.is_integrated_unit)
  if (!_internal_has_is_integrated_unit()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.is_integrated_unit_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.is_integrated_unit_.IsDefault()) {
    _impl_.is_integrated_unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MechanicalUnit::set_allocated_is_integrated_unit(std::string* is_integrated_unit) {
  if (is_integrated_unit != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.is_integrated_unit_.SetAllocated(is_integrated_unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.is_integrated_unit_.IsDefault()) {
    _impl_.is_integrated_unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.is_integrated_unit)
}

// optional string has_integrated_unit = 9;
inline bool MechanicalUnit::_internal_has_has_integrated_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MechanicalUnit::has_has_integrated_unit() const {
  return _internal_has_has_integrated_unit();
}
inline void MechanicalUnit::clear_has_integrated_unit() {
  _impl_.has_integrated_unit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MechanicalUnit::has_integrated_unit() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.has_integrated_unit)
  return _internal_has_integrated_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MechanicalUnit::set_has_integrated_unit(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.has_integrated_unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.has_integrated_unit)
}
inline std::string* MechanicalUnit::mutable_has_integrated_unit() {
  std::string* _s = _internal_mutable_has_integrated_unit();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.has_integrated_unit)
  return _s;
}
inline const std::string& MechanicalUnit::_internal_has_integrated_unit() const {
  return _impl_.has_integrated_unit_.Get();
}
inline void MechanicalUnit::_internal_set_has_integrated_unit(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.has_integrated_unit_.Set(value, GetArenaForAllocation());
}
inline std::string* MechanicalUnit::_internal_mutable_has_integrated_unit() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.has_integrated_unit_.Mutable(GetArenaForAllocation());
}
inline std::string* MechanicalUnit::release_has_integrated_unit() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.has_integrated_unit)
  if (!_internal_has_has_integrated_unit()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.has_integrated_unit_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.has_integrated_unit_.IsDefault()) {
    _impl_.has_integrated_unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MechanicalUnit::set_allocated_has_integrated_unit(std::string* has_integrated_unit) {
  if (has_integrated_unit != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.has_integrated_unit_.SetAllocated(has_integrated_unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.has_integrated_unit_.IsDefault()) {
    _impl_.has_integrated_unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.has_integrated_unit)
}

// optional string status = 10;
inline bool MechanicalUnit::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MechanicalUnit::has_status() const {
  return _internal_has_status();
}
inline void MechanicalUnit::clear_status() {
  _impl_.status_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MechanicalUnit::status() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MechanicalUnit::set_status(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.status)
}
inline std::string* MechanicalUnit::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.status)
  return _s;
}
inline const std::string& MechanicalUnit::_internal_status() const {
  return _impl_.status_.Get();
}
inline void MechanicalUnit::_internal_set_status(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* MechanicalUnit::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* MechanicalUnit::release_status() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.status_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MechanicalUnit::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.status)
}

// optional .abb.robot.MechanicalUnit.Mode mode = 11 [default = DEACTIVATED];
inline bool MechanicalUnit::_internal_has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MechanicalUnit::has_mode() const {
  return _internal_has_mode();
}
inline void MechanicalUnit::clear_mode() {
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::abb::robot::MechanicalUnit_Mode MechanicalUnit::_internal_mode() const {
  return static_cast< ::abb::robot::MechanicalUnit_Mode >(_impl_.mode_);
}
inline ::abb::robot::MechanicalUnit_Mode MechanicalUnit::mode() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.mode)
  return _internal_mode();
}
inline void MechanicalUnit::_internal_set_mode(::abb::robot::MechanicalUnit_Mode value) {
  assert(::abb::robot::MechanicalUnit_Mode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.mode_ = value;
}
inline void MechanicalUnit::set_mode(::abb::robot::MechanicalUnit_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.mode)
}

// repeated .abb.robot.StandardizedJoint standardized_joints = 12;
inline int MechanicalUnit::_internal_standardized_joints_size() const {
  return _impl_.standardized_joints_.size();
}
inline int MechanicalUnit::standardized_joints_size() const {
  return _internal_standardized_joints_size();
}
inline void MechanicalUnit::clear_standardized_joints() {
  _impl_.standardized_joints_.Clear();
}
inline ::abb::robot::StandardizedJoint* MechanicalUnit::mutable_standardized_joints(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.standardized_joints)
  return _impl_.standardized_joints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::StandardizedJoint >*
MechanicalUnit::mutable_standardized_joints() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.MechanicalUnit.standardized_joints)
  return &_impl_.standardized_joints_;
}
inline const ::abb::robot::StandardizedJoint& MechanicalUnit::_internal_standardized_joints(int index) const {
  return _impl_.standardized_joints_.Get(index);
}
inline const ::abb::robot::StandardizedJoint& MechanicalUnit::standardized_joints(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.standardized_joints)
  return _internal_standardized_joints(index);
}
inline ::abb::robot::StandardizedJoint* MechanicalUnit::_internal_add_standardized_joints() {
  return _impl_.standardized_joints_.Add();
}
inline ::abb::robot::StandardizedJoint* MechanicalUnit::add_standardized_joints() {
  ::abb::robot::StandardizedJoint* _add = _internal_add_standardized_joints();
  // @@protoc_insertion_point(field_add:abb.robot.MechanicalUnit.standardized_joints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::StandardizedJoint >&
MechanicalUnit::standardized_joints() const {
  // @@protoc_insertion_point(field_list:abb.robot.MechanicalUnit.standardized_joints)
  return _impl_.standardized_joints_;
}

// -------------------------------------------------------------------

// MechanicalUnitGroup

// optional string name = 1;
inline bool MechanicalUnitGroup::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MechanicalUnitGroup::has_name() const {
  return _internal_has_name();
}
inline void MechanicalUnitGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MechanicalUnitGroup::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnitGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MechanicalUnitGroup::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnitGroup.name)
}
inline std::string* MechanicalUnitGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnitGroup.name)
  return _s;
}
inline const std::string& MechanicalUnitGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MechanicalUnitGroup::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MechanicalUnitGroup::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MechanicalUnitGroup::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnitGroup.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MechanicalUnitGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnitGroup.name)
}

// optional .abb.robot.MechanicalUnit robot = 2;
inline bool MechanicalUnitGroup::_internal_has_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.robot_ != nullptr);
  return value;
}
inline bool MechanicalUnitGroup::has_robot() const {
  return _internal_has_robot();
}
inline void MechanicalUnitGroup::clear_robot() {
  if (_impl_.robot_ != nullptr) _impl_.robot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::robot::MechanicalUnit& MechanicalUnitGroup::_internal_robot() const {
  const ::abb::robot::MechanicalUnit* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::robot::MechanicalUnit&>(
      ::abb::robot::_MechanicalUnit_default_instance_);
}
inline const ::abb::robot::MechanicalUnit& MechanicalUnitGroup::robot() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnitGroup.robot)
  return _internal_robot();
}
inline void MechanicalUnitGroup::unsafe_arena_set_allocated_robot(
    ::abb::robot::MechanicalUnit* robot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = robot;
  if (robot) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.robot.MechanicalUnitGroup.robot)
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::release_robot() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::MechanicalUnit* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnitGroup.robot)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::robot::MechanicalUnit* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::_internal_mutable_robot() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::robot::MechanicalUnit>(GetArenaForAllocation());
    _impl_.robot_ = p;
  }
  return _impl_.robot_;
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::mutable_robot() {
  ::abb::robot::MechanicalUnit* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnitGroup.robot)
  return _msg;
}
inline void MechanicalUnitGroup::set_allocated_robot(::abb::robot::MechanicalUnit* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnitGroup.robot)
}

// repeated .abb.robot.MechanicalUnit mechanical_units = 3;
inline int MechanicalUnitGroup::_internal_mechanical_units_size() const {
  return _impl_.mechanical_units_.size();
}
inline int MechanicalUnitGroup::mechanical_units_size() const {
  return _internal_mechanical_units_size();
}
inline void MechanicalUnitGroup::clear_mechanical_units() {
  _impl_.mechanical_units_.Clear();
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::mutable_mechanical_units(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnitGroup.mechanical_units)
  return _impl_.mechanical_units_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::MechanicalUnit >*
MechanicalUnitGroup::mutable_mechanical_units() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.MechanicalUnitGroup.mechanical_units)
  return &_impl_.mechanical_units_;
}
inline const ::abb::robot::MechanicalUnit& MechanicalUnitGroup::_internal_mechanical_units(int index) const {
  return _impl_.mechanical_units_.Get(index);
}
inline const ::abb::robot::MechanicalUnit& MechanicalUnitGroup::mechanical_units(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnitGroup.mechanical_units)
  return _internal_mechanical_units(index);
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::_internal_add_mechanical_units() {
  return _impl_.mechanical_units_.Add();
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::add_mechanical_units() {
  ::abb::robot::MechanicalUnit* _add = _internal_add_mechanical_units();
  // @@protoc_insertion_point(field_add:abb.robot.MechanicalUnitGroup.mechanical_units)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::MechanicalUnit >&
MechanicalUnitGroup::mechanical_units() const {
  // @@protoc_insertion_point(field_list:abb.robot.MechanicalUnitGroup.mechanical_units)
  return _impl_.mechanical_units_;
}

// -------------------------------------------------------------------

// RAPIDModule

// optional string name = 1;
inline bool RAPIDModule::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RAPIDModule::has_name() const {
  return _internal_has_name();
}
inline void RAPIDModule::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RAPIDModule::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDModule.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RAPIDModule::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDModule.name)
}
inline std::string* RAPIDModule::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.RAPIDModule.name)
  return _s;
}
inline const std::string& RAPIDModule::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RAPIDModule::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RAPIDModule::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RAPIDModule::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.RAPIDModule.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RAPIDModule::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RAPIDModule.name)
}

// optional string type = 2;
inline bool RAPIDModule::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RAPIDModule::has_type() const {
  return _internal_has_type();
}
inline void RAPIDModule::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RAPIDModule::type() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDModule.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RAPIDModule::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDModule.type)
}
inline std::string* RAPIDModule::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:abb.robot.RAPIDModule.type)
  return _s;
}
inline const std::string& RAPIDModule::_internal_type() const {
  return _impl_.type_.Get();
}
inline void RAPIDModule::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* RAPIDModule::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* RAPIDModule::release_type() {
  // @@protoc_insertion_point(field_release:abb.robot.RAPIDModule.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RAPIDModule::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RAPIDModule.type)
}

// -------------------------------------------------------------------

// RAPIDTask

// optional string name = 1;
inline bool RAPIDTask::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RAPIDTask::has_name() const {
  return _internal_has_name();
}
inline void RAPIDTask::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RAPIDTask::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RAPIDTask::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDTask.name)
}
inline std::string* RAPIDTask::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.RAPIDTask.name)
  return _s;
}
inline const std::string& RAPIDTask::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RAPIDTask::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RAPIDTask::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RAPIDTask::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.RAPIDTask.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RAPIDTask::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RAPIDTask.name)
}

// optional bool is_motion_task = 2;
inline bool RAPIDTask::_internal_has_is_motion_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RAPIDTask::has_is_motion_task() const {
  return _internal_has_is_motion_task();
}
inline void RAPIDTask::clear_is_motion_task() {
  _impl_.is_motion_task_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool RAPIDTask::_internal_is_motion_task() const {
  return _impl_.is_motion_task_;
}
inline bool RAPIDTask::is_motion_task() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.is_motion_task)
  return _internal_is_motion_task();
}
inline void RAPIDTask::_internal_set_is_motion_task(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.is_motion_task_ = value;
}
inline void RAPIDTask::set_is_motion_task(bool value) {
  _internal_set_is_motion_task(value);
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDTask.is_motion_task)
}

// optional bool is_active = 3;
inline bool RAPIDTask::_internal_has_is_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RAPIDTask::has_is_active() const {
  return _internal_has_is_active();
}
inline void RAPIDTask::clear_is_active() {
  _impl_.is_active_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool RAPIDTask::_internal_is_active() const {
  return _impl_.is_active_;
}
inline bool RAPIDTask::is_active() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.is_active)
  return _internal_is_active();
}
inline void RAPIDTask::_internal_set_is_active(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_active_ = value;
}
inline void RAPIDTask::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDTask.is_active)
}

// optional .abb.robot.RAPIDTask.ExecutionState execution_state = 4 [default = UNKNOWN];
inline bool RAPIDTask::_internal_has_execution_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RAPIDTask::has_execution_state() const {
  return _internal_has_execution_state();
}
inline void RAPIDTask::clear_execution_state() {
  _impl_.execution_state_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::abb::robot::RAPIDTask_ExecutionState RAPIDTask::_internal_execution_state() const {
  return static_cast< ::abb::robot::RAPIDTask_ExecutionState >(_impl_.execution_state_);
}
inline ::abb::robot::RAPIDTask_ExecutionState RAPIDTask::execution_state() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.execution_state)
  return _internal_execution_state();
}
inline void RAPIDTask::_internal_set_execution_state(::abb::robot::RAPIDTask_ExecutionState value) {
  assert(::abb::robot::RAPIDTask_ExecutionState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.execution_state_ = value;
}
inline void RAPIDTask::set_execution_state(::abb::robot::RAPIDTask_ExecutionState value) {
  _internal_set_execution_state(value);
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDTask.execution_state)
}

// repeated .abb.robot.RAPIDModule modules = 5;
inline int RAPIDTask::_internal_modules_size() const {
  return _impl_.modules_.size();
}
inline int RAPIDTask::modules_size() const {
  return _internal_modules_size();
}
inline void RAPIDTask::clear_modules() {
  _impl_.modules_.Clear();
}
inline ::abb::robot::RAPIDModule* RAPIDTask::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.RAPIDTask.modules)
  return _impl_.modules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::RAPIDModule >*
RAPIDTask::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.RAPIDTask.modules)
  return &_impl_.modules_;
}
inline const ::abb::robot::RAPIDModule& RAPIDTask::_internal_modules(int index) const {
  return _impl_.modules_.Get(index);
}
inline const ::abb::robot::RAPIDModule& RAPIDTask::modules(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.modules)
  return _internal_modules(index);
}
inline ::abb::robot::RAPIDModule* RAPIDTask::_internal_add_modules() {
  return _impl_.modules_.Add();
}
inline ::abb::robot::RAPIDModule* RAPIDTask::add_modules() {
  ::abb::robot::RAPIDModule* _add = _internal_add_modules();
  // @@protoc_insertion_point(field_add:abb.robot.RAPIDTask.modules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abb::robot::RAPIDModule >&
RAPIDTask::modules() const {
  // @@protoc_insertion_point(field_list:abb.robot.RAPIDTask.modules)
  return _impl_.modules_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace robot
}  // namespace abb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::abb::robot::MechanicalUnit_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::robot::MechanicalUnit_Type>() {
  return ::abb::robot::MechanicalUnit_Type_descriptor();
}
template <> struct is_proto_enum< ::abb::robot::MechanicalUnit_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::robot::MechanicalUnit_Mode>() {
  return ::abb::robot::MechanicalUnit_Mode_descriptor();
}
template <> struct is_proto_enum< ::abb::robot::RAPIDTask_ExecutionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::robot::RAPIDTask_ExecutionState>() {
  return ::abb::robot::RAPIDTask_ExecutionState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_robot_5fcontroller_5fdescription_2eproto
